<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/rust-mavlink/rust-mavlink/target/debug/build/mavlink-ddefb958a4cddb2b/out/ardupilotmega.rs`."><title>ardupilotmega.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-c4dbdcde0fbd8430.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../../../../../../../../../../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" disabled href="../../../../../../../../../../../../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" disabled href="../../../../../../../../../../../../static.files/ayu-be46fdc453a55015.css"><script src="../../../../../../../../../../../../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="../../../../../../../../../../../../static.files/source-script-1b95b7cca98b26e5.js"></script><script defer src="../../../../../../../../../../../../source-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><nav class="sub"><a class="sub-logo-container" href="../../../../../../../../../../../../mavlink/index.html"><img class="rust-logo" src="../../../../../../../../../../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../../../../../../../../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../../../../../../../../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../../../../../../../../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><a href="#1" id="1">1</a>
</pre><pre class="rust"><code># ! [doc = <span class="string">&quot;This file was automatically generated, do not edit&quot;</span>] <span class="kw">use crate </span>:: MavlinkVersion ; # [allow (unused_imports)] <span class="kw">use </span>num_derive :: FromPrimitive ; # [allow (unused_imports)] <span class="kw">use </span>num_traits :: FromPrimitive ; # [allow (unused_imports)] <span class="kw">use </span>num_derive :: ToPrimitive ; # [allow (unused_imports)] <span class="kw">use </span>num_traits :: ToPrimitive ; # [allow (unused_imports)] <span class="kw">use </span>bitflags :: bitflags ; <span class="kw">use crate </span>:: { Message , error :: * , bytes :: Bytes , bytes_mut :: BytesMut } ; # [cfg (feature = <span class="string">&quot;serde&quot;</span>)] <span class="kw">use </span>serde :: { Serialize , Deserialize } ; # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>ScriptingCmd { SCRIPTING_CMD_REPL_START = <span class="number">0 </span>, SCRIPTING_CMD_REPL_STOP = <span class="number">1 </span>, SCRIPTING_CMD_STOP = <span class="number">2 </span>, SCRIPTING_CMD_STOP_AND_RESTART = <span class="number">3 </span>, } <span class="kw">impl </span>ScriptingCmd { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: SCRIPTING_CMD_REPL_START ; } <span class="kw">impl </span>Default <span class="kw">for </span>ScriptingCmd { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavSysStatusSensor : u32 { <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_GYRO = <span class="number">1 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_ACCEL = <span class="number">2 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_MAG = <span class="number">4 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_ABSOLUTE_PRESSURE = <span class="number">8 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_DIFFERENTIAL_PRESSURE = <span class="number">16 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_GPS = <span class="number">32 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_OPTICAL_FLOW = <span class="number">64 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_VISION_POSITION = <span class="number">128 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_LASER_POSITION = <span class="number">256 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_EXTERNAL_GROUND_TRUTH = <span class="number">512 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_ANGULAR_RATE_CONTROL = <span class="number">1024 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_ATTITUDE_STABILIZATION = <span class="number">2048 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_YAW_POSITION = <span class="number">4096 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_Z_ALTITUDE_CONTROL = <span class="number">8192 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_XY_POSITION_CONTROL = <span class="number">16384 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_MOTOR_OUTPUTS = <span class="number">32768 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_RC_RECEIVER = <span class="number">65536 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_GYRO2 = <span class="number">131072 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_ACCEL2 = <span class="number">262144 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_3D_MAG2 = <span class="number">524288 </span>; <span class="kw">const </span>MAV_SYS_STATUS_GEOFENCE = <span class="number">1048576 </span>; <span class="kw">const </span>MAV_SYS_STATUS_AHRS = <span class="number">2097152 </span>; <span class="kw">const </span>MAV_SYS_STATUS_TERRAIN = <span class="number">4194304 </span>; <span class="kw">const </span>MAV_SYS_STATUS_REVERSE_MOTOR = <span class="number">8388608 </span>; <span class="kw">const </span>MAV_SYS_STATUS_LOGGING = <span class="number">16777216 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_BATTERY = <span class="number">33554432 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_PROXIMITY = <span class="number">67108864 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_SATCOM = <span class="number">134217728 </span>; <span class="kw">const </span>MAV_SYS_STATUS_PREARM_CHECK = <span class="number">268435456 </span>; <span class="kw">const </span>MAV_SYS_STATUS_OBSTACLE_AVOIDANCE = <span class="number">536870912 </span>; <span class="kw">const </span>MAV_SYS_STATUS_SENSOR_PROPULSION = <span class="number">1073741824 </span>; <span class="kw">const </span>MAV_SYS_STATUS_EXTENSION_USED = <span class="number">2147483648 </span>; } } <span class="kw">impl </span>MavSysStatusSensor { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_SYS_STATUS_SENSOR_3D_GYRO ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavSysStatusSensor { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavVtolState { MAV_VTOL_STATE_UNDEFINED = <span class="number">0 </span>, MAV_VTOL_STATE_TRANSITION_TO_FW = <span class="number">1 </span>, MAV_VTOL_STATE_TRANSITION_TO_MC = <span class="number">2 </span>, MAV_VTOL_STATE_MC = <span class="number">3 </span>, MAV_VTOL_STATE_FW = <span class="number">4 </span>, } <span class="kw">impl </span>MavVtolState { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_VTOL_STATE_UNDEFINED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavVtolState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UtmDataAvailFlags : u8 { <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_TIME_VALID = <span class="number">1 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_UAS_ID_AVAILABLE = <span class="number">2 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_POSITION_AVAILABLE = <span class="number">4 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_ALTITUDE_AVAILABLE = <span class="number">8 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_RELATIVE_ALTITUDE_AVAILABLE = <span class="number">16 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_HORIZONTAL_VELO_AVAILABLE = <span class="number">32 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_VERTICAL_VELO_AVAILABLE = <span class="number">64 </span>; <span class="kw">const </span>UTM_DATA_AVAIL_FLAGS_NEXT_WAYPOINT_AVAILABLE = <span class="number">128 </span>; } } <span class="kw">impl </span>UtmDataAvailFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UTM_DATA_AVAIL_FLAGS_TIME_VALID ; } <span class="kw">impl </span>Default <span class="kw">for </span>UtmDataAvailFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavionixAdsbOutDynamicGpsFix { UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_0 = <span class="number">0 </span>, UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_1 = <span class="number">1 </span>, UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_2D = <span class="number">2 </span>, UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_3D = <span class="number">3 </span>, UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_DGPS = <span class="number">4 </span>, UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_RTK = <span class="number">5 </span>, } <span class="kw">impl </span>UavionixAdsbOutDynamicGpsFix { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC_GPS_FIX_NONE_0 ; } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutDynamicGpsFix { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidSpeedAcc { MAV_ODID_SPEED_ACC_UNKNOWN = <span class="number">0 </span>, MAV_ODID_SPEED_ACC_10_METERS_PER_SECOND = <span class="number">1 </span>, MAV_ODID_SPEED_ACC_3_METERS_PER_SECOND = <span class="number">2 </span>, MAV_ODID_SPEED_ACC_1_METERS_PER_SECOND = <span class="number">3 </span>, MAV_ODID_SPEED_ACC_0_3_METERS_PER_SECOND = <span class="number">4 </span>, } <span class="kw">impl </span>MavOdidSpeedAcc { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_SPEED_ACC_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidSpeedAcc { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GimbalDeviceCapFlags : u16 { <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_RETRACT = <span class="number">1 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_NEUTRAL = <span class="number">2 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_AXIS = <span class="number">4 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_FOLLOW = <span class="number">8 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_ROLL_LOCK = <span class="number">16 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_AXIS = <span class="number">32 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_FOLLOW = <span class="number">64 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_PITCH_LOCK = <span class="number">128 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_AXIS = <span class="number">256 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_FOLLOW = <span class="number">512 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_YAW_LOCK = <span class="number">1024 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_INFINITE_YAW = <span class="number">2048 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_SUPPORTS_YAW_IN_EARTH_FRAME = <span class="number">4096 </span>; <span class="kw">const </span>GIMBAL_DEVICE_CAP_FLAGS_HAS_RC_INPUTS = <span class="number">8192 </span>; } } <span class="kw">impl </span>GimbalDeviceCapFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GIMBAL_DEVICE_CAP_FLAGS_HAS_RETRACT ; } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalDeviceCapFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidOperatorLocationType { MAV_ODID_OPERATOR_LOCATION_TYPE_TAKEOFF = <span class="number">0 </span>, MAV_ODID_OPERATOR_LOCATION_TYPE_LIVE_GNSS = <span class="number">1 </span>, MAV_ODID_OPERATOR_LOCATION_TYPE_FIXED = <span class="number">2 </span>, } <span class="kw">impl </span>MavOdidOperatorLocationType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_OPERATOR_LOCATION_TYPE_TAKEOFF ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidOperatorLocationType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavCmd { MAV_CMD_NAV_WAYPOINT = <span class="number">16 </span>, MAV_CMD_NAV_LOITER_UNLIM = <span class="number">17 </span>, MAV_CMD_NAV_LOITER_TURNS = <span class="number">18 </span>, MAV_CMD_NAV_LOITER_TIME = <span class="number">19 </span>, MAV_CMD_NAV_RETURN_TO_LAUNCH = <span class="number">20 </span>, MAV_CMD_NAV_LAND = <span class="number">21 </span>, MAV_CMD_NAV_TAKEOFF = <span class="number">22 </span>, MAV_CMD_NAV_LAND_LOCAL = <span class="number">23 </span>, MAV_CMD_NAV_TAKEOFF_LOCAL = <span class="number">24 </span>, MAV_CMD_NAV_FOLLOW = <span class="number">25 </span>, MAV_CMD_NAV_CONTINUE_AND_CHANGE_ALT = <span class="number">30 </span>, MAV_CMD_NAV_LOITER_TO_ALT = <span class="number">31 </span>, MAV_CMD_DO_FOLLOW = <span class="number">32 </span>, MAV_CMD_DO_FOLLOW_REPOSITION = <span class="number">33 </span>, MAV_CMD_DO_ORBIT = <span class="number">34 </span>, MAV_CMD_NAV_ROI = <span class="number">80 </span>, MAV_CMD_NAV_PATHPLANNING = <span class="number">81 </span>, MAV_CMD_NAV_SPLINE_WAYPOINT = <span class="number">82 </span>, MAV_CMD_NAV_VTOL_TAKEOFF = <span class="number">84 </span>, MAV_CMD_NAV_VTOL_LAND = <span class="number">85 </span>, MAV_CMD_NAV_GUIDED_ENABLE = <span class="number">92 </span>, MAV_CMD_NAV_DELAY = <span class="number">93 </span>, MAV_CMD_NAV_PAYLOAD_PLACE = <span class="number">94 </span>, MAV_CMD_NAV_LAST = <span class="number">95 </span>, MAV_CMD_CONDITION_DELAY = <span class="number">112 </span>, MAV_CMD_CONDITION_CHANGE_ALT = <span class="number">113 </span>, MAV_CMD_CONDITION_DISTANCE = <span class="number">114 </span>, MAV_CMD_CONDITION_YAW = <span class="number">115 </span>, MAV_CMD_CONDITION_LAST = <span class="number">159 </span>, MAV_CMD_DO_SET_MODE = <span class="number">176 </span>, MAV_CMD_DO_JUMP = <span class="number">177 </span>, MAV_CMD_DO_CHANGE_SPEED = <span class="number">178 </span>, MAV_CMD_DO_SET_HOME = <span class="number">179 </span>, MAV_CMD_DO_SET_PARAMETER = <span class="number">180 </span>, MAV_CMD_DO_SET_RELAY = <span class="number">181 </span>, MAV_CMD_DO_REPEAT_RELAY = <span class="number">182 </span>, MAV_CMD_DO_SET_SERVO = <span class="number">183 </span>, MAV_CMD_DO_REPEAT_SERVO = <span class="number">184 </span>, MAV_CMD_DO_FLIGHTTERMINATION = <span class="number">185 </span>, MAV_CMD_DO_CHANGE_ALTITUDE = <span class="number">186 </span>, MAV_CMD_DO_SET_ACTUATOR = <span class="number">187 </span>, MAV_CMD_DO_LAND_START = <span class="number">189 </span>, MAV_CMD_DO_RALLY_LAND = <span class="number">190 </span>, MAV_CMD_DO_GO_AROUND = <span class="number">191 </span>, MAV_CMD_DO_REPOSITION = <span class="number">192 </span>, MAV_CMD_DO_PAUSE_CONTINUE = <span class="number">193 </span>, MAV_CMD_DO_SET_REVERSE = <span class="number">194 </span>, MAV_CMD_DO_SET_ROI_LOCATION = <span class="number">195 </span>, MAV_CMD_DO_SET_ROI_WPNEXT_OFFSET = <span class="number">196 </span>, MAV_CMD_DO_SET_ROI_NONE = <span class="number">197 </span>, MAV_CMD_DO_SET_ROI_SYSID = <span class="number">198 </span>, MAV_CMD_DO_CONTROL_VIDEO = <span class="number">200 </span>, MAV_CMD_DO_SET_ROI = <span class="number">201 </span>, MAV_CMD_DO_DIGICAM_CONFIGURE = <span class="number">202 </span>, MAV_CMD_DO_DIGICAM_CONTROL = <span class="number">203 </span>, MAV_CMD_DO_MOUNT_CONFIGURE = <span class="number">204 </span>, MAV_CMD_DO_MOUNT_CONTROL = <span class="number">205 </span>, MAV_CMD_DO_SET_CAM_TRIGG_DIST = <span class="number">206 </span>, MAV_CMD_DO_FENCE_ENABLE = <span class="number">207 </span>, MAV_CMD_DO_PARACHUTE = <span class="number">208 </span>, MAV_CMD_DO_MOTOR_TEST = <span class="number">209 </span>, MAV_CMD_DO_INVERTED_FLIGHT = <span class="number">210 </span>, MAV_CMD_DO_GRIPPER = <span class="number">211 </span>, MAV_CMD_DO_AUTOTUNE_ENABLE = <span class="number">212 </span>, MAV_CMD_NAV_SET_YAW_SPEED = <span class="number">213 </span>, MAV_CMD_DO_SET_CAM_TRIGG_INTERVAL = <span class="number">214 </span>, MAV_CMD_DO_MOUNT_CONTROL_QUAT = <span class="number">220 </span>, MAV_CMD_DO_GUIDED_MASTER = <span class="number">221 </span>, MAV_CMD_DO_GUIDED_LIMITS = <span class="number">222 </span>, MAV_CMD_DO_ENGINE_CONTROL = <span class="number">223 </span>, MAV_CMD_DO_SET_MISSION_CURRENT = <span class="number">224 </span>, MAV_CMD_DO_LAST = <span class="number">240 </span>, MAV_CMD_PREFLIGHT_CALIBRATION = <span class="number">241 </span>, MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS = <span class="number">242 </span>, MAV_CMD_PREFLIGHT_UAVCAN = <span class="number">243 </span>, MAV_CMD_PREFLIGHT_STORAGE = <span class="number">245 </span>, MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN = <span class="number">246 </span>, MAV_CMD_OVERRIDE_GOTO = <span class="number">252 </span>, MAV_CMD_OBLIQUE_SURVEY = <span class="number">260 </span>, MAV_CMD_MISSION_START = <span class="number">300 </span>, MAV_CMD_ACTUATOR_TEST = <span class="number">310 </span>, MAV_CMD_CONFIGURE_ACTUATOR = <span class="number">311 </span>, MAV_CMD_COMPONENT_ARM_DISARM = <span class="number">400 </span>, MAV_CMD_RUN_PREARM_CHECKS = <span class="number">401 </span>, MAV_CMD_ILLUMINATOR_ON_OFF = <span class="number">405 </span>, MAV_CMD_GET_HOME_POSITION = <span class="number">410 </span>, MAV_CMD_INJECT_FAILURE = <span class="number">420 </span>, MAV_CMD_START_RX_PAIR = <span class="number">500 </span>, MAV_CMD_GET_MESSAGE_INTERVAL = <span class="number">510 </span>, MAV_CMD_SET_MESSAGE_INTERVAL = <span class="number">511 </span>, MAV_CMD_REQUEST_MESSAGE = <span class="number">512 </span>, MAV_CMD_REQUEST_PROTOCOL_VERSION = <span class="number">519 </span>, MAV_CMD_REQUEST_AUTOPILOT_CAPABILITIES = <span class="number">520 </span>, MAV_CMD_REQUEST_CAMERA_INFORMATION = <span class="number">521 </span>, MAV_CMD_REQUEST_CAMERA_SETTINGS = <span class="number">522 </span>, MAV_CMD_REQUEST_STORAGE_INFORMATION = <span class="number">525 </span>, MAV_CMD_STORAGE_FORMAT = <span class="number">526 </span>, MAV_CMD_REQUEST_CAMERA_CAPTURE_STATUS = <span class="number">527 </span>, MAV_CMD_REQUEST_FLIGHT_INFORMATION = <span class="number">528 </span>, MAV_CMD_RESET_CAMERA_SETTINGS = <span class="number">529 </span>, MAV_CMD_SET_CAMERA_MODE = <span class="number">530 </span>, MAV_CMD_SET_CAMERA_ZOOM = <span class="number">531 </span>, MAV_CMD_SET_CAMERA_FOCUS = <span class="number">532 </span>, MAV_CMD_SET_STORAGE_USAGE = <span class="number">533 </span>, MAV_CMD_JUMP_TAG = <span class="number">600 </span>, MAV_CMD_DO_JUMP_TAG = <span class="number">601 </span>, MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW = <span class="number">1000 </span>, MAV_CMD_DO_GIMBAL_MANAGER_CONFIGURE = <span class="number">1001 </span>, MAV_CMD_IMAGE_START_CAPTURE = <span class="number">2000 </span>, MAV_CMD_IMAGE_STOP_CAPTURE = <span class="number">2001 </span>, MAV_CMD_REQUEST_CAMERA_IMAGE_CAPTURE = <span class="number">2002 </span>, MAV_CMD_DO_TRIGGER_CONTROL = <span class="number">2003 </span>, MAV_CMD_CAMERA_TRACK_POINT = <span class="number">2004 </span>, MAV_CMD_CAMERA_TRACK_RECTANGLE = <span class="number">2005 </span>, MAV_CMD_CAMERA_STOP_TRACKING = <span class="number">2010 </span>, MAV_CMD_VIDEO_START_CAPTURE = <span class="number">2500 </span>, MAV_CMD_VIDEO_STOP_CAPTURE = <span class="number">2501 </span>, MAV_CMD_VIDEO_START_STREAMING = <span class="number">2502 </span>, MAV_CMD_VIDEO_STOP_STREAMING = <span class="number">2503 </span>, MAV_CMD_REQUEST_VIDEO_STREAM_INFORMATION = <span class="number">2504 </span>, MAV_CMD_REQUEST_VIDEO_STREAM_STATUS = <span class="number">2505 </span>, MAV_CMD_LOGGING_START = <span class="number">2510 </span>, MAV_CMD_LOGGING_STOP = <span class="number">2511 </span>, MAV_CMD_AIRFRAME_CONFIGURATION = <span class="number">2520 </span>, MAV_CMD_CONTROL_HIGH_LATENCY = <span class="number">2600 </span>, MAV_CMD_PANORAMA_CREATE = <span class="number">2800 </span>, MAV_CMD_DO_VTOL_TRANSITION = <span class="number">3000 </span>, MAV_CMD_ARM_AUTHORIZATION_REQUEST = <span class="number">3001 </span>, MAV_CMD_SET_GUIDED_SUBMODE_STANDARD = <span class="number">4000 </span>, MAV_CMD_SET_GUIDED_SUBMODE_CIRCLE = <span class="number">4001 </span>, MAV_CMD_CONDITION_GATE = <span class="number">4501 </span>, MAV_CMD_NAV_FENCE_RETURN_POINT = <span class="number">5000 </span>, MAV_CMD_NAV_FENCE_POLYGON_VERTEX_INCLUSION = <span class="number">5001 </span>, MAV_CMD_NAV_FENCE_POLYGON_VERTEX_EXCLUSION = <span class="number">5002 </span>, MAV_CMD_NAV_FENCE_CIRCLE_INCLUSION = <span class="number">5003 </span>, MAV_CMD_NAV_FENCE_CIRCLE_EXCLUSION = <span class="number">5004 </span>, MAV_CMD_NAV_RALLY_POINT = <span class="number">5100 </span>, MAV_CMD_UAVCAN_GET_NODE_INFO = <span class="number">5200 </span>, MAV_CMD_DO_ADSB_OUT_IDENT = <span class="number">10001 </span>, MAV_CMD_PAYLOAD_PREPARE_DEPLOY = <span class="number">30001 </span>, MAV_CMD_PAYLOAD_CONTROL_DEPLOY = <span class="number">30002 </span>, MAV_CMD_FIXED_MAG_CAL_YAW = <span class="number">42006 </span>, MAV_CMD_DO_WINCH = <span class="number">42600 </span>, MAV_CMD_WAYPOINT_USER_1 = <span class="number">31000 </span>, MAV_CMD_WAYPOINT_USER_2 = <span class="number">31001 </span>, MAV_CMD_WAYPOINT_USER_3 = <span class="number">31002 </span>, MAV_CMD_WAYPOINT_USER_4 = <span class="number">31003 </span>, MAV_CMD_WAYPOINT_USER_5 = <span class="number">31004 </span>, MAV_CMD_SPATIAL_USER_1 = <span class="number">31005 </span>, MAV_CMD_SPATIAL_USER_2 = <span class="number">31006 </span>, MAV_CMD_SPATIAL_USER_3 = <span class="number">31007 </span>, MAV_CMD_SPATIAL_USER_4 = <span class="number">31008 </span>, MAV_CMD_SPATIAL_USER_5 = <span class="number">31009 </span>, MAV_CMD_USER_1 = <span class="number">31010 </span>, MAV_CMD_USER_2 = <span class="number">31011 </span>, MAV_CMD_USER_3 = <span class="number">31012 </span>, MAV_CMD_USER_4 = <span class="number">31013 </span>, MAV_CMD_USER_5 = <span class="number">31014 </span>, MAV_CMD_CAN_FORWARD = <span class="number">32000 </span>, MAV_CMD_DO_SET_RESUME_REPEAT_DIST = <span class="number">215 </span>, MAV_CMD_DO_SPRAYER = <span class="number">216 </span>, MAV_CMD_DO_SEND_SCRIPT_MESSAGE = <span class="number">217 </span>, MAV_CMD_DO_AUX_FUNCTION = <span class="number">218 </span>, MAV_CMD_NAV_ALTITUDE_WAIT = <span class="number">83 </span>, MAV_CMD_POWER_OFF_INITIATED = <span class="number">42000 </span>, MAV_CMD_SOLO_BTN_FLY_CLICK = <span class="number">42001 </span>, MAV_CMD_SOLO_BTN_FLY_HOLD = <span class="number">42002 </span>, MAV_CMD_SOLO_BTN_PAUSE_CLICK = <span class="number">42003 </span>, MAV_CMD_FIXED_MAG_CAL = <span class="number">42004 </span>, MAV_CMD_FIXED_MAG_CAL_FIELD = <span class="number">42005 </span>, MAV_CMD_SET_EKF_SOURCE_SET = <span class="number">42007 </span>, MAV_CMD_DO_START_MAG_CAL = <span class="number">42424 </span>, MAV_CMD_DO_ACCEPT_MAG_CAL = <span class="number">42425 </span>, MAV_CMD_DO_CANCEL_MAG_CAL = <span class="number">42426 </span>, MAV_CMD_ACCELCAL_VEHICLE_POS = <span class="number">42429 </span>, MAV_CMD_DO_SEND_BANNER = <span class="number">42428 </span>, MAV_CMD_SET_FACTORY_TEST_MODE = <span class="number">42427 </span>, MAV_CMD_GIMBAL_RESET = <span class="number">42501 </span>, MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS = <span class="number">42502 </span>, MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION = <span class="number">42503 </span>, MAV_CMD_GIMBAL_FULL_RESET = <span class="number">42505 </span>, MAV_CMD_FLASH_BOOTLOADER = <span class="number">42650 </span>, MAV_CMD_BATTERY_RESET = <span class="number">42651 </span>, MAV_CMD_DEBUG_TRAP = <span class="number">42700 </span>, MAV_CMD_SCRIPTING = <span class="number">42701 </span>, MAV_CMD_NAV_SCRIPT_TIME = <span class="number">42702 </span>, MAV_CMD_NAV_ATTITUDE_TIME = <span class="number">42703 </span>, MAV_CMD_GUIDED_CHANGE_SPEED = <span class="number">43000 </span>, MAV_CMD_GUIDED_CHANGE_ALTITUDE = <span class="number">43001 </span>, MAV_CMD_GUIDED_CHANGE_HEADING = <span class="number">43002 </span>, } <span class="kw">impl </span>MavCmd { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_CMD_NAV_WAYPOINT ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavCmd { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MotorTestOrder { MOTOR_TEST_ORDER_DEFAULT = <span class="number">0 </span>, MOTOR_TEST_ORDER_SEQUENCE = <span class="number">1 </span>, MOTOR_TEST_ORDER_BOARD = <span class="number">2 </span>, } <span class="kw">impl </span>MotorTestOrder { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MOTOR_TEST_ORDER_DEFAULT ; } <span class="kw">impl </span>Default <span class="kw">for </span>MotorTestOrder { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>SetFocusType { FOCUS_TYPE_STEP = <span class="number">0 </span>, FOCUS_TYPE_CONTINUOUS = <span class="number">1 </span>, FOCUS_TYPE_RANGE = <span class="number">2 </span>, FOCUS_TYPE_METERS = <span class="number">3 </span>, FOCUS_TYPE_AUTO = <span class="number">4 </span>, FOCUS_TYPE_AUTO_SINGLE = <span class="number">5 </span>, FOCUS_TYPE_AUTO_CONTINUOUS = <span class="number">6 </span>, } <span class="kw">impl </span>SetFocusType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: FOCUS_TYPE_STEP ; } <span class="kw">impl </span>Default <span class="kw">for </span>SetFocusType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidDescType { MAV_ODID_DESC_TYPE_TEXT = <span class="number">0 </span>, MAV_ODID_DESC_TYPE_EMERGENCY = <span class="number">1 </span>, MAV_ODID_DESC_TYPE_EXTENDED_STATUS = <span class="number">2 </span>, } <span class="kw">impl </span>MavOdidDescType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_DESC_TYPE_TEXT ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidDescType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavionixAdsbOutCfgGpsOffsetLat { UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_NO_DATA = <span class="number">0 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_2M = <span class="number">1 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_4M = <span class="number">2 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_LEFT_6M = <span class="number">3 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_0M = <span class="number">4 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_2M = <span class="number">5 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_4M = <span class="number">6 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_RIGHT_6M = <span class="number">7 </span>, } <span class="kw">impl </span>UavionixAdsbOutCfgGpsOffsetLat { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LAT_NO_DATA ; } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutCfgGpsOffsetLat { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FailureType { FAILURE_TYPE_OK = <span class="number">0 </span>, FAILURE_TYPE_OFF = <span class="number">1 </span>, FAILURE_TYPE_STUCK = <span class="number">2 </span>, FAILURE_TYPE_GARBAGE = <span class="number">3 </span>, FAILURE_TYPE_WRONG = <span class="number">4 </span>, FAILURE_TYPE_SLOW = <span class="number">5 </span>, FAILURE_TYPE_DELAYED = <span class="number">6 </span>, FAILURE_TYPE_INTERMITTENT = <span class="number">7 </span>, } <span class="kw">impl </span>FailureType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: FAILURE_TYPE_OK ; } <span class="kw">impl </span>Default <span class="kw">for </span>FailureType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraTrackingTargetData { CAMERA_TRACKING_TARGET_DATA_NONE = <span class="number">0 </span>, CAMERA_TRACKING_TARGET_DATA_EMBEDDED = <span class="number">1 </span>, CAMERA_TRACKING_TARGET_DATA_RENDERED = <span class="number">2 </span>, CAMERA_TRACKING_TARGET_DATA_IN_STATUS = <span class="number">4 </span>, } <span class="kw">impl </span>CameraTrackingTargetData { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CAMERA_TRACKING_TARGET_DATA_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>CameraTrackingTargetData { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavlinkDataStreamType { MAVLINK_DATA_STREAM_IMG_JPEG = <span class="number">0 </span>, MAVLINK_DATA_STREAM_IMG_BMP = <span class="number">1 </span>, MAVLINK_DATA_STREAM_IMG_RAW8U = <span class="number">2 </span>, MAVLINK_DATA_STREAM_IMG_RAW32U = <span class="number">3 </span>, MAVLINK_DATA_STREAM_IMG_PGM = <span class="number">4 </span>, MAVLINK_DATA_STREAM_IMG_PNG = <span class="number">5 </span>, } <span class="kw">impl </span>MavlinkDataStreamType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAVLINK_DATA_STREAM_IMG_JPEG ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavlinkDataStreamType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidArmStatus { MAV_ODID_ARM_STATUS_GOOD_TO_ARM = <span class="number">0 </span>, MAV_ODID_ARM_STATUS_PRE_ARM_FAIL_GENERIC = <span class="number">1 </span>, } <span class="kw">impl </span>MavOdidArmStatus { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_ARM_STATUS_GOOD_TO_ARM ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidArmStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>OsdParamConfigType { OSD_PARAM_NONE = <span class="number">0 </span>, OSD_PARAM_SERIAL_PROTOCOL = <span class="number">1 </span>, OSD_PARAM_SERVO_FUNCTION = <span class="number">2 </span>, OSD_PARAM_AUX_FUNCTION = <span class="number">3 </span>, OSD_PARAM_FLIGHT_MODE = <span class="number">4 </span>, OSD_PARAM_FAILSAFE_ACTION = <span class="number">5 </span>, OSD_PARAM_FAILSAFE_ACTION_1 = <span class="number">6 </span>, OSD_PARAM_FAILSAFE_ACTION_2 = <span class="number">7 </span>, OSD_PARAM_NUM_TYPES = <span class="number">8 </span>, } <span class="kw">impl </span>OsdParamConfigType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: OSD_PARAM_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>OsdParamConfigType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavBatteryType { MAV_BATTERY_TYPE_UNKNOWN = <span class="number">0 </span>, MAV_BATTERY_TYPE_LIPO = <span class="number">1 </span>, MAV_BATTERY_TYPE_LIFE = <span class="number">2 </span>, MAV_BATTERY_TYPE_LION = <span class="number">3 </span>, MAV_BATTERY_TYPE_NIMH = <span class="number">4 </span>, } <span class="kw">impl </span>MavBatteryType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_BATTERY_TYPE_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavBatteryType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>HeadingType { HEADING_TYPE_COURSE_OVER_GROUND = <span class="number">0 </span>, HEADING_TYPE_HEADING = <span class="number">1 </span>, } <span class="kw">impl </span>HeadingType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: HEADING_TYPE_COURSE_OVER_GROUND ; } <span class="kw">impl </span>Default <span class="kw">for </span>HeadingType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproProtuneWhiteBalance { GOPRO_PROTUNE_WHITE_BALANCE_AUTO = <span class="number">0 </span>, GOPRO_PROTUNE_WHITE_BALANCE_3000K = <span class="number">1 </span>, GOPRO_PROTUNE_WHITE_BALANCE_5500K = <span class="number">2 </span>, GOPRO_PROTUNE_WHITE_BALANCE_6500K = <span class="number">3 </span>, GOPRO_PROTUNE_WHITE_BALANCE_RAW = <span class="number">4 </span>, } <span class="kw">impl </span>GoproProtuneWhiteBalance { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_PROTUNE_WHITE_BALANCE_AUTO ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproProtuneWhiteBalance { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavGoto { MAV_GOTO_DO_HOLD = <span class="number">0 </span>, MAV_GOTO_DO_CONTINUE = <span class="number">1 </span>, MAV_GOTO_HOLD_AT_CURRENT_POSITION = <span class="number">2 </span>, MAV_GOTO_HOLD_AT_SPECIFIED_POSITION = <span class="number">3 </span>, } <span class="kw">impl </span>MavGoto { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_GOTO_DO_HOLD ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavGoto { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SerialControlFlag : u8 { <span class="kw">const </span>SERIAL_CONTROL_FLAG_REPLY = <span class="number">1 </span>; <span class="kw">const </span>SERIAL_CONTROL_FLAG_RESPOND = <span class="number">2 </span>; <span class="kw">const </span>SERIAL_CONTROL_FLAG_EXCLUSIVE = <span class="number">4 </span>; <span class="kw">const </span>SERIAL_CONTROL_FLAG_BLOCKING = <span class="number">8 </span>; <span class="kw">const </span>SERIAL_CONTROL_FLAG_MULTI = <span class="number">16 </span>; } } <span class="kw">impl </span>SerialControlFlag { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: SERIAL_CONTROL_FLAG_REPLY ; } <span class="kw">impl </span>Default <span class="kw">for </span>SerialControlFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GimbalManagerCapFlags : u32 { <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_RETRACT = <span class="number">1 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_NEUTRAL = <span class="number">2 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_AXIS = <span class="number">4 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_FOLLOW = <span class="number">8 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_ROLL_LOCK = <span class="number">16 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_AXIS = <span class="number">32 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_FOLLOW = <span class="number">64 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_PITCH_LOCK = <span class="number">128 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_AXIS = <span class="number">256 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_FOLLOW = <span class="number">512 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_YAW_LOCK = <span class="number">1024 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_SUPPORTS_INFINITE_YAW = <span class="number">2048 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_SUPPORTS_YAW_IN_EARTH_FRAME = <span class="number">4096 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_HAS_RC_INPUTS = <span class="number">8192 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_CAN_POINT_LOCATION_LOCAL = <span class="number">65536 </span>; <span class="kw">const </span>GIMBAL_MANAGER_CAP_FLAGS_CAN_POINT_LOCATION_GLOBAL = <span class="number">131072 </span>; } } <span class="kw">impl </span>GimbalManagerCapFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GIMBAL_MANAGER_CAP_FLAGS_HAS_RETRACT ; } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalManagerCapFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>SerialControlDev { SERIAL_CONTROL_DEV_TELEM1 = <span class="number">0 </span>, SERIAL_CONTROL_DEV_TELEM2 = <span class="number">1 </span>, SERIAL_CONTROL_DEV_GPS1 = <span class="number">2 </span>, SERIAL_CONTROL_DEV_GPS2 = <span class="number">3 </span>, SERIAL_CONTROL_DEV_SHELL = <span class="number">10 </span>, SERIAL_CONTROL_SERIAL0 = <span class="number">100 </span>, SERIAL_CONTROL_SERIAL1 = <span class="number">101 </span>, SERIAL_CONTROL_SERIAL2 = <span class="number">102 </span>, SERIAL_CONTROL_SERIAL3 = <span class="number">103 </span>, SERIAL_CONTROL_SERIAL4 = <span class="number">104 </span>, SERIAL_CONTROL_SERIAL5 = <span class="number">105 </span>, SERIAL_CONTROL_SERIAL6 = <span class="number">106 </span>, SERIAL_CONTROL_SERIAL7 = <span class="number">107 </span>, SERIAL_CONTROL_SERIAL8 = <span class="number">108 </span>, SERIAL_CONTROL_SERIAL9 = <span class="number">109 </span>, } <span class="kw">impl </span>SerialControlDev { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: SERIAL_CONTROL_DEV_TELEM1 ; } <span class="kw">impl </span>Default <span class="kw">for </span>SerialControlDev { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavSensorOrientation { MAV_SENSOR_ROTATION_NONE = <span class="number">0 </span>, MAV_SENSOR_ROTATION_YAW_45 = <span class="number">1 </span>, MAV_SENSOR_ROTATION_YAW_90 = <span class="number">2 </span>, MAV_SENSOR_ROTATION_YAW_135 = <span class="number">3 </span>, MAV_SENSOR_ROTATION_YAW_180 = <span class="number">4 </span>, MAV_SENSOR_ROTATION_YAW_225 = <span class="number">5 </span>, MAV_SENSOR_ROTATION_YAW_270 = <span class="number">6 </span>, MAV_SENSOR_ROTATION_YAW_315 = <span class="number">7 </span>, MAV_SENSOR_ROTATION_ROLL_180 = <span class="number">8 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_45 = <span class="number">9 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_90 = <span class="number">10 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_135 = <span class="number">11 </span>, MAV_SENSOR_ROTATION_PITCH_180 = <span class="number">12 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_225 = <span class="number">13 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_270 = <span class="number">14 </span>, MAV_SENSOR_ROTATION_ROLL_180_YAW_315 = <span class="number">15 </span>, MAV_SENSOR_ROTATION_ROLL_90 = <span class="number">16 </span>, MAV_SENSOR_ROTATION_ROLL_90_YAW_45 = <span class="number">17 </span>, MAV_SENSOR_ROTATION_ROLL_90_YAW_90 = <span class="number">18 </span>, MAV_SENSOR_ROTATION_ROLL_90_YAW_135 = <span class="number">19 </span>, MAV_SENSOR_ROTATION_ROLL_270 = <span class="number">20 </span>, MAV_SENSOR_ROTATION_ROLL_270_YAW_45 = <span class="number">21 </span>, MAV_SENSOR_ROTATION_ROLL_270_YAW_90 = <span class="number">22 </span>, MAV_SENSOR_ROTATION_ROLL_270_YAW_135 = <span class="number">23 </span>, MAV_SENSOR_ROTATION_PITCH_90 = <span class="number">24 </span>, MAV_SENSOR_ROTATION_PITCH_270 = <span class="number">25 </span>, MAV_SENSOR_ROTATION_PITCH_180_YAW_90 = <span class="number">26 </span>, MAV_SENSOR_ROTATION_PITCH_180_YAW_270 = <span class="number">27 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_90 = <span class="number">28 </span>, MAV_SENSOR_ROTATION_ROLL_180_PITCH_90 = <span class="number">29 </span>, MAV_SENSOR_ROTATION_ROLL_270_PITCH_90 = <span class="number">30 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_180 = <span class="number">31 </span>, MAV_SENSOR_ROTATION_ROLL_270_PITCH_180 = <span class="number">32 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_270 = <span class="number">33 </span>, MAV_SENSOR_ROTATION_ROLL_180_PITCH_270 = <span class="number">34 </span>, MAV_SENSOR_ROTATION_ROLL_270_PITCH_270 = <span class="number">35 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_180_YAW_90 = <span class="number">36 </span>, MAV_SENSOR_ROTATION_ROLL_90_YAW_270 = <span class="number">37 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_68_YAW_293 = <span class="number">38 </span>, MAV_SENSOR_ROTATION_PITCH_315 = <span class="number">39 </span>, MAV_SENSOR_ROTATION_ROLL_90_PITCH_315 = <span class="number">40 </span>, MAV_SENSOR_ROTATION_CUSTOM = <span class="number">100 </span>, } <span class="kw">impl </span>MavSensorOrientation { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_SENSOR_ROTATION_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavSensorOrientation { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavionixAdsbEmergencyStatus { UAVIONIX_ADSB_OUT_NO_EMERGENCY = <span class="number">0 </span>, UAVIONIX_ADSB_OUT_GENERAL_EMERGENCY = <span class="number">1 </span>, UAVIONIX_ADSB_OUT_LIFEGUARD_EMERGENCY = <span class="number">2 </span>, UAVIONIX_ADSB_OUT_MINIMUM_FUEL_EMERGENCY = <span class="number">3 </span>, UAVIONIX_ADSB_OUT_NO_COMM_EMERGENCY = <span class="number">4 </span>, UAVIONIX_ADSB_OUT_UNLAWFUL_INTERFERANCE_EMERGENCY = <span class="number">5 </span>, UAVIONIX_ADSB_OUT_DOWNED_AIRCRAFT_EMERGENCY = <span class="number">6 </span>, UAVIONIX_ADSB_OUT_RESERVED = <span class="number">7 </span>, } <span class="kw">impl </span>UavionixAdsbEmergencyStatus { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_NO_EMERGENCY ; } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbEmergencyStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>VtolTransitionHeading { VTOL_TRANSITION_HEADING_VEHICLE_DEFAULT = <span class="number">0 </span>, VTOL_TRANSITION_HEADING_NEXT_WAYPOINT = <span class="number">1 </span>, VTOL_TRANSITION_HEADING_TAKEOFF = <span class="number">2 </span>, VTOL_TRANSITION_HEADING_SPECIFIED = <span class="number">3 </span>, VTOL_TRANSITION_HEADING_ANY = <span class="number">4 </span>, } <span class="kw">impl </span>VtolTransitionHeading { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: VTOL_TRANSITION_HEADING_VEHICLE_DEFAULT ; } <span class="kw">impl </span>Default <span class="kw">for </span>VtolTransitionHeading { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>OsdParamConfigError { OSD_PARAM_SUCCESS = <span class="number">0 </span>, OSD_PARAM_INVALID_SCREEN = <span class="number">1 </span>, OSD_PARAM_INVALID_PARAMETER_INDEX = <span class="number">2 </span>, OSD_PARAM_INVALID_PARAMETER = <span class="number">3 </span>, } <span class="kw">impl </span>OsdParamConfigError { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: OSD_PARAM_SUCCESS ; } <span class="kw">impl </span>Default <span class="kw">for </span>OsdParamConfigError { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraTrackingMode { CAMERA_TRACKING_MODE_NONE = <span class="number">0 </span>, CAMERA_TRACKING_MODE_POINT = <span class="number">1 </span>, CAMERA_TRACKING_MODE_RECTANGLE = <span class="number">2 </span>, } <span class="kw">impl </span>CameraTrackingMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CAMERA_TRACKING_MODE_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>CameraTrackingMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HighresImuUpdatedFlags : u16 { <span class="kw">const </span>HIGHRES_IMU_UPDATED_NONE = <span class="number">0 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_XACC = <span class="number">1 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_YACC = <span class="number">2 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_ZACC = <span class="number">4 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_XGYRO = <span class="number">8 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_YGYRO = <span class="number">16 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_ZGYRO = <span class="number">32 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_XMAG = <span class="number">64 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_YMAG = <span class="number">128 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_ZMAG = <span class="number">256 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_ABS_PRESSURE = <span class="number">512 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_DIFF_PRESSURE = <span class="number">1024 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_PRESSURE_ALT = <span class="number">2048 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_TEMPERATURE = <span class="number">4096 </span>; <span class="kw">const </span>HIGHRES_IMU_UPDATED_ALL = <span class="number">65535 </span>; } } <span class="kw">impl </span>HighresImuUpdatedFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: HIGHRES_IMU_UPDATED_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>HighresImuUpdatedFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavionixAdsbOutCfgAircraftSize { UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_NO_DATA = <span class="number">0 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L15M_W23M = <span class="number">1 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25M_W28P5M = <span class="number">2 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L25_34M = <span class="number">3 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_33M = <span class="number">4 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L35_38M = <span class="number">5 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_39P5M = <span class="number">6 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L45_45M = <span class="number">7 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_45M = <span class="number">8 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L55_52M = <span class="number">9 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_59P5M = <span class="number">10 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L65_67M = <span class="number">11 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W72P5M = <span class="number">12 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L75_W80M = <span class="number">13 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W80M = <span class="number">14 </span>, UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_L85_W90M = <span class="number">15 </span>, } <span class="kw">impl </span>UavionixAdsbOutCfgAircraftSize { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG_AIRCRAFT_SIZE_NO_DATA ; } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutCfgAircraftSize { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidVerAcc { MAV_ODID_VER_ACC_UNKNOWN = <span class="number">0 </span>, MAV_ODID_VER_ACC_150_METER = <span class="number">1 </span>, MAV_ODID_VER_ACC_45_METER = <span class="number">2 </span>, MAV_ODID_VER_ACC_25_METER = <span class="number">3 </span>, MAV_ODID_VER_ACC_10_METER = <span class="number">4 </span>, MAV_ODID_VER_ACC_3_METER = <span class="number">5 </span>, MAV_ODID_VER_ACC_1_METER = <span class="number">6 </span>, } <span class="kw">impl </span>MavOdidVerAcc { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_VER_ACC_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidVerAcc { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavBatteryFunction { MAV_BATTERY_FUNCTION_UNKNOWN = <span class="number">0 </span>, MAV_BATTERY_FUNCTION_ALL = <span class="number">1 </span>, MAV_BATTERY_FUNCTION_PROPULSION = <span class="number">2 </span>, MAV_BATTERY_FUNCTION_AVIONICS = <span class="number">3 </span>, MAV_BATTERY_FUNCTION_PAYLOAD = <span class="number">4 </span>, } <span class="kw">impl </span>MavBatteryFunction { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_BATTERY_FUNCTION_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavBatteryFunction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidAuthType { MAV_ODID_AUTH_TYPE_NONE = <span class="number">0 </span>, MAV_ODID_AUTH_TYPE_UAS_ID_SIGNATURE = <span class="number">1 </span>, MAV_ODID_AUTH_TYPE_OPERATOR_ID_SIGNATURE = <span class="number">2 </span>, MAV_ODID_AUTH_TYPE_MESSAGE_SET_SIGNATURE = <span class="number">3 </span>, MAV_ODID_AUTH_TYPE_NETWORK_REMOTE_ID = <span class="number">4 </span>, MAV_ODID_AUTH_TYPE_SPECIFIC_AUTHENTICATION = <span class="number">5 </span>, } <span class="kw">impl </span>MavOdidAuthType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_AUTH_TYPE_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidAuthType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavResult { MAV_RESULT_ACCEPTED = <span class="number">0 </span>, MAV_RESULT_TEMPORARILY_REJECTED = <span class="number">1 </span>, MAV_RESULT_DENIED = <span class="number">2 </span>, MAV_RESULT_UNSUPPORTED = <span class="number">3 </span>, MAV_RESULT_FAILED = <span class="number">4 </span>, MAV_RESULT_IN_PROGRESS = <span class="number">5 </span>, MAV_RESULT_CANCELLED = <span class="number">6 </span>, } <span class="kw">impl </span>MavResult { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_RESULT_ACCEPTED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavResult { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavGeneratorStatusFlag : u64 { <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_OFF = <span class="number">1 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_READY = <span class="number">2 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_GENERATING = <span class="number">4 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_CHARGING = <span class="number">8 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_REDUCED_POWER = <span class="number">16 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_MAXPOWER = <span class="number">32 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_OVERTEMP_WARNING = <span class="number">64 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_OVERTEMP_FAULT = <span class="number">128 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_OVERTEMP_WARNING = <span class="number">256 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_OVERTEMP_FAULT = <span class="number">512 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_ELECTRONICS_FAULT = <span class="number">1024 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_POWERSOURCE_FAULT = <span class="number">2048 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_COMMUNICATION_WARNING = <span class="number">4096 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_COOLING_WARNING = <span class="number">8192 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_POWER_RAIL_FAULT = <span class="number">16384 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_OVERCURRENT_FAULT = <span class="number">32768 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_BATTERY_OVERCHARGE_CURRENT_FAULT = <span class="number">65536 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_OVERVOLTAGE_FAULT = <span class="number">131072 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_BATTERY_UNDERVOLT_FAULT = <span class="number">262144 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_START_INHIBITED = <span class="number">524288 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_MAINTENANCE_REQUIRED = <span class="number">1048576 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_WARMING_UP = <span class="number">2097152 </span>; <span class="kw">const </span>MAV_GENERATOR_STATUS_FLAG_IDLE = <span class="number">4194304 </span>; } } <span class="kw">impl </span>MavGeneratorStatusFlag { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_GENERATOR_STATUS_FLAG_OFF ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavGeneratorStatusFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraFeedbackFlags { CAMERA_FEEDBACK_PHOTO = <span class="number">0 </span>, CAMERA_FEEDBACK_VIDEO = <span class="number">1 </span>, CAMERA_FEEDBACK_BADEXPOSURE = <span class="number">2 </span>, CAMERA_FEEDBACK_CLOSEDLOOP = <span class="number">3 </span>, CAMERA_FEEDBACK_OPENLOOP = <span class="number">4 </span>, } <span class="kw">impl </span>CameraFeedbackFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CAMERA_FEEDBACK_PHOTO ; } <span class="kw">impl </span>Default <span class="kw">for </span>CameraFeedbackFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavDoRepositionFlags { MAV_DO_REPOSITION_FLAGS_CHANGE_MODE = <span class="number">1 </span>, } <span class="kw">impl </span>MavDoRepositionFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_DO_REPOSITION_FLAGS_CHANGE_MODE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavDoRepositionFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FenceAction { FENCE_ACTION_NONE = <span class="number">0 </span>, FENCE_ACTION_GUIDED = <span class="number">1 </span>, FENCE_ACTION_REPORT = <span class="number">2 </span>, FENCE_ACTION_GUIDED_THR_PASS = <span class="number">3 </span>, FENCE_ACTION_RTL = <span class="number">4 </span>, FENCE_ACTION_HOLD = <span class="number">5 </span>, FENCE_ACTION_TERMINATE = <span class="number">6 </span>, FENCE_ACTION_LAND = <span class="number">7 </span>, } <span class="kw">impl </span>FenceAction { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: FENCE_ACTION_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>FenceAction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidIdType { MAV_ODID_ID_TYPE_NONE = <span class="number">0 </span>, MAV_ODID_ID_TYPE_SERIAL_NUMBER = <span class="number">1 </span>, MAV_ODID_ID_TYPE_CAA_REGISTRATION_ID = <span class="number">2 </span>, MAV_ODID_ID_TYPE_UTM_ASSIGNED_UUID = <span class="number">3 </span>, MAV_ODID_ID_TYPE_SPECIFIC_SESSION_ID = <span class="number">4 </span>, } <span class="kw">impl </span>MavOdidIdType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_ID_TYPE_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidIdType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FenceBreach { FENCE_BREACH_NONE = <span class="number">0 </span>, FENCE_BREACH_MINALT = <span class="number">1 </span>, FENCE_BREACH_MAXALT = <span class="number">2 </span>, FENCE_BREACH_BOUNDARY = <span class="number">3 </span>, } <span class="kw">impl </span>FenceBreach { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: FENCE_BREACH_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>FenceBreach { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavMissionType { MAV_MISSION_TYPE_MISSION = <span class="number">0 </span>, MAV_MISSION_TYPE_FENCE = <span class="number">1 </span>, MAV_MISSION_TYPE_RALLY = <span class="number">2 </span>, MAV_MISSION_TYPE_ALL = <span class="number">255 </span>, } <span class="kw">impl </span>MavMissionType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_MISSION_TYPE_MISSION ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavMissionType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UtmFlightState { UTM_FLIGHT_STATE_UNKNOWN = <span class="number">1 </span>, UTM_FLIGHT_STATE_GROUND = <span class="number">2 </span>, UTM_FLIGHT_STATE_AIRBORNE = <span class="number">3 </span>, UTM_FLIGHT_STATE_EMERGENCY = <span class="number">16 </span>, UTM_FLIGHT_STATE_NOCTRL = <span class="number">32 </span>, } <span class="kw">impl </span>UtmFlightState { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UTM_FLIGHT_STATE_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>UtmFlightState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CellularStatusFlag { CELLULAR_STATUS_FLAG_UNKNOWN = <span class="number">0 </span>, CELLULAR_STATUS_FLAG_FAILED = <span class="number">1 </span>, CELLULAR_STATUS_FLAG_INITIALIZING = <span class="number">2 </span>, CELLULAR_STATUS_FLAG_LOCKED = <span class="number">3 </span>, CELLULAR_STATUS_FLAG_DISABLED = <span class="number">4 </span>, CELLULAR_STATUS_FLAG_DISABLING = <span class="number">5 </span>, CELLULAR_STATUS_FLAG_ENABLING = <span class="number">6 </span>, CELLULAR_STATUS_FLAG_ENABLED = <span class="number">7 </span>, CELLULAR_STATUS_FLAG_SEARCHING = <span class="number">8 </span>, CELLULAR_STATUS_FLAG_REGISTERED = <span class="number">9 </span>, CELLULAR_STATUS_FLAG_DISCONNECTING = <span class="number">10 </span>, CELLULAR_STATUS_FLAG_CONNECTING = <span class="number">11 </span>, CELLULAR_STATUS_FLAG_CONNECTED = <span class="number">12 </span>, } <span class="kw">impl </span>CellularStatusFlag { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CELLULAR_STATUS_FLAG_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>CellularStatusFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>LimitsState { LIMITS_INIT = <span class="number">0 </span>, LIMITS_DISABLED = <span class="number">1 </span>, LIMITS_ENABLED = <span class="number">2 </span>, LIMITS_TRIGGERED = <span class="number">3 </span>, LIMITS_RECOVERING = <span class="number">4 </span>, LIMITS_RECOVERED = <span class="number">5 </span>, } <span class="kw">impl </span>LimitsState { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: LIMITS_INIT ; } <span class="kw">impl </span>Default <span class="kw">for </span>LimitsState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproVideoSettingsFlags { GOPRO_VIDEO_SETTINGS_TV_MODE = <span class="number">1 </span>, } <span class="kw">impl </span>GoproVideoSettingsFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_VIDEO_SETTINGS_TV_MODE ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproVideoSettingsFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavEventCurrentSequenceFlags : u8 { <span class="kw">const </span>MAV_EVENT_CURRENT_SEQUENCE_FLAGS_RESET = <span class="number">1 </span>; } } <span class="kw">impl </span>MavEventCurrentSequenceFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_EVENT_CURRENT_SEQUENCE_FLAGS_RESET ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavEventCurrentSequenceFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproProtuneSharpness { GOPRO_PROTUNE_SHARPNESS_LOW = <span class="number">0 </span>, GOPRO_PROTUNE_SHARPNESS_MEDIUM = <span class="number">1 </span>, GOPRO_PROTUNE_SHARPNESS_HIGH = <span class="number">2 </span>, } <span class="kw">impl </span>GoproProtuneSharpness { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_PROTUNE_SHARPNESS_LOW ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproProtuneSharpness { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FirmwareVersionType { FIRMWARE_VERSION_TYPE_DEV = <span class="number">0 </span>, FIRMWARE_VERSION_TYPE_ALPHA = <span class="number">64 </span>, FIRMWARE_VERSION_TYPE_BETA = <span class="number">128 </span>, FIRMWARE_VERSION_TYPE_RC = <span class="number">192 </span>, FIRMWARE_VERSION_TYPE_OFFICIAL = <span class="number">255 </span>, } <span class="kw">impl </span>FirmwareVersionType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: FIRMWARE_VERSION_TYPE_DEV ; } <span class="kw">impl </span>Default <span class="kw">for </span>FirmwareVersionType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavState { MAV_STATE_UNINIT = <span class="number">0 </span>, MAV_STATE_BOOT = <span class="number">1 </span>, MAV_STATE_CALIBRATING = <span class="number">2 </span>, MAV_STATE_STANDBY = <span class="number">3 </span>, MAV_STATE_ACTIVE = <span class="number">4 </span>, MAV_STATE_CRITICAL = <span class="number">5 </span>, MAV_STATE_EMERGENCY = <span class="number">6 </span>, MAV_STATE_POWEROFF = <span class="number">7 </span>, MAV_STATE_FLIGHT_TERMINATION = <span class="number">8 </span>, } <span class="kw">impl </span>MavState { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_STATE_UNINIT ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavCollisionThreatLevel { MAV_COLLISION_THREAT_LEVEL_NONE = <span class="number">0 </span>, MAV_COLLISION_THREAT_LEVEL_LOW = <span class="number">1 </span>, MAV_COLLISION_THREAT_LEVEL_HIGH = <span class="number">2 </span>, } <span class="kw">impl </span>MavCollisionThreatLevel { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_COLLISION_THREAT_LEVEL_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavCollisionThreatLevel { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavFtpOpcode { MAV_FTP_OPCODE_NONE = <span class="number">0 </span>, MAV_FTP_OPCODE_TERMINATESESSION = <span class="number">1 </span>, MAV_FTP_OPCODE_RESETSESSION = <span class="number">2 </span>, MAV_FTP_OPCODE_LISTDIRECTORY = <span class="number">3 </span>, MAV_FTP_OPCODE_OPENFILERO = <span class="number">4 </span>, MAV_FTP_OPCODE_READFILE = <span class="number">5 </span>, MAV_FTP_OPCODE_CREATEFILE = <span class="number">6 </span>, MAV_FTP_OPCODE_WRITEFILE = <span class="number">7 </span>, MAV_FTP_OPCODE_REMOVEFILE = <span class="number">8 </span>, MAV_FTP_OPCODE_CREATEDIRECTORY = <span class="number">9 </span>, MAV_FTP_OPCODE_REMOVEDIRECTORY = <span class="number">10 </span>, MAV_FTP_OPCODE_OPENFILEWO = <span class="number">11 </span>, MAV_FTP_OPCODE_TRUNCATEFILE = <span class="number">12 </span>, MAV_FTP_OPCODE_RENAME = <span class="number">13 </span>, MAV_FTP_OPCODE_CALCFILECRC = <span class="number">14 </span>, MAV_FTP_OPCODE_BURSTREADFILE = <span class="number">15 </span>, MAV_FTP_OPCODE_ACK = <span class="number">128 </span>, MAV_FTP_OPCODE_NAK = <span class="number">129 </span>, } <span class="kw">impl </span>MavFtpOpcode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_FTP_OPCODE_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavFtpOpcode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>DeviceOpBustype { DEVICE_OP_BUSTYPE_I2C = <span class="number">0 </span>, DEVICE_OP_BUSTYPE_SPI = <span class="number">1 </span>, } <span class="kw">impl </span>DeviceOpBustype { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: DEVICE_OP_BUSTYPE_I2C ; } <span class="kw">impl </span>Default <span class="kw">for </span>DeviceOpBustype { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GimbalAxis { GIMBAL_AXIS_YAW = <span class="number">0 </span>, GIMBAL_AXIS_PITCH = <span class="number">1 </span>, GIMBAL_AXIS_ROLL = <span class="number">2 </span>, } <span class="kw">impl </span>GimbalAxis { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GIMBAL_AXIS_YAW ; } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalAxis { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AisFlags : u16 { <span class="kw">const </span>AIS_FLAGS_POSITION_ACCURACY = <span class="number">1 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_COG = <span class="number">2 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_VELOCITY = <span class="number">4 </span>; <span class="kw">const </span>AIS_FLAGS_HIGH_VELOCITY = <span class="number">8 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_TURN_RATE = <span class="number">16 </span>; <span class="kw">const </span>AIS_FLAGS_TURN_RATE_SIGN_ONLY = <span class="number">32 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_DIMENSIONS = <span class="number">64 </span>; <span class="kw">const </span>AIS_FLAGS_LARGE_BOW_DIMENSION = <span class="number">128 </span>; <span class="kw">const </span>AIS_FLAGS_LARGE_STERN_DIMENSION = <span class="number">256 </span>; <span class="kw">const </span>AIS_FLAGS_LARGE_PORT_DIMENSION = <span class="number">512 </span>; <span class="kw">const </span>AIS_FLAGS_LARGE_STARBOARD_DIMENSION = <span class="number">1024 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_CALLSIGN = <span class="number">2048 </span>; <span class="kw">const </span>AIS_FLAGS_VALID_NAME = <span class="number">4096 </span>; } } <span class="kw">impl </span>AisFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: AIS_FLAGS_POSITION_ACCURACY ; } <span class="kw">impl </span>Default <span class="kw">for </span>AisFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidClassEu { MAV_ODID_CLASS_EU_UNDECLARED = <span class="number">0 </span>, MAV_ODID_CLASS_EU_CLASS_0 = <span class="number">1 </span>, MAV_ODID_CLASS_EU_CLASS_1 = <span class="number">2 </span>, MAV_ODID_CLASS_EU_CLASS_2 = <span class="number">3 </span>, MAV_ODID_CLASS_EU_CLASS_3 = <span class="number">4 </span>, MAV_ODID_CLASS_EU_CLASS_4 = <span class="number">5 </span>, MAV_ODID_CLASS_EU_CLASS_5 = <span class="number">6 </span>, MAV_ODID_CLASS_EU_CLASS_6 = <span class="number">7 </span>, } <span class="kw">impl </span>MavOdidClassEu { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_CLASS_EU_UNDECLARED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidClassEu { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>IcarousTrackBandTypes { ICAROUS_TRACK_BAND_TYPE_NONE = <span class="number">0 </span>, ICAROUS_TRACK_BAND_TYPE_NEAR = <span class="number">1 </span>, ICAROUS_TRACK_BAND_TYPE_RECOVERY = <span class="number">2 </span>, } <span class="kw">impl </span>IcarousTrackBandTypes { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ICAROUS_TRACK_BAND_TYPE_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>IcarousTrackBandTypes { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproCharging { GOPRO_CHARGING_DISABLED = <span class="number">0 </span>, GOPRO_CHARGING_ENABLED = <span class="number">1 </span>, } <span class="kw">impl </span>GoproCharging { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_CHARGING_DISABLED ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproCharging { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>SubMode { SUB_MODE_STABILIZE = <span class="number">0 </span>, SUB_MODE_ACRO = <span class="number">1 </span>, SUB_MODE_ALT_HOLD = <span class="number">2 </span>, SUB_MODE_AUTO = <span class="number">3 </span>, SUB_MODE_GUIDED = <span class="number">4 </span>, SUB_MODE_CIRCLE = <span class="number">7 </span>, SUB_MODE_SURFACE = <span class="number">9 </span>, SUB_MODE_POSHOLD = <span class="number">16 </span>, SUB_MODE_MANUAL = <span class="number">19 </span>, } <span class="kw">impl </span>SubMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: SUB_MODE_STABILIZE ; } <span class="kw">impl </span>Default <span class="kw">for </span>SubMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CellularConfigResponse { CELLULAR_CONFIG_RESPONSE_ACCEPTED = <span class="number">0 </span>, CELLULAR_CONFIG_RESPONSE_APN_ERROR = <span class="number">1 </span>, CELLULAR_CONFIG_RESPONSE_PIN_ERROR = <span class="number">2 </span>, CELLULAR_CONFIG_RESPONSE_REJECTED = <span class="number">3 </span>, CELLULAR_CONFIG_BLOCKED_PUK_REQUIRED = <span class="number">4 </span>, } <span class="kw">impl </span>CellularConfigResponse { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CELLULAR_CONFIG_RESPONSE_ACCEPTED ; } <span class="kw">impl </span>Default <span class="kw">for </span>CellularConfigResponse { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>ParamAck { PARAM_ACK_ACCEPTED = <span class="number">0 </span>, PARAM_ACK_VALUE_UNSUPPORTED = <span class="number">1 </span>, PARAM_ACK_FAILED = <span class="number">2 </span>, PARAM_ACK_IN_PROGRESS = <span class="number">3 </span>, } <span class="kw">impl </span>ParamAck { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: PARAM_ACK_ACCEPTED ; } <span class="kw">impl </span>Default <span class="kw">for </span>ParamAck { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavParamExtType { MAV_PARAM_EXT_TYPE_UINT8 = <span class="number">1 </span>, MAV_PARAM_EXT_TYPE_INT8 = <span class="number">2 </span>, MAV_PARAM_EXT_TYPE_UINT16 = <span class="number">3 </span>, MAV_PARAM_EXT_TYPE_INT16 = <span class="number">4 </span>, MAV_PARAM_EXT_TYPE_UINT32 = <span class="number">5 </span>, MAV_PARAM_EXT_TYPE_INT32 = <span class="number">6 </span>, MAV_PARAM_EXT_TYPE_UINT64 = <span class="number">7 </span>, MAV_PARAM_EXT_TYPE_INT64 = <span class="number">8 </span>, MAV_PARAM_EXT_TYPE_REAL32 = <span class="number">9 </span>, MAV_PARAM_EXT_TYPE_REAL64 = <span class="number">10 </span>, MAV_PARAM_EXT_TYPE_CUSTOM = <span class="number">11 </span>, } <span class="kw">impl </span>MavParamExtType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_PARAM_EXT_TYPE_UINT8 ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavParamExtType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>LedControlPattern { LED_CONTROL_PATTERN_OFF = <span class="number">0 </span>, LED_CONTROL_PATTERN_FIRMWAREUPDATE = <span class="number">1 </span>, LED_CONTROL_PATTERN_CUSTOM = <span class="number">255 </span>, } <span class="kw">impl </span>LedControlPattern { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: LED_CONTROL_PATTERN_OFF ; } <span class="kw">impl </span>Default <span class="kw">for </span>LedControlPattern { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>StorageType { STORAGE_TYPE_UNKNOWN = <span class="number">0 </span>, STORAGE_TYPE_USB_STICK = <span class="number">1 </span>, STORAGE_TYPE_SD = <span class="number">2 </span>, STORAGE_TYPE_MICROSD = <span class="number">3 </span>, STORAGE_TYPE_CF = <span class="number">4 </span>, STORAGE_TYPE_CFE = <span class="number">5 </span>, STORAGE_TYPE_XQD = <span class="number">6 </span>, STORAGE_TYPE_HD = <span class="number">7 </span>, STORAGE_TYPE_OTHER = <span class="number">254 </span>, } <span class="kw">impl </span>StorageType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: STORAGE_TYPE_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>StorageType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>ParachuteAction { PARACHUTE_DISABLE = <span class="number">0 </span>, PARACHUTE_ENABLE = <span class="number">1 </span>, PARACHUTE_RELEASE = <span class="number">2 </span>, } <span class="kw">impl </span>ParachuteAction { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: PARACHUTE_DISABLE ; } <span class="kw">impl </span>Default <span class="kw">for </span>ParachuteAction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavCmdAck { MAV_CMD_ACK_OK = <span class="number">0 </span>, MAV_CMD_ACK_ERR_FAIL = <span class="number">1 </span>, MAV_CMD_ACK_ERR_ACCESS_DENIED = <span class="number">2 </span>, MAV_CMD_ACK_ERR_NOT_SUPPORTED = <span class="number">3 </span>, MAV_CMD_ACK_ERR_COORDINATE_FRAME_NOT_SUPPORTED = <span class="number">4 </span>, MAV_CMD_ACK_ERR_COORDINATES_OUT_OF_RANGE = <span class="number">5 </span>, MAV_CMD_ACK_ERR_X_LAT_OUT_OF_RANGE = <span class="number">6 </span>, MAV_CMD_ACK_ERR_Y_LON_OUT_OF_RANGE = <span class="number">7 </span>, MAV_CMD_ACK_ERR_Z_ALT_OUT_OF_RANGE = <span class="number">8 </span>, } <span class="kw">impl </span>MavCmdAck { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_CMD_ACK_OK ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavCmdAck { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AttitudeTargetTypemask : u8 { <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_BODY_ROLL_RATE_IGNORE = <span class="number">1 </span>; <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_BODY_PITCH_RATE_IGNORE = <span class="number">2 </span>; <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_BODY_YAW_RATE_IGNORE = <span class="number">4 </span>; <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_THRUST_BODY_SET = <span class="number">32 </span>; <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_THROTTLE_IGNORE = <span class="number">64 </span>; <span class="kw">const </span>ATTITUDE_TARGET_TYPEMASK_ATTITUDE_IGNORE = <span class="number">128 </span>; } } <span class="kw">impl </span>AttitudeTargetTypemask { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ATTITUDE_TARGET_TYPEMASK_BODY_ROLL_RATE_IGNORE ; } <span class="kw">impl </span>Default <span class="kw">for </span>AttitudeTargetTypemask { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavComponent { MAV_COMP_ID_ALL = <span class="number">0 </span>, MAV_COMP_ID_AUTOPILOT1 = <span class="number">1 </span>, MAV_COMP_ID_USER1 = <span class="number">25 </span>, MAV_COMP_ID_USER2 = <span class="number">26 </span>, MAV_COMP_ID_USER3 = <span class="number">27 </span>, MAV_COMP_ID_USER4 = <span class="number">28 </span>, MAV_COMP_ID_USER5 = <span class="number">29 </span>, MAV_COMP_ID_USER6 = <span class="number">30 </span>, MAV_COMP_ID_USER7 = <span class="number">31 </span>, MAV_COMP_ID_USER8 = <span class="number">32 </span>, MAV_COMP_ID_USER9 = <span class="number">33 </span>, MAV_COMP_ID_USER10 = <span class="number">34 </span>, MAV_COMP_ID_USER11 = <span class="number">35 </span>, MAV_COMP_ID_USER12 = <span class="number">36 </span>, MAV_COMP_ID_USER13 = <span class="number">37 </span>, MAV_COMP_ID_USER14 = <span class="number">38 </span>, MAV_COMP_ID_USER15 = <span class="number">39 </span>, MAV_COMP_ID_USER16 = <span class="number">40 </span>, MAV_COMP_ID_USER17 = <span class="number">41 </span>, MAV_COMP_ID_USER18 = <span class="number">42 </span>, MAV_COMP_ID_USER19 = <span class="number">43 </span>, MAV_COMP_ID_USER20 = <span class="number">44 </span>, MAV_COMP_ID_USER21 = <span class="number">45 </span>, MAV_COMP_ID_USER22 = <span class="number">46 </span>, MAV_COMP_ID_USER23 = <span class="number">47 </span>, MAV_COMP_ID_USER24 = <span class="number">48 </span>, MAV_COMP_ID_USER25 = <span class="number">49 </span>, MAV_COMP_ID_USER26 = <span class="number">50 </span>, MAV_COMP_ID_USER27 = <span class="number">51 </span>, MAV_COMP_ID_USER28 = <span class="number">52 </span>, MAV_COMP_ID_USER29 = <span class="number">53 </span>, MAV_COMP_ID_USER30 = <span class="number">54 </span>, MAV_COMP_ID_USER31 = <span class="number">55 </span>, MAV_COMP_ID_USER32 = <span class="number">56 </span>, MAV_COMP_ID_USER33 = <span class="number">57 </span>, MAV_COMP_ID_USER34 = <span class="number">58 </span>, MAV_COMP_ID_USER35 = <span class="number">59 </span>, MAV_COMP_ID_USER36 = <span class="number">60 </span>, MAV_COMP_ID_USER37 = <span class="number">61 </span>, MAV_COMP_ID_USER38 = <span class="number">62 </span>, MAV_COMP_ID_USER39 = <span class="number">63 </span>, MAV_COMP_ID_USER40 = <span class="number">64 </span>, MAV_COMP_ID_USER41 = <span class="number">65 </span>, MAV_COMP_ID_USER42 = <span class="number">66 </span>, MAV_COMP_ID_USER43 = <span class="number">67 </span>, MAV_COMP_ID_TELEMETRY_RADIO = <span class="number">68 </span>, MAV_COMP_ID_USER45 = <span class="number">69 </span>, MAV_COMP_ID_USER46 = <span class="number">70 </span>, MAV_COMP_ID_USER47 = <span class="number">71 </span>, MAV_COMP_ID_USER48 = <span class="number">72 </span>, MAV_COMP_ID_USER49 = <span class="number">73 </span>, MAV_COMP_ID_USER50 = <span class="number">74 </span>, MAV_COMP_ID_USER51 = <span class="number">75 </span>, MAV_COMP_ID_USER52 = <span class="number">76 </span>, MAV_COMP_ID_USER53 = <span class="number">77 </span>, MAV_COMP_ID_USER54 = <span class="number">78 </span>, MAV_COMP_ID_USER55 = <span class="number">79 </span>, MAV_COMP_ID_USER56 = <span class="number">80 </span>, MAV_COMP_ID_USER57 = <span class="number">81 </span>, MAV_COMP_ID_USER58 = <span class="number">82 </span>, MAV_COMP_ID_USER59 = <span class="number">83 </span>, MAV_COMP_ID_USER60 = <span class="number">84 </span>, MAV_COMP_ID_USER61 = <span class="number">85 </span>, MAV_COMP_ID_USER62 = <span class="number">86 </span>, MAV_COMP_ID_USER63 = <span class="number">87 </span>, MAV_COMP_ID_USER64 = <span class="number">88 </span>, MAV_COMP_ID_USER65 = <span class="number">89 </span>, MAV_COMP_ID_USER66 = <span class="number">90 </span>, MAV_COMP_ID_USER67 = <span class="number">91 </span>, MAV_COMP_ID_USER68 = <span class="number">92 </span>, MAV_COMP_ID_USER69 = <span class="number">93 </span>, MAV_COMP_ID_USER70 = <span class="number">94 </span>, MAV_COMP_ID_USER71 = <span class="number">95 </span>, MAV_COMP_ID_USER72 = <span class="number">96 </span>, MAV_COMP_ID_USER73 = <span class="number">97 </span>, MAV_COMP_ID_USER74 = <span class="number">98 </span>, MAV_COMP_ID_USER75 = <span class="number">99 </span>, MAV_COMP_ID_CAMERA = <span class="number">100 </span>, MAV_COMP_ID_CAMERA2 = <span class="number">101 </span>, MAV_COMP_ID_CAMERA3 = <span class="number">102 </span>, MAV_COMP_ID_CAMERA4 = <span class="number">103 </span>, MAV_COMP_ID_CAMERA5 = <span class="number">104 </span>, MAV_COMP_ID_CAMERA6 = <span class="number">105 </span>, MAV_COMP_ID_SERVO1 = <span class="number">140 </span>, MAV_COMP_ID_SERVO2 = <span class="number">141 </span>, MAV_COMP_ID_SERVO3 = <span class="number">142 </span>, MAV_COMP_ID_SERVO4 = <span class="number">143 </span>, MAV_COMP_ID_SERVO5 = <span class="number">144 </span>, MAV_COMP_ID_SERVO6 = <span class="number">145 </span>, MAV_COMP_ID_SERVO7 = <span class="number">146 </span>, MAV_COMP_ID_SERVO8 = <span class="number">147 </span>, MAV_COMP_ID_SERVO9 = <span class="number">148 </span>, MAV_COMP_ID_SERVO10 = <span class="number">149 </span>, MAV_COMP_ID_SERVO11 = <span class="number">150 </span>, MAV_COMP_ID_SERVO12 = <span class="number">151 </span>, MAV_COMP_ID_SERVO13 = <span class="number">152 </span>, MAV_COMP_ID_SERVO14 = <span class="number">153 </span>, MAV_COMP_ID_GIMBAL = <span class="number">154 </span>, MAV_COMP_ID_LOG = <span class="number">155 </span>, MAV_COMP_ID_ADSB = <span class="number">156 </span>, MAV_COMP_ID_OSD = <span class="number">157 </span>, MAV_COMP_ID_PERIPHERAL = <span class="number">158 </span>, MAV_COMP_ID_QX1_GIMBAL = <span class="number">159 </span>, MAV_COMP_ID_FLARM = <span class="number">160 </span>, MAV_COMP_ID_PARACHUTE = <span class="number">161 </span>, MAV_COMP_ID_WINCH = <span class="number">169 </span>, MAV_COMP_ID_GIMBAL2 = <span class="number">171 </span>, MAV_COMP_ID_GIMBAL3 = <span class="number">172 </span>, MAV_COMP_ID_GIMBAL4 = <span class="number">173 </span>, MAV_COMP_ID_GIMBAL5 = <span class="number">174 </span>, MAV_COMP_ID_GIMBAL6 = <span class="number">175 </span>, MAV_COMP_ID_BATTERY = <span class="number">180 </span>, MAV_COMP_ID_BATTERY2 = <span class="number">181 </span>, MAV_COMP_ID_MAVCAN = <span class="number">189 </span>, MAV_COMP_ID_MISSIONPLANNER = <span class="number">190 </span>, MAV_COMP_ID_ONBOARD_COMPUTER = <span class="number">191 </span>, MAV_COMP_ID_ONBOARD_COMPUTER2 = <span class="number">192 </span>, MAV_COMP_ID_ONBOARD_COMPUTER3 = <span class="number">193 </span>, MAV_COMP_ID_ONBOARD_COMPUTER4 = <span class="number">194 </span>, MAV_COMP_ID_PATHPLANNER = <span class="number">195 </span>, MAV_COMP_ID_OBSTACLE_AVOIDANCE = <span class="number">196 </span>, MAV_COMP_ID_VISUAL_INERTIAL_ODOMETRY = <span class="number">197 </span>, MAV_COMP_ID_PAIRING_MANAGER = <span class="number">198 </span>, MAV_COMP_ID_IMU = <span class="number">200 </span>, MAV_COMP_ID_IMU_2 = <span class="number">201 </span>, MAV_COMP_ID_IMU_3 = <span class="number">202 </span>, MAV_COMP_ID_GPS = <span class="number">220 </span>, MAV_COMP_ID_GPS2 = <span class="number">221 </span>, MAV_COMP_ID_ODID_TXRX_1 = <span class="number">236 </span>, MAV_COMP_ID_ODID_TXRX_2 = <span class="number">237 </span>, MAV_COMP_ID_ODID_TXRX_3 = <span class="number">238 </span>, MAV_COMP_ID_UDP_BRIDGE = <span class="number">240 </span>, MAV_COMP_ID_UART_BRIDGE = <span class="number">241 </span>, MAV_COMP_ID_TUNNEL_NODE = <span class="number">242 </span>, MAV_COMP_ID_SYSTEM_CONTROL = <span class="number">250 </span>, } <span class="kw">impl </span>MavComponent { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_COMP_ID_ALL ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavComponent { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PositionTargetTypemask : u16 { <span class="kw">const </span>POSITION_TARGET_TYPEMASK_X_IGNORE = <span class="number">1 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_Y_IGNORE = <span class="number">2 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_Z_IGNORE = <span class="number">4 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_VX_IGNORE = <span class="number">8 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_VY_IGNORE = <span class="number">16 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_VZ_IGNORE = <span class="number">32 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_AX_IGNORE = <span class="number">64 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_AY_IGNORE = <span class="number">128 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_AZ_IGNORE = <span class="number">256 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_FORCE_SET = <span class="number">512 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_YAW_IGNORE = <span class="number">1024 </span>; <span class="kw">const </span>POSITION_TARGET_TYPEMASK_YAW_RATE_IGNORE = <span class="number">2048 </span>; } } <span class="kw">impl </span>PositionTargetTypemask { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: POSITION_TARGET_TYPEMASK_X_IGNORE ; } <span class="kw">impl </span>Default <span class="kw">for </span>PositionTargetTypemask { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavParamType { MAV_PARAM_TYPE_UINT8 = <span class="number">1 </span>, MAV_PARAM_TYPE_INT8 = <span class="number">2 </span>, MAV_PARAM_TYPE_UINT16 = <span class="number">3 </span>, MAV_PARAM_TYPE_INT16 = <span class="number">4 </span>, MAV_PARAM_TYPE_UINT32 = <span class="number">5 </span>, MAV_PARAM_TYPE_INT32 = <span class="number">6 </span>, MAV_PARAM_TYPE_UINT64 = <span class="number">7 </span>, MAV_PARAM_TYPE_INT64 = <span class="number">8 </span>, MAV_PARAM_TYPE_REAL32 = <span class="number">9 </span>, MAV_PARAM_TYPE_REAL64 = <span class="number">10 </span>, } <span class="kw">impl </span>MavParamType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_PARAM_TYPE_UINT8 ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavParamType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MotorTestThrottleType { MOTOR_TEST_THROTTLE_PERCENT = <span class="number">0 </span>, MOTOR_TEST_THROTTLE_PWM = <span class="number">1 </span>, MOTOR_TEST_THROTTLE_PILOT = <span class="number">2 </span>, MOTOR_TEST_COMPASS_CAL = <span class="number">3 </span>, } <span class="kw">impl </span>MotorTestThrottleType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MOTOR_TEST_THROTTLE_PERCENT ; } <span class="kw">impl </span>Default <span class="kw">for </span>MotorTestThrottleType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavcanNodeMode { UAVCAN_NODE_MODE_OPERATIONAL = <span class="number">0 </span>, UAVCAN_NODE_MODE_INITIALIZATION = <span class="number">1 </span>, UAVCAN_NODE_MODE_MAINTENANCE = <span class="number">2 </span>, UAVCAN_NODE_MODE_SOFTWARE_UPDATE = <span class="number">3 </span>, UAVCAN_NODE_MODE_OFFLINE = <span class="number">7 </span>, } <span class="kw">impl </span>UavcanNodeMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UAVCAN_NODE_MODE_OPERATIONAL ; } <span class="kw">impl </span>Default <span class="kw">for </span>UavcanNodeMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavFtpErr { MAV_FTP_ERR_NONE = <span class="number">0 </span>, MAV_FTP_ERR_FAIL = <span class="number">1 </span>, MAV_FTP_ERR_FAILERRNO = <span class="number">2 </span>, MAV_FTP_ERR_INVALIDDATASIZE = <span class="number">3 </span>, MAV_FTP_ERR_INVALIDSESSION = <span class="number">4 </span>, MAV_FTP_ERR_NOSESSIONSAVAILABLE = <span class="number">5 </span>, MAV_FTP_ERR_EOF = <span class="number">6 </span>, MAV_FTP_ERR_UNKNOWNCOMMAND = <span class="number">7 </span>, MAV_FTP_ERR_FILEEXISTS = <span class="number">8 </span>, MAV_FTP_ERR_FILEPROTECTED = <span class="number">9 </span>, MAV_FTP_ERR_FILENOTFOUND = <span class="number">10 </span>, } <span class="kw">impl </span>MavFtpErr { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_FTP_ERR_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavFtpErr { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>AisNavStatus { UNDER_WAY = <span class="number">0 </span>, AIS_NAV_ANCHORED = <span class="number">1 </span>, AIS_NAV_UN_COMMANDED = <span class="number">2 </span>, AIS_NAV_RESTRICTED_MANOEUVERABILITY = <span class="number">3 </span>, AIS_NAV_DRAUGHT_CONSTRAINED = <span class="number">4 </span>, AIS_NAV_MOORED = <span class="number">5 </span>, AIS_NAV_AGROUND = <span class="number">6 </span>, AIS_NAV_FISHING = <span class="number">7 </span>, AIS_NAV_SAILING = <span class="number">8 </span>, AIS_NAV_RESERVED_HSC = <span class="number">9 </span>, AIS_NAV_RESERVED_WIG = <span class="number">10 </span>, AIS_NAV_RESERVED_1 = <span class="number">11 </span>, AIS_NAV_RESERVED_2 = <span class="number">12 </span>, AIS_NAV_RESERVED_3 = <span class="number">13 </span>, AIS_NAV_AIS_SART = <span class="number">14 </span>, AIS_NAV_UNKNOWN = <span class="number">15 </span>, } <span class="kw">impl </span>AisNavStatus { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UNDER_WAY ; } <span class="kw">impl </span>Default <span class="kw">for </span>AisNavStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>SpeedType { SPEED_TYPE_AIRSPEED = <span class="number">0 </span>, SPEED_TYPE_GROUNDSPEED = <span class="number">1 </span>, } <span class="kw">impl </span>SpeedType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: SPEED_TYPE_AIRSPEED ; } <span class="kw">impl </span>Default <span class="kw">for </span>SpeedType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavAutopilot { MAV_AUTOPILOT_GENERIC = <span class="number">0 </span>, MAV_AUTOPILOT_RESERVED = <span class="number">1 </span>, MAV_AUTOPILOT_SLUGS = <span class="number">2 </span>, MAV_AUTOPILOT_ARDUPILOTMEGA = <span class="number">3 </span>, MAV_AUTOPILOT_OPENPILOT = <span class="number">4 </span>, MAV_AUTOPILOT_GENERIC_WAYPOINTS_ONLY = <span class="number">5 </span>, MAV_AUTOPILOT_GENERIC_WAYPOINTS_AND_SIMPLE_NAVIGATION_ONLY = <span class="number">6 </span>, MAV_AUTOPILOT_GENERIC_MISSION_FULL = <span class="number">7 </span>, MAV_AUTOPILOT_INVALID = <span class="number">8 </span>, MAV_AUTOPILOT_PPZ = <span class="number">9 </span>, MAV_AUTOPILOT_UDB = <span class="number">10 </span>, MAV_AUTOPILOT_FP = <span class="number">11 </span>, MAV_AUTOPILOT_PX4 = <span class="number">12 </span>, MAV_AUTOPILOT_SMACCMPILOT = <span class="number">13 </span>, MAV_AUTOPILOT_AUTOQUAD = <span class="number">14 </span>, MAV_AUTOPILOT_ARMAZILA = <span class="number">15 </span>, MAV_AUTOPILOT_AEROB = <span class="number">16 </span>, MAV_AUTOPILOT_ASLUAV = <span class="number">17 </span>, MAV_AUTOPILOT_SMARTAP = <span class="number">18 </span>, MAV_AUTOPILOT_AIRRAILS = <span class="number">19 </span>, MAV_AUTOPILOT_REFLEX = <span class="number">20 </span>, } <span class="kw">impl </span>MavAutopilot { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_AUTOPILOT_GENERIC ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavAutopilot { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproCaptureMode { GOPRO_CAPTURE_MODE_VIDEO = <span class="number">0 </span>, GOPRO_CAPTURE_MODE_PHOTO = <span class="number">1 </span>, GOPRO_CAPTURE_MODE_BURST = <span class="number">2 </span>, GOPRO_CAPTURE_MODE_TIME_LAPSE = <span class="number">3 </span>, GOPRO_CAPTURE_MODE_MULTI_SHOT = <span class="number">4 </span>, GOPRO_CAPTURE_MODE_PLAYBACK = <span class="number">5 </span>, GOPRO_CAPTURE_MODE_SETUP = <span class="number">6 </span>, GOPRO_CAPTURE_MODE_UNKNOWN = <span class="number">255 </span>, } <span class="kw">impl </span>GoproCaptureMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_CAPTURE_MODE_VIDEO ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproCaptureMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CanFilterOp { CAN_FILTER_REPLACE = <span class="number">0 </span>, CAN_FILTER_ADD = <span class="number">1 </span>, CAN_FILTER_REMOVE = <span class="number">2 </span>, } <span class="kw">impl </span>CanFilterOp { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CAN_FILTER_REPLACE ; } <span class="kw">impl </span>Default <span class="kw">for </span>CanFilterOp { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>StorageStatus { STORAGE_STATUS_EMPTY = <span class="number">0 </span>, STORAGE_STATUS_UNFORMATTED = <span class="number">1 </span>, STORAGE_STATUS_READY = <span class="number">2 </span>, STORAGE_STATUS_NOT_SUPPORTED = <span class="number">3 </span>, } <span class="kw">impl </span>StorageStatus { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: STORAGE_STATUS_EMPTY ; } <span class="kw">impl </span>Default <span class="kw">for </span>StorageStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproResolution { GOPRO_RESOLUTION_480p = <span class="number">0 </span>, GOPRO_RESOLUTION_720p = <span class="number">1 </span>, GOPRO_RESOLUTION_960p = <span class="number">2 </span>, GOPRO_RESOLUTION_1080p = <span class="number">3 </span>, GOPRO_RESOLUTION_1440p = <span class="number">4 </span>, GOPRO_RESOLUTION_2_7k_17_9 = <span class="number">5 </span>, GOPRO_RESOLUTION_2_7k_16_9 = <span class="number">6 </span>, GOPRO_RESOLUTION_2_7k_4_3 = <span class="number">7 </span>, GOPRO_RESOLUTION_4k_16_9 = <span class="number">8 </span>, GOPRO_RESOLUTION_4k_17_9 = <span class="number">9 </span>, GOPRO_RESOLUTION_720p_SUPERVIEW = <span class="number">10 </span>, GOPRO_RESOLUTION_1080p_SUPERVIEW = <span class="number">11 </span>, GOPRO_RESOLUTION_2_7k_SUPERVIEW = <span class="number">12 </span>, GOPRO_RESOLUTION_4k_SUPERVIEW = <span class="number">13 </span>, } <span class="kw">impl </span>GoproResolution { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_RESOLUTION_480p ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproResolution { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>AisType { AIS_TYPE_UNKNOWN = <span class="number">0 </span>, AIS_TYPE_RESERVED_1 = <span class="number">1 </span>, AIS_TYPE_RESERVED_2 = <span class="number">2 </span>, AIS_TYPE_RESERVED_3 = <span class="number">3 </span>, AIS_TYPE_RESERVED_4 = <span class="number">4 </span>, AIS_TYPE_RESERVED_5 = <span class="number">5 </span>, AIS_TYPE_RESERVED_6 = <span class="number">6 </span>, AIS_TYPE_RESERVED_7 = <span class="number">7 </span>, AIS_TYPE_RESERVED_8 = <span class="number">8 </span>, AIS_TYPE_RESERVED_9 = <span class="number">9 </span>, AIS_TYPE_RESERVED_10 = <span class="number">10 </span>, AIS_TYPE_RESERVED_11 = <span class="number">11 </span>, AIS_TYPE_RESERVED_12 = <span class="number">12 </span>, AIS_TYPE_RESERVED_13 = <span class="number">13 </span>, AIS_TYPE_RESERVED_14 = <span class="number">14 </span>, AIS_TYPE_RESERVED_15 = <span class="number">15 </span>, AIS_TYPE_RESERVED_16 = <span class="number">16 </span>, AIS_TYPE_RESERVED_17 = <span class="number">17 </span>, AIS_TYPE_RESERVED_18 = <span class="number">18 </span>, AIS_TYPE_RESERVED_19 = <span class="number">19 </span>, AIS_TYPE_WIG = <span class="number">20 </span>, AIS_TYPE_WIG_HAZARDOUS_A = <span class="number">21 </span>, AIS_TYPE_WIG_HAZARDOUS_B = <span class="number">22 </span>, AIS_TYPE_WIG_HAZARDOUS_C = <span class="number">23 </span>, AIS_TYPE_WIG_HAZARDOUS_D = <span class="number">24 </span>, AIS_TYPE_WIG_RESERVED_1 = <span class="number">25 </span>, AIS_TYPE_WIG_RESERVED_2 = <span class="number">26 </span>, AIS_TYPE_WIG_RESERVED_3 = <span class="number">27 </span>, AIS_TYPE_WIG_RESERVED_4 = <span class="number">28 </span>, AIS_TYPE_WIG_RESERVED_5 = <span class="number">29 </span>, AIS_TYPE_FISHING = <span class="number">30 </span>, AIS_TYPE_TOWING = <span class="number">31 </span>, AIS_TYPE_TOWING_LARGE = <span class="number">32 </span>, AIS_TYPE_DREDGING = <span class="number">33 </span>, AIS_TYPE_DIVING = <span class="number">34 </span>, AIS_TYPE_MILITARY = <span class="number">35 </span>, AIS_TYPE_SAILING = <span class="number">36 </span>, AIS_TYPE_PLEASURE = <span class="number">37 </span>, AIS_TYPE_RESERVED_20 = <span class="number">38 </span>, AIS_TYPE_RESERVED_21 = <span class="number">39 </span>, AIS_TYPE_HSC = <span class="number">40 </span>, AIS_TYPE_HSC_HAZARDOUS_A = <span class="number">41 </span>, AIS_TYPE_HSC_HAZARDOUS_B = <span class="number">42 </span>, AIS_TYPE_HSC_HAZARDOUS_C = <span class="number">43 </span>, AIS_TYPE_HSC_HAZARDOUS_D = <span class="number">44 </span>, AIS_TYPE_HSC_RESERVED_1 = <span class="number">45 </span>, AIS_TYPE_HSC_RESERVED_2 = <span class="number">46 </span>, AIS_TYPE_HSC_RESERVED_3 = <span class="number">47 </span>, AIS_TYPE_HSC_RESERVED_4 = <span class="number">48 </span>, AIS_TYPE_HSC_UNKNOWN = <span class="number">49 </span>, AIS_TYPE_PILOT = <span class="number">50 </span>, AIS_TYPE_SAR = <span class="number">51 </span>, AIS_TYPE_TUG = <span class="number">52 </span>, AIS_TYPE_PORT_TENDER = <span class="number">53 </span>, AIS_TYPE_ANTI_POLLUTION = <span class="number">54 </span>, AIS_TYPE_LAW_ENFORCEMENT = <span class="number">55 </span>, AIS_TYPE_SPARE_LOCAL_1 = <span class="number">56 </span>, AIS_TYPE_SPARE_LOCAL_2 = <span class="number">57 </span>, AIS_TYPE_MEDICAL_TRANSPORT = <span class="number">58 </span>, AIS_TYPE_NONECOMBATANT = <span class="number">59 </span>, AIS_TYPE_PASSENGER = <span class="number">60 </span>, AIS_TYPE_PASSENGER_HAZARDOUS_A = <span class="number">61 </span>, AIS_TYPE_PASSENGER_HAZARDOUS_B = <span class="number">62 </span>, AIS_TYPE_PASSENGER_HAZARDOUS_C = <span class="number">63 </span>, AIS_TYPE_PASSENGER_HAZARDOUS_D = <span class="number">64 </span>, AIS_TYPE_PASSENGER_RESERVED_1 = <span class="number">65 </span>, AIS_TYPE_PASSENGER_RESERVED_2 = <span class="number">66 </span>, AIS_TYPE_PASSENGER_RESERVED_3 = <span class="number">67 </span>, AIS_TYPE_PASSENGER_RESERVED_4 = <span class="number">68 </span>, AIS_TYPE_PASSENGER_UNKNOWN = <span class="number">69 </span>, AIS_TYPE_CARGO = <span class="number">70 </span>, AIS_TYPE_CARGO_HAZARDOUS_A = <span class="number">71 </span>, AIS_TYPE_CARGO_HAZARDOUS_B = <span class="number">72 </span>, AIS_TYPE_CARGO_HAZARDOUS_C = <span class="number">73 </span>, AIS_TYPE_CARGO_HAZARDOUS_D = <span class="number">74 </span>, AIS_TYPE_CARGO_RESERVED_1 = <span class="number">75 </span>, AIS_TYPE_CARGO_RESERVED_2 = <span class="number">76 </span>, AIS_TYPE_CARGO_RESERVED_3 = <span class="number">77 </span>, AIS_TYPE_CARGO_RESERVED_4 = <span class="number">78 </span>, AIS_TYPE_CARGO_UNKNOWN = <span class="number">79 </span>, AIS_TYPE_TANKER = <span class="number">80 </span>, AIS_TYPE_TANKER_HAZARDOUS_A = <span class="number">81 </span>, AIS_TYPE_TANKER_HAZARDOUS_B = <span class="number">82 </span>, AIS_TYPE_TANKER_HAZARDOUS_C = <span class="number">83 </span>, AIS_TYPE_TANKER_HAZARDOUS_D = <span class="number">84 </span>, AIS_TYPE_TANKER_RESERVED_1 = <span class="number">85 </span>, AIS_TYPE_TANKER_RESERVED_2 = <span class="number">86 </span>, AIS_TYPE_TANKER_RESERVED_3 = <span class="number">87 </span>, AIS_TYPE_TANKER_RESERVED_4 = <span class="number">88 </span>, AIS_TYPE_TANKER_UNKNOWN = <span class="number">89 </span>, AIS_TYPE_OTHER = <span class="number">90 </span>, AIS_TYPE_OTHER_HAZARDOUS_A = <span class="number">91 </span>, AIS_TYPE_OTHER_HAZARDOUS_B = <span class="number">92 </span>, AIS_TYPE_OTHER_HAZARDOUS_C = <span class="number">93 </span>, AIS_TYPE_OTHER_HAZARDOUS_D = <span class="number">94 </span>, AIS_TYPE_OTHER_RESERVED_1 = <span class="number">95 </span>, AIS_TYPE_OTHER_RESERVED_2 = <span class="number">96 </span>, AIS_TYPE_OTHER_RESERVED_3 = <span class="number">97 </span>, AIS_TYPE_OTHER_RESERVED_4 = <span class="number">98 </span>, AIS_TYPE_OTHER_UNKNOWN = <span class="number">99 </span>, } <span class="kw">impl </span>AisType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: AIS_TYPE_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>AisType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CompMetadataType { COMP_METADATA_TYPE_GENERAL = <span class="number">0 </span>, COMP_METADATA_TYPE_PARAMETER = <span class="number">1 </span>, COMP_METADATA_TYPE_COMMANDS = <span class="number">2 </span>, COMP_METADATA_TYPE_PERIPHERALS = <span class="number">3 </span>, COMP_METADATA_TYPE_EVENTS = <span class="number">4 </span>, COMP_METADATA_TYPE_ACTUATORS = <span class="number">5 </span>, } <span class="kw">impl </span>CompMetadataType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: COMP_METADATA_TYPE_GENERAL ; } <span class="kw">impl </span>Default <span class="kw">for </span>CompMetadataType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EkfStatusFlags : u16 { <span class="kw">const </span>EKF_ATTITUDE = <span class="number">1 </span>; <span class="kw">const </span>EKF_VELOCITY_HORIZ = <span class="number">2 </span>; <span class="kw">const </span>EKF_VELOCITY_VERT = <span class="number">4 </span>; <span class="kw">const </span>EKF_POS_HORIZ_REL = <span class="number">8 </span>; <span class="kw">const </span>EKF_POS_HORIZ_ABS = <span class="number">16 </span>; <span class="kw">const </span>EKF_POS_VERT_ABS = <span class="number">32 </span>; <span class="kw">const </span>EKF_POS_VERT_AGL = <span class="number">64 </span>; <span class="kw">const </span>EKF_CONST_POS_MODE = <span class="number">128 </span>; <span class="kw">const </span>EKF_PRED_POS_HORIZ_REL = <span class="number">256 </span>; <span class="kw">const </span>EKF_PRED_POS_HORIZ_ABS = <span class="number">512 </span>; <span class="kw">const </span>EKF_UNINITIALIZED = <span class="number">1024 </span>; } } <span class="kw">impl </span>EkfStatusFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: EKF_ATTITUDE ; } <span class="kw">impl </span>Default <span class="kw">for </span>EkfStatusFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavRemoteLogDataBlockCommands { MAV_REMOTE_LOG_DATA_BLOCK_STOP = <span class="number">2147483645 </span>, MAV_REMOTE_LOG_DATA_BLOCK_START = <span class="number">2147483646 </span>, } <span class="kw">impl </span>MavRemoteLogDataBlockCommands { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_REMOTE_LOG_DATA_BLOCK_STOP ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavRemoteLogDataBlockCommands { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavCollisionSrc { MAV_COLLISION_SRC_ADSB = <span class="number">0 </span>, MAV_COLLISION_SRC_MAVLINK_GPS_GLOBAL_INT = <span class="number">1 </span>, } <span class="kw">impl </span>MavCollisionSrc { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_COLLISION_SRC_ADSB ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavCollisionSrc { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproProtuneColour { GOPRO_PROTUNE_COLOUR_STANDARD = <span class="number">0 </span>, GOPRO_PROTUNE_COLOUR_NEUTRAL = <span class="number">1 </span>, } <span class="kw">impl </span>GoproProtuneColour { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_PROTUNE_COLOUR_STANDARD ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproProtuneColour { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavBatteryChargeState { MAV_BATTERY_CHARGE_STATE_UNDEFINED = <span class="number">0 </span>, MAV_BATTERY_CHARGE_STATE_OK = <span class="number">1 </span>, MAV_BATTERY_CHARGE_STATE_LOW = <span class="number">2 </span>, MAV_BATTERY_CHARGE_STATE_CRITICAL = <span class="number">3 </span>, MAV_BATTERY_CHARGE_STATE_EMERGENCY = <span class="number">4 </span>, MAV_BATTERY_CHARGE_STATE_FAILED = <span class="number">5 </span>, MAV_BATTERY_CHARGE_STATE_UNHEALTHY = <span class="number">6 </span>, MAV_BATTERY_CHARGE_STATE_CHARGING = <span class="number">7 </span>, } <span class="kw">impl </span>MavBatteryChargeState { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_BATTERY_CHARGE_STATE_UNDEFINED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavBatteryChargeState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidTimeAcc { MAV_ODID_TIME_ACC_UNKNOWN = <span class="number">0 </span>, MAV_ODID_TIME_ACC_0_1_SECOND = <span class="number">1 </span>, MAV_ODID_TIME_ACC_0_2_SECOND = <span class="number">2 </span>, MAV_ODID_TIME_ACC_0_3_SECOND = <span class="number">3 </span>, MAV_ODID_TIME_ACC_0_4_SECOND = <span class="number">4 </span>, MAV_ODID_TIME_ACC_0_5_SECOND = <span class="number">5 </span>, MAV_ODID_TIME_ACC_0_6_SECOND = <span class="number">6 </span>, MAV_ODID_TIME_ACC_0_7_SECOND = <span class="number">7 </span>, MAV_ODID_TIME_ACC_0_8_SECOND = <span class="number">8 </span>, MAV_ODID_TIME_ACC_0_9_SECOND = <span class="number">9 </span>, MAV_ODID_TIME_ACC_1_0_SECOND = <span class="number">10 </span>, MAV_ODID_TIME_ACC_1_1_SECOND = <span class="number">11 </span>, MAV_ODID_TIME_ACC_1_2_SECOND = <span class="number">12 </span>, MAV_ODID_TIME_ACC_1_3_SECOND = <span class="number">13 </span>, MAV_ODID_TIME_ACC_1_4_SECOND = <span class="number">14 </span>, MAV_ODID_TIME_ACC_1_5_SECOND = <span class="number">15 </span>, } <span class="kw">impl </span>MavOdidTimeAcc { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_TIME_ACC_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidTimeAcc { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavModeGimbal { MAV_MODE_GIMBAL_UNINITIALIZED = <span class="number">0 </span>, MAV_MODE_GIMBAL_CALIBRATING_PITCH = <span class="number">1 </span>, MAV_MODE_GIMBAL_CALIBRATING_ROLL = <span class="number">2 </span>, MAV_MODE_GIMBAL_CALIBRATING_YAW = <span class="number">3 </span>, MAV_MODE_GIMBAL_INITIALIZED = <span class="number">4 </span>, MAV_MODE_GIMBAL_ACTIVE = <span class="number">5 </span>, MAV_MODE_GIMBAL_RATE_CMD_TIMEOUT = <span class="number">6 </span>, } <span class="kw">impl </span>MavModeGimbal { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_MODE_GIMBAL_UNINITIALIZED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavModeGimbal { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproHeartbeatStatus { GOPRO_HEARTBEAT_STATUS_DISCONNECTED = <span class="number">0 </span>, GOPRO_HEARTBEAT_STATUS_INCOMPATIBLE = <span class="number">1 </span>, GOPRO_HEARTBEAT_STATUS_CONNECTED = <span class="number">2 </span>, GOPRO_HEARTBEAT_STATUS_ERROR = <span class="number">3 </span>, } <span class="kw">impl </span>GoproHeartbeatStatus { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_HEARTBEAT_STATUS_DISCONNECTED ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproHeartbeatStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>VideoStreamType { VIDEO_STREAM_TYPE_RTSP = <span class="number">0 </span>, VIDEO_STREAM_TYPE_RTPUDP = <span class="number">1 </span>, VIDEO_STREAM_TYPE_TCP_MPEG = <span class="number">2 </span>, VIDEO_STREAM_TYPE_MPEG_TS_H264 = <span class="number">3 </span>, } <span class="kw">impl </span>VideoStreamType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: VIDEO_STREAM_TYPE_RTSP ; } <span class="kw">impl </span>Default <span class="kw">for </span>VideoStreamType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>LandingTargetType { LANDING_TARGET_TYPE_LIGHT_BEACON = <span class="number">0 </span>, LANDING_TARGET_TYPE_RADIO_BEACON = <span class="number">1 </span>, LANDING_TARGET_TYPE_VISION_FIDUCIAL = <span class="number">2 </span>, LANDING_TARGET_TYPE_VISION_OTHER = <span class="number">3 </span>, } <span class="kw">impl </span>LandingTargetType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: LANDING_TARGET_TYPE_LIGHT_BEACON ; } <span class="kw">impl </span>Default <span class="kw">for </span>LandingTargetType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>WifiConfigApMode { WIFI_CONFIG_AP_MODE_UNDEFINED = <span class="number">0 </span>, WIFI_CONFIG_AP_MODE_AP = <span class="number">1 </span>, WIFI_CONFIG_AP_MODE_STATION = <span class="number">2 </span>, WIFI_CONFIG_AP_MODE_DISABLED = <span class="number">3 </span>, } <span class="kw">impl </span>WifiConfigApMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: WIFI_CONFIG_AP_MODE_UNDEFINED ; } <span class="kw">impl </span>Default <span class="kw">for </span>WifiConfigApMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GimbalDeviceFlags : u16 { <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_RETRACT = <span class="number">1 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_NEUTRAL = <span class="number">2 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_ROLL_LOCK = <span class="number">4 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_PITCH_LOCK = <span class="number">8 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_YAW_LOCK = <span class="number">16 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_YAW_IN_VEHICLE_FRAME = <span class="number">32 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_YAW_IN_EARTH_FRAME = <span class="number">64 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_ACCEPTS_YAW_IN_EARTH_FRAME = <span class="number">128 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_RC_EXCLUSIVE = <span class="number">256 </span>; <span class="kw">const </span>GIMBAL_DEVICE_FLAGS_RC_MIXED = <span class="number">512 </span>; } } <span class="kw">impl </span>GimbalDeviceFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GIMBAL_DEVICE_FLAGS_RETRACT ; } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalDeviceFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraZoomType { ZOOM_TYPE_STEP = <span class="number">0 </span>, ZOOM_TYPE_CONTINUOUS = <span class="number">1 </span>, ZOOM_TYPE_RANGE = <span class="number">2 </span>, ZOOM_TYPE_FOCAL_LENGTH = <span class="number">3 </span>, } <span class="kw">impl </span>CameraZoomType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ZOOM_TYPE_STEP ; } <span class="kw">impl </span>Default <span class="kw">for </span>CameraZoomType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavProtocolCapability : u64 { <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT = <span class="number">1 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_PARAM_FLOAT = <span class="number">2 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_MISSION_INT = <span class="number">4 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_COMMAND_INT = <span class="number">8 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_PARAM_ENCODE_BYTEWISE = <span class="number">16 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_FTP = <span class="number">32 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_SET_ATTITUDE_TARGET = <span class="number">64 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_LOCAL_NED = <span class="number">128 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_SET_POSITION_TARGET_GLOBAL_INT = <span class="number">256 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_TERRAIN = <span class="number">512 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_SET_ACTUATOR_TARGET = <span class="number">1024 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_FLIGHT_TERMINATION = <span class="number">2048 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_COMPASS_CALIBRATION = <span class="number">4096 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_MAVLINK2 = <span class="number">8192 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_MISSION_FENCE = <span class="number">16384 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_MISSION_RALLY = <span class="number">32768 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_RESERVED2 = <span class="number">65536 </span>; <span class="kw">const </span>MAV_PROTOCOL_CAPABILITY_PARAM_ENCODE_C_CAST = <span class="number">131072 </span>; } } <span class="kw">impl </span>MavProtocolCapability { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_PROTOCOL_CAPABILITY_MISSION_FLOAT ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavProtocolCapability { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GimbalDeviceErrorFlags : u32 { <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_AT_ROLL_LIMIT = <span class="number">1 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_AT_PITCH_LIMIT = <span class="number">2 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_AT_YAW_LIMIT = <span class="number">4 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_ENCODER_ERROR = <span class="number">8 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_POWER_ERROR = <span class="number">16 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_MOTOR_ERROR = <span class="number">32 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_SOFTWARE_ERROR = <span class="number">64 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_COMMS_ERROR = <span class="number">128 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_CALIBRATION_RUNNING = <span class="number">256 </span>; <span class="kw">const </span>GIMBAL_DEVICE_ERROR_FLAGS_NO_MANAGER = <span class="number">512 </span>; } } <span class="kw">impl </span>GimbalDeviceErrorFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GIMBAL_DEVICE_ERROR_FLAGS_AT_ROLL_LIMIT ; } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalDeviceErrorFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UavionixAdsbOutDynamicState : u16 { <span class="kw">const </span>UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE = <span class="number">1 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_DYNAMIC_STATE_AUTOPILOT_ENABLED = <span class="number">2 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_DYNAMIC_STATE_NICBARO_CROSSCHECKED = <span class="number">4 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_DYNAMIC_STATE_ON_GROUND = <span class="number">8 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_DYNAMIC_STATE_IDENT = <span class="number">16 </span>; } } <span class="kw">impl </span>UavionixAdsbOutDynamicState { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC_STATE_INTENT_CHANGE ; } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutDynamicState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproFrameRate { GOPRO_FRAME_RATE_12 = <span class="number">0 </span>, GOPRO_FRAME_RATE_15 = <span class="number">1 </span>, GOPRO_FRAME_RATE_24 = <span class="number">2 </span>, GOPRO_FRAME_RATE_25 = <span class="number">3 </span>, GOPRO_FRAME_RATE_30 = <span class="number">4 </span>, GOPRO_FRAME_RATE_48 = <span class="number">5 </span>, GOPRO_FRAME_RATE_50 = <span class="number">6 </span>, GOPRO_FRAME_RATE_60 = <span class="number">7 </span>, GOPRO_FRAME_RATE_80 = <span class="number">8 </span>, GOPRO_FRAME_RATE_90 = <span class="number">9 </span>, GOPRO_FRAME_RATE_100 = <span class="number">10 </span>, GOPRO_FRAME_RATE_120 = <span class="number">11 </span>, GOPRO_FRAME_RATE_240 = <span class="number">12 </span>, GOPRO_FRAME_RATE_12_5 = <span class="number">13 </span>, } <span class="kw">impl </span>GoproFrameRate { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_FRAME_RATE_12 ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproFrameRate { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidOperatorIdType { MAV_ODID_OPERATOR_ID_TYPE_CAA = <span class="number">0 </span>, } <span class="kw">impl </span>MavOdidOperatorIdType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_OPERATOR_ID_TYPE_CAA ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidOperatorIdType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GoproHeartbeatFlags : u8 { <span class="kw">const </span>GOPRO_FLAG_RECORDING = <span class="number">1 </span>; } } <span class="kw">impl </span>GoproHeartbeatFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_FLAG_RECORDING ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproHeartbeatFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>ActuatorOutputFunction { ACTUATOR_OUTPUT_FUNCTION_NONE = <span class="number">0 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR1 = <span class="number">1 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR2 = <span class="number">2 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR3 = <span class="number">3 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR4 = <span class="number">4 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR5 = <span class="number">5 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR6 = <span class="number">6 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR7 = <span class="number">7 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR8 = <span class="number">8 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR9 = <span class="number">9 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR10 = <span class="number">10 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR11 = <span class="number">11 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR12 = <span class="number">12 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR13 = <span class="number">13 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR14 = <span class="number">14 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR15 = <span class="number">15 </span>, ACTUATOR_OUTPUT_FUNCTION_MOTOR16 = <span class="number">16 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO1 = <span class="number">33 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO2 = <span class="number">34 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO3 = <span class="number">35 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO4 = <span class="number">36 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO5 = <span class="number">37 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO6 = <span class="number">38 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO7 = <span class="number">39 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO8 = <span class="number">40 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO9 = <span class="number">41 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO10 = <span class="number">42 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO11 = <span class="number">43 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO12 = <span class="number">44 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO13 = <span class="number">45 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO14 = <span class="number">46 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO15 = <span class="number">47 </span>, ACTUATOR_OUTPUT_FUNCTION_SERVO16 = <span class="number">48 </span>, } <span class="kw">impl </span>ActuatorOutputFunction { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ACTUATOR_OUTPUT_FUNCTION_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>ActuatorOutputFunction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EscFailureFlags : u16 { <span class="kw">const </span>ESC_FAILURE_NONE = <span class="number">0 </span>; <span class="kw">const </span>ESC_FAILURE_OVER_CURRENT = <span class="number">1 </span>; <span class="kw">const </span>ESC_FAILURE_OVER_VOLTAGE = <span class="number">2 </span>; <span class="kw">const </span>ESC_FAILURE_OVER_TEMPERATURE = <span class="number">4 </span>; <span class="kw">const </span>ESC_FAILURE_OVER_RPM = <span class="number">8 </span>; <span class="kw">const </span>ESC_FAILURE_INCONSISTENT_CMD = <span class="number">16 </span>; <span class="kw">const </span>ESC_FAILURE_MOTOR_STUCK = <span class="number">32 </span>; <span class="kw">const </span>ESC_FAILURE_GENERIC = <span class="number">64 </span>; } } <span class="kw">impl </span>EscFailureFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ESC_FAILURE_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>EscFailureFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavRemoteLogDataBlockStatuses { MAV_REMOTE_LOG_DATA_BLOCK_NACK = <span class="number">0 </span>, MAV_REMOTE_LOG_DATA_BLOCK_ACK = <span class="number">1 </span>, } <span class="kw">impl </span>MavRemoteLogDataBlockStatuses { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_REMOTE_LOG_DATA_BLOCK_NACK ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavRemoteLogDataBlockStatuses { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LimitModule : u8 { <span class="kw">const </span>LIMIT_GPSLOCK = <span class="number">1 </span>; <span class="kw">const </span>LIMIT_GEOFENCE = <span class="number">2 </span>; <span class="kw">const </span>LIMIT_ALTITUDE = <span class="number">4 </span>; } } <span class="kw">impl </span>LimitModule { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: LIMIT_GPSLOCK ; } <span class="kw">impl </span>Default <span class="kw">for </span>LimitModule { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproCommand { GOPRO_COMMAND_POWER = <span class="number">0 </span>, GOPRO_COMMAND_CAPTURE_MODE = <span class="number">1 </span>, GOPRO_COMMAND_SHUTTER = <span class="number">2 </span>, GOPRO_COMMAND_BATTERY = <span class="number">3 </span>, GOPRO_COMMAND_MODEL = <span class="number">4 </span>, GOPRO_COMMAND_VIDEO_SETTINGS = <span class="number">5 </span>, GOPRO_COMMAND_LOW_LIGHT = <span class="number">6 </span>, GOPRO_COMMAND_PHOTO_RESOLUTION = <span class="number">7 </span>, GOPRO_COMMAND_PHOTO_BURST_RATE = <span class="number">8 </span>, GOPRO_COMMAND_PROTUNE = <span class="number">9 </span>, GOPRO_COMMAND_PROTUNE_WHITE_BALANCE = <span class="number">10 </span>, GOPRO_COMMAND_PROTUNE_COLOUR = <span class="number">11 </span>, GOPRO_COMMAND_PROTUNE_GAIN = <span class="number">12 </span>, GOPRO_COMMAND_PROTUNE_SHARPNESS = <span class="number">13 </span>, GOPRO_COMMAND_PROTUNE_EXPOSURE = <span class="number">14 </span>, GOPRO_COMMAND_TIME = <span class="number">15 </span>, GOPRO_COMMAND_CHARGING = <span class="number">16 </span>, } <span class="kw">impl </span>GoproCommand { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_COMMAND_POWER ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproCommand { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavArmAuthDeniedReason { MAV_ARM_AUTH_DENIED_REASON_GENERIC = <span class="number">0 </span>, MAV_ARM_AUTH_DENIED_REASON_NONE = <span class="number">1 </span>, MAV_ARM_AUTH_DENIED_REASON_INVALID_WAYPOINT = <span class="number">2 </span>, MAV_ARM_AUTH_DENIED_REASON_TIMEOUT = <span class="number">3 </span>, MAV_ARM_AUTH_DENIED_REASON_AIRSPACE_IN_USE = <span class="number">4 </span>, MAV_ARM_AUTH_DENIED_REASON_BAD_WEATHER = <span class="number">5 </span>, } <span class="kw">impl </span>MavArmAuthDeniedReason { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ARM_AUTH_DENIED_REASON_GENERIC ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavArmAuthDeniedReason { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavEventErrorReason { MAV_EVENT_ERROR_REASON_UNAVAILABLE = <span class="number">0 </span>, } <span class="kw">impl </span>MavEventErrorReason { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_EVENT_ERROR_REASON_UNAVAILABLE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavEventErrorReason { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>AdsbEmitterType { ADSB_EMITTER_TYPE_NO_INFO = <span class="number">0 </span>, ADSB_EMITTER_TYPE_LIGHT = <span class="number">1 </span>, ADSB_EMITTER_TYPE_SMALL = <span class="number">2 </span>, ADSB_EMITTER_TYPE_LARGE = <span class="number">3 </span>, ADSB_EMITTER_TYPE_HIGH_VORTEX_LARGE = <span class="number">4 </span>, ADSB_EMITTER_TYPE_HEAVY = <span class="number">5 </span>, ADSB_EMITTER_TYPE_HIGHLY_MANUV = <span class="number">6 </span>, ADSB_EMITTER_TYPE_ROTOCRAFT = <span class="number">7 </span>, ADSB_EMITTER_TYPE_UNASSIGNED = <span class="number">8 </span>, ADSB_EMITTER_TYPE_GLIDER = <span class="number">9 </span>, ADSB_EMITTER_TYPE_LIGHTER_AIR = <span class="number">10 </span>, ADSB_EMITTER_TYPE_PARACHUTE = <span class="number">11 </span>, ADSB_EMITTER_TYPE_ULTRA_LIGHT = <span class="number">12 </span>, ADSB_EMITTER_TYPE_UNASSIGNED2 = <span class="number">13 </span>, ADSB_EMITTER_TYPE_UAV = <span class="number">14 </span>, ADSB_EMITTER_TYPE_SPACE = <span class="number">15 </span>, ADSB_EMITTER_TYPE_UNASSGINED3 = <span class="number">16 </span>, ADSB_EMITTER_TYPE_EMERGENCY_SURFACE = <span class="number">17 </span>, ADSB_EMITTER_TYPE_SERVICE_SURFACE = <span class="number">18 </span>, ADSB_EMITTER_TYPE_POINT_OBSTACLE = <span class="number">19 </span>, } <span class="kw">impl </span>AdsbEmitterType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ADSB_EMITTER_TYPE_NO_INFO ; } <span class="kw">impl </span>Default <span class="kw">for </span>AdsbEmitterType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CellularNetworkRadioType { CELLULAR_NETWORK_RADIO_TYPE_NONE = <span class="number">0 </span>, CELLULAR_NETWORK_RADIO_TYPE_GSM = <span class="number">1 </span>, CELLULAR_NETWORK_RADIO_TYPE_CDMA = <span class="number">2 </span>, CELLULAR_NETWORK_RADIO_TYPE_WCDMA = <span class="number">3 </span>, CELLULAR_NETWORK_RADIO_TYPE_LTE = <span class="number">4 </span>, } <span class="kw">impl </span>CellularNetworkRadioType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CELLULAR_NETWORK_RADIO_TYPE_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>CellularNetworkRadioType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>VideoStreamStatusFlags { VIDEO_STREAM_STATUS_FLAGS_RUNNING = <span class="number">1 </span>, VIDEO_STREAM_STATUS_FLAGS_THERMAL = <span class="number">2 </span>, } <span class="kw">impl </span>VideoStreamStatusFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: VIDEO_STREAM_STATUS_FLAGS_RUNNING ; } <span class="kw">impl </span>Default <span class="kw">for </span>VideoStreamStatusFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavMode { MAV_MODE_PREFLIGHT = <span class="number">0 </span>, MAV_MODE_STABILIZE_DISARMED = <span class="number">80 </span>, MAV_MODE_STABILIZE_ARMED = <span class="number">208 </span>, MAV_MODE_MANUAL_DISARMED = <span class="number">64 </span>, MAV_MODE_MANUAL_ARMED = <span class="number">192 </span>, MAV_MODE_GUIDED_DISARMED = <span class="number">88 </span>, MAV_MODE_GUIDED_ARMED = <span class="number">216 </span>, MAV_MODE_AUTO_DISARMED = <span class="number">92 </span>, MAV_MODE_AUTO_ARMED = <span class="number">220 </span>, MAV_MODE_TEST_DISARMED = <span class="number">66 </span>, MAV_MODE_TEST_ARMED = <span class="number">194 </span>, } <span class="kw">impl </span>MavMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_MODE_PREFLIGHT ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GpsFixType { GPS_FIX_TYPE_NO_GPS = <span class="number">0 </span>, GPS_FIX_TYPE_NO_FIX = <span class="number">1 </span>, GPS_FIX_TYPE_2D_FIX = <span class="number">2 </span>, GPS_FIX_TYPE_3D_FIX = <span class="number">3 </span>, GPS_FIX_TYPE_DGPS = <span class="number">4 </span>, GPS_FIX_TYPE_RTK_FLOAT = <span class="number">5 </span>, GPS_FIX_TYPE_RTK_FIXED = <span class="number">6 </span>, GPS_FIX_TYPE_STATIC = <span class="number">7 </span>, GPS_FIX_TYPE_PPP = <span class="number">8 </span>, } <span class="kw">impl </span>GpsFixType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GPS_FIX_TYPE_NO_GPS ; } <span class="kw">impl </span>Default <span class="kw">for </span>GpsFixType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidCategoryEu { MAV_ODID_CATEGORY_EU_UNDECLARED = <span class="number">0 </span>, MAV_ODID_CATEGORY_EU_OPEN = <span class="number">1 </span>, MAV_ODID_CATEGORY_EU_SPECIFIC = <span class="number">2 </span>, MAV_ODID_CATEGORY_EU_CERTIFIED = <span class="number">3 </span>, } <span class="kw">impl </span>MavOdidCategoryEu { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_CATEGORY_EU_UNDECLARED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidCategoryEu { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavTunnelPayloadType { MAV_TUNNEL_PAYLOAD_TYPE_UNKNOWN = <span class="number">0 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED0 = <span class="number">200 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED1 = <span class="number">201 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED2 = <span class="number">202 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED3 = <span class="number">203 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED4 = <span class="number">204 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED5 = <span class="number">205 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED6 = <span class="number">206 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED7 = <span class="number">207 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED8 = <span class="number">208 </span>, MAV_TUNNEL_PAYLOAD_TYPE_STORM32_RESERVED9 = <span class="number">209 </span>, } <span class="kw">impl </span>MavTunnelPayloadType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_TUNNEL_PAYLOAD_TYPE_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavTunnelPayloadType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>TrackerMode { TRACKER_MODE_MANUAL = <span class="number">0 </span>, TRACKER_MODE_STOP = <span class="number">1 </span>, TRACKER_MODE_SCAN = <span class="number">2 </span>, TRACKER_MODE_SERVO_TEST = <span class="number">3 </span>, TRACKER_MODE_AUTO = <span class="number">10 </span>, TRACKER_MODE_INITIALIZING = <span class="number">16 </span>, } <span class="kw">impl </span>TrackerMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: TRACKER_MODE_MANUAL ; } <span class="kw">impl </span>Default <span class="kw">for </span>TrackerMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>RoverMode { ROVER_MODE_MANUAL = <span class="number">0 </span>, ROVER_MODE_ACRO = <span class="number">1 </span>, ROVER_MODE_STEERING = <span class="number">3 </span>, ROVER_MODE_HOLD = <span class="number">4 </span>, ROVER_MODE_LOITER = <span class="number">5 </span>, ROVER_MODE_FOLLOW = <span class="number">6 </span>, ROVER_MODE_SIMPLE = <span class="number">7 </span>, ROVER_MODE_AUTO = <span class="number">10 </span>, ROVER_MODE_RTL = <span class="number">11 </span>, ROVER_MODE_SMART_RTL = <span class="number">12 </span>, ROVER_MODE_GUIDED = <span class="number">15 </span>, ROVER_MODE_INITIALIZING = <span class="number">16 </span>, } <span class="kw">impl </span>RoverMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ROVER_MODE_MANUAL ; } <span class="kw">impl </span>Default <span class="kw">for </span>RoverMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidHeightRef { MAV_ODID_HEIGHT_REF_OVER_TAKEOFF = <span class="number">0 </span>, MAV_ODID_HEIGHT_REF_OVER_GROUND = <span class="number">1 </span>, } <span class="kw">impl </span>MavOdidHeightRef { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_HEIGHT_REF_OVER_TAKEOFF ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidHeightRef { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>PrecisionLandMode { PRECISION_LAND_MODE_DISABLED = <span class="number">0 </span>, PRECISION_LAND_MODE_OPPORTUNISTIC = <span class="number">1 </span>, PRECISION_LAND_MODE_REQUIRED = <span class="number">2 </span>, } <span class="kw">impl </span>PrecisionLandMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: PRECISION_LAND_MODE_DISABLED ; } <span class="kw">impl </span>Default <span class="kw">for </span>PrecisionLandMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavSysStatusSensorExtended { MAV_SYS_STATUS_RECOVERY_SYSTEM = <span class="number">1 </span>, } <span class="kw">impl </span>MavSysStatusSensorExtended { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_SYS_STATUS_RECOVERY_SYSTEM ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavSysStatusSensorExtended { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavBatteryMode { MAV_BATTERY_MODE_UNKNOWN = <span class="number">0 </span>, MAV_BATTERY_MODE_AUTO_DISCHARGING = <span class="number">1 </span>, MAV_BATTERY_MODE_HOT_SWAP = <span class="number">2 </span>, } <span class="kw">impl </span>MavBatteryMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_BATTERY_MODE_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavBatteryMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CellularNetworkFailedReason { CELLULAR_NETWORK_FAILED_REASON_NONE = <span class="number">0 </span>, CELLULAR_NETWORK_FAILED_REASON_UNKNOWN = <span class="number">1 </span>, CELLULAR_NETWORK_FAILED_REASON_SIM_MISSING = <span class="number">2 </span>, CELLULAR_NETWORK_FAILED_REASON_SIM_ERROR = <span class="number">3 </span>, } <span class="kw">impl </span>CellularNetworkFailedReason { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CELLULAR_NETWORK_FAILED_REASON_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>CellularNetworkFailedReason { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>PlaneMode { PLANE_MODE_MANUAL = <span class="number">0 </span>, PLANE_MODE_CIRCLE = <span class="number">1 </span>, PLANE_MODE_STABILIZE = <span class="number">2 </span>, PLANE_MODE_TRAINING = <span class="number">3 </span>, PLANE_MODE_ACRO = <span class="number">4 </span>, PLANE_MODE_FLY_BY_WIRE_A = <span class="number">5 </span>, PLANE_MODE_FLY_BY_WIRE_B = <span class="number">6 </span>, PLANE_MODE_CRUISE = <span class="number">7 </span>, PLANE_MODE_AUTOTUNE = <span class="number">8 </span>, PLANE_MODE_AUTO = <span class="number">10 </span>, PLANE_MODE_RTL = <span class="number">11 </span>, PLANE_MODE_LOITER = <span class="number">12 </span>, PLANE_MODE_TAKEOFF = <span class="number">13 </span>, PLANE_MODE_AVOID_ADSB = <span class="number">14 </span>, PLANE_MODE_GUIDED = <span class="number">15 </span>, PLANE_MODE_INITIALIZING = <span class="number">16 </span>, PLANE_MODE_QSTABILIZE = <span class="number">17 </span>, PLANE_MODE_QHOVER = <span class="number">18 </span>, PLANE_MODE_QLOITER = <span class="number">19 </span>, PLANE_MODE_QLAND = <span class="number">20 </span>, PLANE_MODE_QRTL = <span class="number">21 </span>, PLANE_MODE_QAUTOTUNE = <span class="number">22 </span>, PLANE_MODE_QACRO = <span class="number">23 </span>, PLANE_MODE_THERMAL = <span class="number">24 </span>, } <span class="kw">impl </span>PlaneMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: PLANE_MODE_MANUAL ; } <span class="kw">impl </span>Default <span class="kw">for </span>PlaneMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavType { MAV_TYPE_GENERIC = <span class="number">0 </span>, MAV_TYPE_FIXED_WING = <span class="number">1 </span>, MAV_TYPE_QUADROTOR = <span class="number">2 </span>, MAV_TYPE_COAXIAL = <span class="number">3 </span>, MAV_TYPE_HELICOPTER = <span class="number">4 </span>, MAV_TYPE_ANTENNA_TRACKER = <span class="number">5 </span>, MAV_TYPE_GCS = <span class="number">6 </span>, MAV_TYPE_AIRSHIP = <span class="number">7 </span>, MAV_TYPE_FREE_BALLOON = <span class="number">8 </span>, MAV_TYPE_ROCKET = <span class="number">9 </span>, MAV_TYPE_GROUND_ROVER = <span class="number">10 </span>, MAV_TYPE_SURFACE_BOAT = <span class="number">11 </span>, MAV_TYPE_SUBMARINE = <span class="number">12 </span>, MAV_TYPE_HEXAROTOR = <span class="number">13 </span>, MAV_TYPE_OCTOROTOR = <span class="number">14 </span>, MAV_TYPE_TRICOPTER = <span class="number">15 </span>, MAV_TYPE_FLAPPING_WING = <span class="number">16 </span>, MAV_TYPE_KITE = <span class="number">17 </span>, MAV_TYPE_ONBOARD_CONTROLLER = <span class="number">18 </span>, MAV_TYPE_VTOL_TAILSITTER_DUOROTOR = <span class="number">19 </span>, MAV_TYPE_VTOL_TAILSITTER_QUADROTOR = <span class="number">20 </span>, MAV_TYPE_VTOL_TILTROTOR = <span class="number">21 </span>, MAV_TYPE_VTOL_FIXEDROTOR = <span class="number">22 </span>, MAV_TYPE_VTOL_TAILSITTER = <span class="number">23 </span>, MAV_TYPE_VTOL_TILTWING = <span class="number">24 </span>, MAV_TYPE_VTOL_RESERVED5 = <span class="number">25 </span>, MAV_TYPE_GIMBAL = <span class="number">26 </span>, MAV_TYPE_ADSB = <span class="number">27 </span>, MAV_TYPE_PARAFOIL = <span class="number">28 </span>, MAV_TYPE_DODECAROTOR = <span class="number">29 </span>, MAV_TYPE_CAMERA = <span class="number">30 </span>, MAV_TYPE_CHARGING_STATION = <span class="number">31 </span>, MAV_TYPE_FLARM = <span class="number">32 </span>, MAV_TYPE_SERVO = <span class="number">33 </span>, MAV_TYPE_ODID = <span class="number">34 </span>, MAV_TYPE_DECAROTOR = <span class="number">35 </span>, MAV_TYPE_BATTERY = <span class="number">36 </span>, MAV_TYPE_PARACHUTE = <span class="number">37 </span>, MAV_TYPE_LOG = <span class="number">38 </span>, MAV_TYPE_OSD = <span class="number">39 </span>, MAV_TYPE_IMU = <span class="number">40 </span>, MAV_TYPE_GPS = <span class="number">41 </span>, MAV_TYPE_WINCH = <span class="number">42 </span>, } <span class="kw">impl </span>MavType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_TYPE_GENERIC ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MagCalStatus { MAG_CAL_NOT_STARTED = <span class="number">0 </span>, MAG_CAL_WAITING_TO_START = <span class="number">1 </span>, MAG_CAL_RUNNING_STEP_ONE = <span class="number">2 </span>, MAG_CAL_RUNNING_STEP_TWO = <span class="number">3 </span>, MAG_CAL_SUCCESS = <span class="number">4 </span>, MAG_CAL_FAILED = <span class="number">5 </span>, MAG_CAL_BAD_ORIENTATION = <span class="number">6 </span>, MAG_CAL_BAD_RADIUS = <span class="number">7 </span>, } <span class="kw">impl </span>MagCalStatus { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAG_CAL_NOT_STARTED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MagCalStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavionixAdsbOutCfgGpsOffsetLon { UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_NO_DATA = <span class="number">0 </span>, UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_APPLIED_BY_SENSOR = <span class="number">1 </span>, } <span class="kw">impl </span>UavionixAdsbOutCfgGpsOffsetLon { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG_GPS_OFFSET_LON_NO_DATA ; } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutCfgGpsOffsetLon { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CopterMode { COPTER_MODE_STABILIZE = <span class="number">0 </span>, COPTER_MODE_ACRO = <span class="number">1 </span>, COPTER_MODE_ALT_HOLD = <span class="number">2 </span>, COPTER_MODE_AUTO = <span class="number">3 </span>, COPTER_MODE_GUIDED = <span class="number">4 </span>, COPTER_MODE_LOITER = <span class="number">5 </span>, COPTER_MODE_RTL = <span class="number">6 </span>, COPTER_MODE_CIRCLE = <span class="number">7 </span>, COPTER_MODE_LAND = <span class="number">9 </span>, COPTER_MODE_DRIFT = <span class="number">11 </span>, COPTER_MODE_SPORT = <span class="number">13 </span>, COPTER_MODE_FLIP = <span class="number">14 </span>, COPTER_MODE_AUTOTUNE = <span class="number">15 </span>, COPTER_MODE_POSHOLD = <span class="number">16 </span>, COPTER_MODE_BRAKE = <span class="number">17 </span>, COPTER_MODE_THROW = <span class="number">18 </span>, COPTER_MODE_AVOID_ADSB = <span class="number">19 </span>, COPTER_MODE_GUIDED_NOGPS = <span class="number">20 </span>, COPTER_MODE_SMART_RTL = <span class="number">21 </span>, COPTER_MODE_FLOWHOLD = <span class="number">22 </span>, COPTER_MODE_FOLLOW = <span class="number">23 </span>, COPTER_MODE_ZIGZAG = <span class="number">24 </span>, COPTER_MODE_SYSTEMID = <span class="number">25 </span>, COPTER_MODE_AUTOROTATE = <span class="number">26 </span>, COPTER_MODE_AUTO_RTL = <span class="number">27 </span>, } <span class="kw">impl </span>CopterMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: COPTER_MODE_STABILIZE ; } <span class="kw">impl </span>Default <span class="kw">for </span>CopterMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidClassificationType { MAV_ODID_CLASSIFICATION_TYPE_UNDECLARED = <span class="number">0 </span>, MAV_ODID_CLASSIFICATION_TYPE_EU = <span class="number">1 </span>, } <span class="kw">impl </span>MavOdidClassificationType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_CLASSIFICATION_TYPE_UNDECLARED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidClassificationType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>StorageUsageFlag { STORAGE_USAGE_FLAG_SET = <span class="number">1 </span>, STORAGE_USAGE_FLAG_PHOTO = <span class="number">2 </span>, STORAGE_USAGE_FLAG_VIDEO = <span class="number">4 </span>, STORAGE_USAGE_FLAG_LOGS = <span class="number">8 </span>, } <span class="kw">impl </span>StorageUsageFlag { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: STORAGE_USAGE_FLAG_SET ; } <span class="kw">impl </span>Default <span class="kw">for </span>StorageUsageFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproFieldOfView { GOPRO_FIELD_OF_VIEW_WIDE = <span class="number">0 </span>, GOPRO_FIELD_OF_VIEW_MEDIUM = <span class="number">1 </span>, GOPRO_FIELD_OF_VIEW_NARROW = <span class="number">2 </span>, } <span class="kw">impl </span>GoproFieldOfView { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_FIELD_OF_VIEW_WIDE ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproFieldOfView { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproProtuneExposure { GOPRO_PROTUNE_EXPOSURE_NEG_5_0 = <span class="number">0 </span>, GOPRO_PROTUNE_EXPOSURE_NEG_4_5 = <span class="number">1 </span>, GOPRO_PROTUNE_EXPOSURE_NEG_4_0 = <span class="number">2 </span>, GOPRO_PROTUNE_EXPOSURE_NEG_3_5 = <span class="number">3 </span>, GOPRO_PROTUNE_EXPOSURE_NEG_3_0 = <span class="number">4 </span>, GOPRO_PROTUNE_EXPOSURE_NEG_2_5 = <span class="number">5 </span>, GOPRO_PROTUNE_EXPOSURE_NEG_2_0 = <span class="number">6 </span>, GOPRO_PROTUNE_EXPOSURE_NEG_1_5 = <span class="number">7 </span>, GOPRO_PROTUNE_EXPOSURE_NEG_1_0 = <span class="number">8 </span>, GOPRO_PROTUNE_EXPOSURE_NEG_0_5 = <span class="number">9 </span>, GOPRO_PROTUNE_EXPOSURE_ZERO = <span class="number">10 </span>, GOPRO_PROTUNE_EXPOSURE_POS_0_5 = <span class="number">11 </span>, GOPRO_PROTUNE_EXPOSURE_POS_1_0 = <span class="number">12 </span>, GOPRO_PROTUNE_EXPOSURE_POS_1_5 = <span class="number">13 </span>, GOPRO_PROTUNE_EXPOSURE_POS_2_0 = <span class="number">14 </span>, GOPRO_PROTUNE_EXPOSURE_POS_2_5 = <span class="number">15 </span>, GOPRO_PROTUNE_EXPOSURE_POS_3_0 = <span class="number">16 </span>, GOPRO_PROTUNE_EXPOSURE_POS_3_5 = <span class="number">17 </span>, GOPRO_PROTUNE_EXPOSURE_POS_4_0 = <span class="number">18 </span>, GOPRO_PROTUNE_EXPOSURE_POS_4_5 = <span class="number">19 </span>, GOPRO_PROTUNE_EXPOSURE_POS_5_0 = <span class="number">20 </span>, } <span class="kw">impl </span>GoproProtuneExposure { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_PROTUNE_EXPOSURE_NEG_5_0 ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproProtuneExposure { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>WifiConfigApResponse { WIFI_CONFIG_AP_RESPONSE_UNDEFINED = <span class="number">0 </span>, WIFI_CONFIG_AP_RESPONSE_ACCEPTED = <span class="number">1 </span>, WIFI_CONFIG_AP_RESPONSE_REJECTED = <span class="number">2 </span>, WIFI_CONFIG_AP_RESPONSE_MODE_ERROR = <span class="number">3 </span>, WIFI_CONFIG_AP_RESPONSE_SSID_ERROR = <span class="number">4 </span>, WIFI_CONFIG_AP_RESPONSE_PASSWORD_ERROR = <span class="number">5 </span>, } <span class="kw">impl </span>WifiConfigApResponse { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: WIFI_CONFIG_AP_RESPONSE_UNDEFINED ; } <span class="kw">impl </span>Default <span class="kw">for </span>WifiConfigApResponse { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavLandedState { MAV_LANDED_STATE_UNDEFINED = <span class="number">0 </span>, MAV_LANDED_STATE_ON_GROUND = <span class="number">1 </span>, MAV_LANDED_STATE_IN_AIR = <span class="number">2 </span>, MAV_LANDED_STATE_TAKEOFF = <span class="number">3 </span>, MAV_LANDED_STATE_LANDING = <span class="number">4 </span>, } <span class="kw">impl </span>MavLandedState { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_LANDED_STATE_UNDEFINED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavLandedState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidHorAcc { MAV_ODID_HOR_ACC_UNKNOWN = <span class="number">0 </span>, MAV_ODID_HOR_ACC_10NM = <span class="number">1 </span>, MAV_ODID_HOR_ACC_4NM = <span class="number">2 </span>, MAV_ODID_HOR_ACC_2NM = <span class="number">3 </span>, MAV_ODID_HOR_ACC_1NM = <span class="number">4 </span>, MAV_ODID_HOR_ACC_0_5NM = <span class="number">5 </span>, MAV_ODID_HOR_ACC_0_3NM = <span class="number">6 </span>, MAV_ODID_HOR_ACC_0_1NM = <span class="number">7 </span>, MAV_ODID_HOR_ACC_0_05NM = <span class="number">8 </span>, MAV_ODID_HOR_ACC_30_METER = <span class="number">9 </span>, MAV_ODID_HOR_ACC_10_METER = <span class="number">10 </span>, MAV_ODID_HOR_ACC_3_METER = <span class="number">11 </span>, MAV_ODID_HOR_ACC_1_METER = <span class="number">12 </span>, } <span class="kw">impl </span>MavOdidHorAcc { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_HOR_ACC_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidHorAcc { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavBatteryFault { MAV_BATTERY_FAULT_DEEP_DISCHARGE = <span class="number">1 </span>, MAV_BATTERY_FAULT_SPIKES = <span class="number">2 </span>, MAV_BATTERY_FAULT_CELL_FAIL = <span class="number">4 </span>, MAV_BATTERY_FAULT_OVER_CURRENT = <span class="number">8 </span>, MAV_BATTERY_FAULT_OVER_TEMPERATURE = <span class="number">16 </span>, MAV_BATTERY_FAULT_UNDER_TEMPERATURE = <span class="number">32 </span>, MAV_BATTERY_FAULT_INCOMPATIBLE_VOLTAGE = <span class="number">64 </span>, MAV_BATTERY_FAULT_INCOMPATIBLE_FIRMWARE = <span class="number">128 </span>, BATTERY_FAULT_INCOMPATIBLE_CELLS_CONFIGURATION = <span class="number">256 </span>, } <span class="kw">impl </span>MavBatteryFault { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_BATTERY_FAULT_DEEP_DISCHARGE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavBatteryFault { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>AutotuneAxis { AUTOTUNE_AXIS_DEFAULT = <span class="number">0 </span>, AUTOTUNE_AXIS_ROLL = <span class="number">1 </span>, AUTOTUNE_AXIS_PITCH = <span class="number">2 </span>, AUTOTUNE_AXIS_YAW = <span class="number">4 </span>, } <span class="kw">impl </span>AutotuneAxis { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: AUTOTUNE_AXIS_DEFAULT ; } <span class="kw">impl </span>Default <span class="kw">for </span>AutotuneAxis { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GripperActions { GRIPPER_ACTION_RELEASE = <span class="number">0 </span>, GRIPPER_ACTION_GRAB = <span class="number">1 </span>, } <span class="kw">impl </span>GripperActions { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GRIPPER_ACTION_RELEASE ; } <span class="kw">impl </span>Default <span class="kw">for </span>GripperActions { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavModeFlag : u8 { <span class="kw">const </span>MAV_MODE_FLAG_SAFETY_ARMED = <span class="number">128 </span>; <span class="kw">const </span>MAV_MODE_FLAG_MANUAL_INPUT_ENABLED = <span class="number">64 </span>; <span class="kw">const </span>MAV_MODE_FLAG_HIL_ENABLED = <span class="number">32 </span>; <span class="kw">const </span>MAV_MODE_FLAG_STABILIZE_ENABLED = <span class="number">16 </span>; <span class="kw">const </span>MAV_MODE_FLAG_GUIDED_ENABLED = <span class="number">8 </span>; <span class="kw">const </span>MAV_MODE_FLAG_AUTO_ENABLED = <span class="number">4 </span>; <span class="kw">const </span>MAV_MODE_FLAG_TEST_ENABLED = <span class="number">2 </span>; <span class="kw">const </span>MAV_MODE_FLAG_CUSTOM_MODE_ENABLED = <span class="number">1 </span>; } } <span class="kw">impl </span>MavModeFlag { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_MODE_FLAG_SAFETY_ARMED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavModeFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproRequestStatus { GOPRO_REQUEST_SUCCESS = <span class="number">0 </span>, GOPRO_REQUEST_FAILED = <span class="number">1 </span>, } <span class="kw">impl </span>GoproRequestStatus { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_REQUEST_SUCCESS ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproRequestStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproBurstRate { GOPRO_BURST_RATE_3_IN_1_SECOND = <span class="number">0 </span>, GOPRO_BURST_RATE_5_IN_1_SECOND = <span class="number">1 </span>, GOPRO_BURST_RATE_10_IN_1_SECOND = <span class="number">2 </span>, GOPRO_BURST_RATE_10_IN_2_SECOND = <span class="number">3 </span>, GOPRO_BURST_RATE_10_IN_3_SECOND = <span class="number">4 </span>, GOPRO_BURST_RATE_30_IN_1_SECOND = <span class="number">5 </span>, GOPRO_BURST_RATE_30_IN_2_SECOND = <span class="number">6 </span>, GOPRO_BURST_RATE_30_IN_3_SECOND = <span class="number">7 </span>, GOPRO_BURST_RATE_30_IN_6_SECOND = <span class="number">8 </span>, } <span class="kw">impl </span>GoproBurstRate { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_BURST_RATE_3_IN_1_SECOND ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproBurstRate { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>DeepstallStage { DEEPSTALL_STAGE_FLY_TO_LANDING = <span class="number">0 </span>, DEEPSTALL_STAGE_ESTIMATE_WIND = <span class="number">1 </span>, DEEPSTALL_STAGE_WAIT_FOR_BREAKOUT = <span class="number">2 </span>, DEEPSTALL_STAGE_FLY_TO_ARC = <span class="number">3 </span>, DEEPSTALL_STAGE_ARC = <span class="number">4 </span>, DEEPSTALL_STAGE_APPROACH = <span class="number">5 </span>, DEEPSTALL_STAGE_LAND = <span class="number">6 </span>, } <span class="kw">impl </span>DeepstallStage { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: DEEPSTALL_STAGE_FLY_TO_LANDING ; } <span class="kw">impl </span>Default <span class="kw">for </span>DeepstallStage { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavFrame { MAV_FRAME_GLOBAL = <span class="number">0 </span>, MAV_FRAME_LOCAL_NED = <span class="number">1 </span>, MAV_FRAME_MISSION = <span class="number">2 </span>, MAV_FRAME_GLOBAL_RELATIVE_ALT = <span class="number">3 </span>, MAV_FRAME_LOCAL_ENU = <span class="number">4 </span>, MAV_FRAME_GLOBAL_INT = <span class="number">5 </span>, MAV_FRAME_GLOBAL_RELATIVE_ALT_INT = <span class="number">6 </span>, MAV_FRAME_LOCAL_OFFSET_NED = <span class="number">7 </span>, MAV_FRAME_BODY_NED = <span class="number">8 </span>, MAV_FRAME_BODY_OFFSET_NED = <span class="number">9 </span>, MAV_FRAME_GLOBAL_TERRAIN_ALT = <span class="number">10 </span>, MAV_FRAME_GLOBAL_TERRAIN_ALT_INT = <span class="number">11 </span>, MAV_FRAME_BODY_FRD = <span class="number">12 </span>, MAV_FRAME_RESERVED_13 = <span class="number">13 </span>, MAV_FRAME_RESERVED_14 = <span class="number">14 </span>, MAV_FRAME_RESERVED_15 = <span class="number">15 </span>, MAV_FRAME_RESERVED_16 = <span class="number">16 </span>, MAV_FRAME_RESERVED_17 = <span class="number">17 </span>, MAV_FRAME_RESERVED_18 = <span class="number">18 </span>, MAV_FRAME_RESERVED_19 = <span class="number">19 </span>, MAV_FRAME_LOCAL_FRD = <span class="number">20 </span>, MAV_FRAME_LOCAL_FLU = <span class="number">21 </span>, } <span class="kw">impl </span>MavFrame { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_FRAME_GLOBAL ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavFrame { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AdsbFlags : u16 { <span class="kw">const </span>ADSB_FLAGS_VALID_COORDS = <span class="number">1 </span>; <span class="kw">const </span>ADSB_FLAGS_VALID_ALTITUDE = <span class="number">2 </span>; <span class="kw">const </span>ADSB_FLAGS_VALID_HEADING = <span class="number">4 </span>; <span class="kw">const </span>ADSB_FLAGS_VALID_VELOCITY = <span class="number">8 </span>; <span class="kw">const </span>ADSB_FLAGS_VALID_CALLSIGN = <span class="number">16 </span>; <span class="kw">const </span>ADSB_FLAGS_VALID_SQUAWK = <span class="number">32 </span>; <span class="kw">const </span>ADSB_FLAGS_SIMULATED = <span class="number">64 </span>; <span class="kw">const </span>ADSB_FLAGS_VERTICAL_VELOCITY_VALID = <span class="number">128 </span>; <span class="kw">const </span>ADSB_FLAGS_BARO_VALID = <span class="number">256 </span>; <span class="kw">const </span>ADSB_FLAGS_SOURCE_UAT = <span class="number">32768 </span>; } } <span class="kw">impl </span>AdsbFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ADSB_FLAGS_VALID_COORDS ; } <span class="kw">impl </span>Default <span class="kw">for </span>AdsbFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavDataStream { MAV_DATA_STREAM_ALL = <span class="number">0 </span>, MAV_DATA_STREAM_RAW_SENSORS = <span class="number">1 </span>, MAV_DATA_STREAM_EXTENDED_STATUS = <span class="number">2 </span>, MAV_DATA_STREAM_RC_CHANNELS = <span class="number">3 </span>, MAV_DATA_STREAM_RAW_CONTROLLER = <span class="number">4 </span>, MAV_DATA_STREAM_POSITION = <span class="number">6 </span>, MAV_DATA_STREAM_EXTRA1 = <span class="number">10 </span>, MAV_DATA_STREAM_EXTRA2 = <span class="number">11 </span>, MAV_DATA_STREAM_EXTRA3 = <span class="number">12 </span>, } <span class="kw">impl </span>MavDataStream { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_DATA_STREAM_ALL ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavDataStream { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavModeFlagDecodePosition { MAV_MODE_FLAG_DECODE_POSITION_SAFETY = <span class="number">128 </span>, MAV_MODE_FLAG_DECODE_POSITION_MANUAL = <span class="number">64 </span>, MAV_MODE_FLAG_DECODE_POSITION_HIL = <span class="number">32 </span>, MAV_MODE_FLAG_DECODE_POSITION_STABILIZE = <span class="number">16 </span>, MAV_MODE_FLAG_DECODE_POSITION_GUIDED = <span class="number">8 </span>, MAV_MODE_FLAG_DECODE_POSITION_AUTO = <span class="number">4 </span>, MAV_MODE_FLAG_DECODE_POSITION_TEST = <span class="number">2 </span>, MAV_MODE_FLAG_DECODE_POSITION_CUSTOM_MODE = <span class="number">1 </span>, } <span class="kw">impl </span>MavModeFlagDecodePosition { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_MODE_FLAG_DECODE_POSITION_SAFETY ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavModeFlagDecodePosition { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>EscConnectionType { ESC_CONNECTION_TYPE_PPM = <span class="number">0 </span>, ESC_CONNECTION_TYPE_SERIAL = <span class="number">1 </span>, ESC_CONNECTION_TYPE_ONESHOT = <span class="number">2 </span>, ESC_CONNECTION_TYPE_I2C = <span class="number">3 </span>, ESC_CONNECTION_TYPE_CAN = <span class="number">4 </span>, ESC_CONNECTION_TYPE_DSHOT = <span class="number">5 </span>, } <span class="kw">impl </span>EscConnectionType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ESC_CONNECTION_TYPE_PPM ; } <span class="kw">impl </span>Default <span class="kw">for </span>EscConnectionType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraMode { CAMERA_MODE_IMAGE = <span class="number">0 </span>, CAMERA_MODE_VIDEO = <span class="number">1 </span>, CAMERA_MODE_IMAGE_SURVEY = <span class="number">2 </span>, } <span class="kw">impl </span>CameraMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CAMERA_MODE_IMAGE ; } <span class="kw">impl </span>Default <span class="kw">for </span>CameraMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>RcType { RC_TYPE_SPEKTRUM_DSM2 = <span class="number">0 </span>, RC_TYPE_SPEKTRUM_DSMX = <span class="number">1 </span>, } <span class="kw">impl </span>RcType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: RC_TYPE_SPEKTRUM_DSM2 ; } <span class="kw">impl </span>Default <span class="kw">for </span>RcType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>AdsbAltitudeType { ADSB_ALTITUDE_TYPE_PRESSURE_QNH = <span class="number">0 </span>, ADSB_ALTITUDE_TYPE_GEOMETRIC = <span class="number">1 </span>, } <span class="kw">impl </span>AdsbAltitudeType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ADSB_ALTITUDE_TYPE_PRESSURE_QNH ; } <span class="kw">impl </span>Default <span class="kw">for </span>AdsbAltitudeType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavWinchStatusFlag : u32 { <span class="kw">const </span>MAV_WINCH_STATUS_HEALTHY = <span class="number">1 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_FULLY_RETRACTED = <span class="number">2 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_MOVING = <span class="number">4 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_CLUTCH_ENGAGED = <span class="number">8 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_LOCKED = <span class="number">16 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_DROPPING = <span class="number">32 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_ARRESTING = <span class="number">64 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_GROUND_SENSE = <span class="number">128 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_RETRACTING = <span class="number">256 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_REDELIVER = <span class="number">512 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_ABANDON_LINE = <span class="number">1024 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_LOCKING = <span class="number">2048 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_LOAD_LINE = <span class="number">4096 </span>; <span class="kw">const </span>MAV_WINCH_STATUS_LOAD_PAYLOAD = <span class="number">8192 </span>; } } <span class="kw">impl </span>MavWinchStatusFlag { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_WINCH_STATUS_HEALTHY ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavWinchStatusFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavEstimatorType { MAV_ESTIMATOR_TYPE_UNKNOWN = <span class="number">0 </span>, MAV_ESTIMATOR_TYPE_NAIVE = <span class="number">1 </span>, MAV_ESTIMATOR_TYPE_VISION = <span class="number">2 </span>, MAV_ESTIMATOR_TYPE_VIO = <span class="number">3 </span>, MAV_ESTIMATOR_TYPE_GPS = <span class="number">4 </span>, MAV_ESTIMATOR_TYPE_GPS_INS = <span class="number">5 </span>, MAV_ESTIMATOR_TYPE_MOCAP = <span class="number">6 </span>, MAV_ESTIMATOR_TYPE_LIDAR = <span class="number">7 </span>, MAV_ESTIMATOR_TYPE_AUTOPILOT = <span class="number">8 </span>, } <span class="kw">impl </span>MavEstimatorType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ESTIMATOR_TYPE_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavEstimatorType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavMissionResult { MAV_MISSION_ACCEPTED = <span class="number">0 </span>, MAV_MISSION_ERROR = <span class="number">1 </span>, MAV_MISSION_UNSUPPORTED_FRAME = <span class="number">2 </span>, MAV_MISSION_UNSUPPORTED = <span class="number">3 </span>, MAV_MISSION_NO_SPACE = <span class="number">4 </span>, MAV_MISSION_INVALID = <span class="number">5 </span>, MAV_MISSION_INVALID_PARAM1 = <span class="number">6 </span>, MAV_MISSION_INVALID_PARAM2 = <span class="number">7 </span>, MAV_MISSION_INVALID_PARAM3 = <span class="number">8 </span>, MAV_MISSION_INVALID_PARAM4 = <span class="number">9 </span>, MAV_MISSION_INVALID_PARAM5_X = <span class="number">10 </span>, MAV_MISSION_INVALID_PARAM6_Y = <span class="number">11 </span>, MAV_MISSION_INVALID_PARAM7 = <span class="number">12 </span>, MAV_MISSION_INVALID_SEQUENCE = <span class="number">13 </span>, MAV_MISSION_DENIED = <span class="number">14 </span>, MAV_MISSION_OPERATION_CANCELLED = <span class="number">15 </span>, } <span class="kw">impl </span>MavMissionResult { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_MISSION_ACCEPTED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavMissionResult { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>PreflightStorageParameterAction { PARAM_READ_PERSISTENT = <span class="number">0 </span>, PARAM_WRITE_PERSISTENT = <span class="number">1 </span>, PARAM_RESET_CONFIG_DEFAULT = <span class="number">2 </span>, PARAM_RESET_SENSOR_DEFAULT = <span class="number">3 </span>, PARAM_RESET_ALL_DEFAULT = <span class="number">4 </span>, } <span class="kw">impl </span>PreflightStorageParameterAction { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: PARAM_READ_PERSISTENT ; } <span class="kw">impl </span>Default <span class="kw">for </span>PreflightStorageParameterAction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HlFailureFlag : u16 { <span class="kw">const </span>HL_FAILURE_FLAG_GPS = <span class="number">1 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_DIFFERENTIAL_PRESSURE = <span class="number">2 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_ABSOLUTE_PRESSURE = <span class="number">4 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_3D_ACCEL = <span class="number">8 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_3D_GYRO = <span class="number">16 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_3D_MAG = <span class="number">32 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_TERRAIN = <span class="number">64 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_BATTERY = <span class="number">128 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_RC_RECEIVER = <span class="number">256 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_OFFBOARD_LINK = <span class="number">512 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_ENGINE = <span class="number">1024 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_GEOFENCE = <span class="number">2048 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_ESTIMATOR = <span class="number">4096 </span>; <span class="kw">const </span>HL_FAILURE_FLAG_MISSION = <span class="number">8192 </span>; } } <span class="kw">impl </span>HlFailureFlag { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: HL_FAILURE_FLAG_GPS ; } <span class="kw">impl </span>Default <span class="kw">for </span>HlFailureFlag { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavSeverity { MAV_SEVERITY_EMERGENCY = <span class="number">0 </span>, MAV_SEVERITY_ALERT = <span class="number">1 </span>, MAV_SEVERITY_CRITICAL = <span class="number">2 </span>, MAV_SEVERITY_ERROR = <span class="number">3 </span>, MAV_SEVERITY_WARNING = <span class="number">4 </span>, MAV_SEVERITY_NOTICE = <span class="number">5 </span>, MAV_SEVERITY_INFO = <span class="number">6 </span>, MAV_SEVERITY_DEBUG = <span class="number">7 </span>, } <span class="kw">impl </span>MavSeverity { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_SEVERITY_EMERGENCY ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavSeverity { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TuneFormat : u32 { <span class="kw">const </span>TUNE_FORMAT_QBASIC1_1 = <span class="number">1 </span>; <span class="kw">const </span>TUNE_FORMAT_MML_MODERN = <span class="number">2 </span>; } } <span class="kw">impl </span>TuneFormat { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: TUNE_FORMAT_QBASIC1_1 ; } <span class="kw">impl </span>Default <span class="kw">for </span>TuneFormat { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>RtkBaselineCoordinateSystem { RTK_BASELINE_COORDINATE_SYSTEM_ECEF = <span class="number">0 </span>, RTK_BASELINE_COORDINATE_SYSTEM_NED = <span class="number">1 </span>, } <span class="kw">impl </span>RtkBaselineCoordinateSystem { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: RTK_BASELINE_COORDINATE_SYSTEM_ECEF ; } <span class="kw">impl </span>Default <span class="kw">for </span>RtkBaselineCoordinateSystem { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavDistanceSensor { MAV_DISTANCE_SENSOR_LASER = <span class="number">0 </span>, MAV_DISTANCE_SENSOR_ULTRASOUND = <span class="number">1 </span>, MAV_DISTANCE_SENSOR_INFRARED = <span class="number">2 </span>, MAV_DISTANCE_SENSOR_RADAR = <span class="number">3 </span>, MAV_DISTANCE_SENSOR_UNKNOWN = <span class="number">4 </span>, } <span class="kw">impl </span>MavDistanceSensor { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_DISTANCE_SENSOR_LASER ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavDistanceSensor { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UavionixAdsbOutRfSelect : u8 { <span class="kw">const </span>UAVIONIX_ADSB_OUT_RF_SELECT_STANDBY = <span class="number">0 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_RF_SELECT_RX_ENABLED = <span class="number">1 </span>; <span class="kw">const </span>UAVIONIX_ADSB_OUT_RF_SELECT_TX_ENABLED = <span class="number">2 </span>; } } <span class="kw">impl </span>UavionixAdsbOutRfSelect { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_RF_SELECT_STANDBY ; } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbOutRfSelect { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FailureUnit { FAILURE_UNIT_SENSOR_GYRO = <span class="number">0 </span>, FAILURE_UNIT_SENSOR_ACCEL = <span class="number">1 </span>, FAILURE_UNIT_SENSOR_MAG = <span class="number">2 </span>, FAILURE_UNIT_SENSOR_BARO = <span class="number">3 </span>, FAILURE_UNIT_SENSOR_GPS = <span class="number">4 </span>, FAILURE_UNIT_SENSOR_OPTICAL_FLOW = <span class="number">5 </span>, FAILURE_UNIT_SENSOR_VIO = <span class="number">6 </span>, FAILURE_UNIT_SENSOR_DISTANCE_SENSOR = <span class="number">7 </span>, FAILURE_UNIT_SENSOR_AIRSPEED = <span class="number">8 </span>, FAILURE_UNIT_SYSTEM_BATTERY = <span class="number">100 </span>, FAILURE_UNIT_SYSTEM_MOTOR = <span class="number">101 </span>, FAILURE_UNIT_SYSTEM_SERVO = <span class="number">102 </span>, FAILURE_UNIT_SYSTEM_AVOIDANCE = <span class="number">103 </span>, FAILURE_UNIT_SYSTEM_RC_SIGNAL = <span class="number">104 </span>, FAILURE_UNIT_SYSTEM_MAVLINK_SIGNAL = <span class="number">105 </span>, } <span class="kw">impl </span>FailureUnit { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: FAILURE_UNIT_SENSOR_GYRO ; } <span class="kw">impl </span>Default <span class="kw">for </span>FailureUnit { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RallyFlags : u8 { <span class="kw">const </span>FAVORABLE_WIND = <span class="number">1 </span>; <span class="kw">const </span>LAND_IMMEDIATELY = <span class="number">2 </span>; } } <span class="kw">impl </span>RallyFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: FAVORABLE_WIND ; } <span class="kw">impl </span>Default <span class="kw">for </span>RallyFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GimbalAxisCalibrationStatus { GIMBAL_AXIS_CALIBRATION_STATUS_IN_PROGRESS = <span class="number">0 </span>, GIMBAL_AXIS_CALIBRATION_STATUS_SUCCEEDED = <span class="number">1 </span>, GIMBAL_AXIS_CALIBRATION_STATUS_FAILED = <span class="number">2 </span>, } <span class="kw">impl </span>GimbalAxisCalibrationStatus { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GIMBAL_AXIS_CALIBRATION_STATUS_IN_PROGRESS ; } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalAxisCalibrationStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavRoi { MAV_ROI_NONE = <span class="number">0 </span>, MAV_ROI_WPNEXT = <span class="number">1 </span>, MAV_ROI_WPINDEX = <span class="number">2 </span>, MAV_ROI_LOCATION = <span class="number">3 </span>, MAV_ROI_TARGET = <span class="number">4 </span>, } <span class="kw">impl </span>MavRoi { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ROI_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavRoi { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UavionixAdsbRfHealth : u8 { <span class="kw">const </span>UAVIONIX_ADSB_RF_HEALTH_INITIALIZING = <span class="number">0 </span>; <span class="kw">const </span>UAVIONIX_ADSB_RF_HEALTH_OK = <span class="number">1 </span>; <span class="kw">const </span>UAVIONIX_ADSB_RF_HEALTH_FAIL_TX = <span class="number">2 </span>; <span class="kw">const </span>UAVIONIX_ADSB_RF_HEALTH_FAIL_RX = <span class="number">16 </span>; } } <span class="kw">impl </span>UavionixAdsbRfHealth { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UAVIONIX_ADSB_RF_HEALTH_INITIALIZING ; } <span class="kw">impl </span>Default <span class="kw">for </span>UavionixAdsbRfHealth { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MavPowerStatus : u16 { <span class="kw">const </span>MAV_POWER_STATUS_BRICK_VALID = <span class="number">1 </span>; <span class="kw">const </span>MAV_POWER_STATUS_SERVO_VALID = <span class="number">2 </span>; <span class="kw">const </span>MAV_POWER_STATUS_USB_CONNECTED = <span class="number">4 </span>; <span class="kw">const </span>MAV_POWER_STATUS_PERIPH_OVERCURRENT = <span class="number">8 </span>; <span class="kw">const </span>MAV_POWER_STATUS_PERIPH_HIPOWER_OVERCURRENT = <span class="number">16 </span>; <span class="kw">const </span>MAV_POWER_STATUS_CHANGED = <span class="number">32 </span>; } } <span class="kw">impl </span>MavPowerStatus { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_POWER_STATUS_BRICK_VALID ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavPowerStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>UavcanNodeHealth { UAVCAN_NODE_HEALTH_OK = <span class="number">0 </span>, UAVCAN_NODE_HEALTH_WARNING = <span class="number">1 </span>, UAVCAN_NODE_HEALTH_ERROR = <span class="number">2 </span>, UAVCAN_NODE_HEALTH_CRITICAL = <span class="number">3 </span>, } <span class="kw">impl </span>UavcanNodeHealth { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: UAVCAN_NODE_HEALTH_OK ; } <span class="kw">impl </span>Default <span class="kw">for </span>UavcanNodeHealth { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidStatus { MAV_ODID_STATUS_UNDECLARED = <span class="number">0 </span>, MAV_ODID_STATUS_GROUND = <span class="number">1 </span>, MAV_ODID_STATUS_AIRBORNE = <span class="number">2 </span>, MAV_ODID_STATUS_EMERGENCY = <span class="number">3 </span>, MAV_ODID_STATUS_REMOTE_ID_SYSTEM_FAILURE = <span class="number">4 </span>, } <span class="kw">impl </span>MavOdidStatus { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_STATUS_UNDECLARED ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidStatus { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>OrbitYawBehaviour { ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TO_CIRCLE_CENTER = <span class="number">0 </span>, ORBIT_YAW_BEHAVIOUR_HOLD_INITIAL_HEADING = <span class="number">1 </span>, ORBIT_YAW_BEHAVIOUR_UNCONTROLLED = <span class="number">2 </span>, ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TANGENT_TO_CIRCLE = <span class="number">3 </span>, ORBIT_YAW_BEHAVIOUR_RC_CONTROLLED = <span class="number">4 </span>, } <span class="kw">impl </span>OrbitYawBehaviour { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ORBIT_YAW_BEHAVIOUR_HOLD_FRONT_TO_CIRCLE_CENTER ; } <span class="kw">impl </span>Default <span class="kw">for </span>OrbitYawBehaviour { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>FenceMitigate { FENCE_MITIGATE_UNKNOWN = <span class="number">0 </span>, FENCE_MITIGATE_NONE = <span class="number">1 </span>, FENCE_MITIGATE_VEL_LIMIT = <span class="number">2 </span>, } <span class="kw">impl </span>FenceMitigate { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: FENCE_MITIGATE_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>FenceMitigate { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavMountMode { MAV_MOUNT_MODE_RETRACT = <span class="number">0 </span>, MAV_MOUNT_MODE_NEUTRAL = <span class="number">1 </span>, MAV_MOUNT_MODE_MAVLINK_TARGETING = <span class="number">2 </span>, MAV_MOUNT_MODE_RC_TARGETING = <span class="number">3 </span>, MAV_MOUNT_MODE_GPS_POINT = <span class="number">4 </span>, MAV_MOUNT_MODE_SYSID_TARGET = <span class="number">5 </span>, MAV_MOUNT_MODE_HOME_LOCATION = <span class="number">6 </span>, } <span class="kw">impl </span>MavMountMode { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_MOUNT_MODE_RETRACT ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavMountMode { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraStatusTypes { CAMERA_STATUS_TYPE_HEARTBEAT = <span class="number">0 </span>, CAMERA_STATUS_TYPE_TRIGGER = <span class="number">1 </span>, CAMERA_STATUS_TYPE_DISCONNECT = <span class="number">2 </span>, CAMERA_STATUS_TYPE_ERROR = <span class="number">3 </span>, CAMERA_STATUS_TYPE_LOWBATT = <span class="number">4 </span>, CAMERA_STATUS_TYPE_LOWSTORE = <span class="number">5 </span>, CAMERA_STATUS_TYPE_LOWSTOREV = <span class="number">6 </span>, } <span class="kw">impl </span>CameraStatusTypes { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CAMERA_STATUS_TYPE_HEARTBEAT ; } <span class="kw">impl </span>Default <span class="kw">for </span>CameraStatusTypes { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MissionState { MISSION_STATE_UNKNOWN = <span class="number">0 </span>, MISSION_STATE_NO_MISSION = <span class="number">1 </span>, MISSION_STATE_NOT_STARTED = <span class="number">2 </span>, MISSION_STATE_ACTIVE = <span class="number">3 </span>, MISSION_STATE_PAUSED = <span class="number">4 </span>, MISSION_STATE_COMPLETE = <span class="number">5 </span>, } <span class="kw">impl </span>MissionState { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MISSION_STATE_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>MissionState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavCollisionAction { MAV_COLLISION_ACTION_NONE = <span class="number">0 </span>, MAV_COLLISION_ACTION_REPORT = <span class="number">1 </span>, MAV_COLLISION_ACTION_ASCEND_OR_DESCEND = <span class="number">2 </span>, MAV_COLLISION_ACTION_MOVE_HORIZONTALLY = <span class="number">3 </span>, MAV_COLLISION_ACTION_MOVE_PERPENDICULAR = <span class="number">4 </span>, MAV_COLLISION_ACTION_RTL = <span class="number">5 </span>, MAV_COLLISION_ACTION_HOVER = <span class="number">6 </span>, } <span class="kw">impl </span>MavCollisionAction { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_COLLISION_ACTION_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavCollisionAction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>WinchActions { WINCH_RELAXED = <span class="number">0 </span>, WINCH_RELATIVE_LENGTH_CONTROL = <span class="number">1 </span>, WINCH_RATE_CONTROL = <span class="number">2 </span>, WINCH_LOCK = <span class="number">3 </span>, WINCH_DELIVER = <span class="number">4 </span>, WINCH_HOLD = <span class="number">5 </span>, WINCH_RETRACT = <span class="number">6 </span>, WINCH_LOAD_LINE = <span class="number">7 </span>, WINCH_ABANDON_LINE = <span class="number">8 </span>, WINCH_LOAD_PAYLOAD = <span class="number">9 </span>, } <span class="kw">impl </span>WinchActions { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: WINCH_RELAXED ; } <span class="kw">impl </span>Default <span class="kw">for </span>WinchActions { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproPhotoResolution { GOPRO_PHOTO_RESOLUTION_5MP_MEDIUM = <span class="number">0 </span>, GOPRO_PHOTO_RESOLUTION_7MP_MEDIUM = <span class="number">1 </span>, GOPRO_PHOTO_RESOLUTION_7MP_WIDE = <span class="number">2 </span>, GOPRO_PHOTO_RESOLUTION_10MP_WIDE = <span class="number">3 </span>, GOPRO_PHOTO_RESOLUTION_12MP_WIDE = <span class="number">4 </span>, } <span class="kw">impl </span>GoproPhotoResolution { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_PHOTO_RESOLUTION_5MP_MEDIUM ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproPhotoResolution { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproModel { GOPRO_MODEL_UNKNOWN = <span class="number">0 </span>, GOPRO_MODEL_HERO_3_PLUS_SILVER = <span class="number">1 </span>, GOPRO_MODEL_HERO_3_PLUS_BLACK = <span class="number">2 </span>, GOPRO_MODEL_HERO_4_SILVER = <span class="number">3 </span>, GOPRO_MODEL_HERO_4_BLACK = <span class="number">4 </span>, } <span class="kw">impl </span>GoproModel { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_MODEL_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproModel { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HilSensorUpdatedFlags : u32 { <span class="kw">const </span>HIL_SENSOR_UPDATED_NONE = <span class="number">0 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_XACC = <span class="number">1 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_YACC = <span class="number">2 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_ZACC = <span class="number">4 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_XGYRO = <span class="number">8 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_YGYRO = <span class="number">16 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_ZGYRO = <span class="number">32 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_XMAG = <span class="number">64 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_YMAG = <span class="number">128 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_ZMAG = <span class="number">256 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_ABS_PRESSURE = <span class="number">512 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_DIFF_PRESSURE = <span class="number">1024 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_PRESSURE_ALT = <span class="number">2048 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_TEMPERATURE = <span class="number">4096 </span>; <span class="kw">const </span>HIL_SENSOR_UPDATED_RESET = <span class="number">2147483648 </span>; } } <span class="kw">impl </span>HilSensorUpdatedFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: HIL_SENSOR_UPDATED_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>HilSensorUpdatedFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>NavVtolLandOptions { NAV_VTOL_LAND_OPTIONS_DEFAULT = <span class="number">0 </span>, NAV_VTOL_LAND_OPTIONS_FW_DESCENT = <span class="number">1 </span>, NAV_VTOL_LAND_OPTIONS_HOVER_DESCENT = <span class="number">2 </span>, } <span class="kw">impl </span>NavVtolLandOptions { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: NAV_VTOL_LAND_OPTIONS_DEFAULT ; } <span class="kw">impl </span>Default <span class="kw">for </span>NavVtolLandOptions { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GoproProtuneGain { GOPRO_PROTUNE_GAIN_400 = <span class="number">0 </span>, GOPRO_PROTUNE_GAIN_800 = <span class="number">1 </span>, GOPRO_PROTUNE_GAIN_1600 = <span class="number">2 </span>, GOPRO_PROTUNE_GAIN_3200 = <span class="number">3 </span>, GOPRO_PROTUNE_GAIN_6400 = <span class="number">4 </span>, } <span class="kw">impl </span>GoproProtuneGain { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GOPRO_PROTUNE_GAIN_400 ; } <span class="kw">impl </span>Default <span class="kw">for </span>GoproProtuneGain { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CameraCapFlags : u32 { <span class="kw">const </span>CAMERA_CAP_FLAGS_CAPTURE_VIDEO = <span class="number">1 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_CAPTURE_IMAGE = <span class="number">2 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_MODES = <span class="number">4 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_CAN_CAPTURE_IMAGE_IN_VIDEO_MODE = <span class="number">8 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_CAN_CAPTURE_VIDEO_IN_IMAGE_MODE = <span class="number">16 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_IMAGE_SURVEY_MODE = <span class="number">32 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_BASIC_ZOOM = <span class="number">64 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_BASIC_FOCUS = <span class="number">128 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_VIDEO_STREAM = <span class="number">256 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_TRACKING_POINT = <span class="number">512 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_TRACKING_RECTANGLE = <span class="number">1024 </span>; <span class="kw">const </span>CAMERA_CAP_FLAGS_HAS_TRACKING_GEO_STATUS = <span class="number">2048 </span>; } } <span class="kw">impl </span>CameraCapFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CAMERA_CAP_FLAGS_CAPTURE_VIDEO ; } <span class="kw">impl </span>Default <span class="kw">for </span>CameraCapFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>AccelcalVehiclePos { ACCELCAL_VEHICLE_POS_LEVEL = <span class="number">1 </span>, ACCELCAL_VEHICLE_POS_LEFT = <span class="number">2 </span>, ACCELCAL_VEHICLE_POS_RIGHT = <span class="number">3 </span>, ACCELCAL_VEHICLE_POS_NOSEDOWN = <span class="number">4 </span>, ACCELCAL_VEHICLE_POS_NOSEUP = <span class="number">5 </span>, ACCELCAL_VEHICLE_POS_BACK = <span class="number">6 </span>, ACCELCAL_VEHICLE_POS_SUCCESS = <span class="number">16777215 </span>, ACCELCAL_VEHICLE_POS_FAILED = <span class="number">16777216 </span>, } <span class="kw">impl </span>AccelcalVehiclePos { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ACCELCAL_VEHICLE_POS_LEVEL ; } <span class="kw">impl </span>Default <span class="kw">for </span>AccelcalVehiclePos { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>IcarousFmsState { ICAROUS_FMS_STATE_IDLE = <span class="number">0 </span>, ICAROUS_FMS_STATE_TAKEOFF = <span class="number">1 </span>, ICAROUS_FMS_STATE_CLIMB = <span class="number">2 </span>, ICAROUS_FMS_STATE_CRUISE = <span class="number">3 </span>, ICAROUS_FMS_STATE_APPROACH = <span class="number">4 </span>, ICAROUS_FMS_STATE_LAND = <span class="number">5 </span>, } <span class="kw">impl </span>IcarousFmsState { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ICAROUS_FMS_STATE_IDLE ; } <span class="kw">impl </span>Default <span class="kw">for </span>IcarousFmsState { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavOdidUaType { MAV_ODID_UA_TYPE_NONE = <span class="number">0 </span>, MAV_ODID_UA_TYPE_AEROPLANE = <span class="number">1 </span>, MAV_ODID_UA_TYPE_HELICOPTER_OR_MULTIROTOR = <span class="number">2 </span>, MAV_ODID_UA_TYPE_GYROPLANE = <span class="number">3 </span>, MAV_ODID_UA_TYPE_HYBRID_LIFT = <span class="number">4 </span>, MAV_ODID_UA_TYPE_ORNITHOPTER = <span class="number">5 </span>, MAV_ODID_UA_TYPE_GLIDER = <span class="number">6 </span>, MAV_ODID_UA_TYPE_KITE = <span class="number">7 </span>, MAV_ODID_UA_TYPE_FREE_BALLOON = <span class="number">8 </span>, MAV_ODID_UA_TYPE_CAPTIVE_BALLOON = <span class="number">9 </span>, MAV_ODID_UA_TYPE_AIRSHIP = <span class="number">10 </span>, MAV_ODID_UA_TYPE_FREE_FALL_PARACHUTE = <span class="number">11 </span>, MAV_ODID_UA_TYPE_ROCKET = <span class="number">12 </span>, MAV_ODID_UA_TYPE_TETHERED_POWERED_AIRCRAFT = <span class="number">13 </span>, MAV_ODID_UA_TYPE_GROUND_OBSTACLE = <span class="number">14 </span>, MAV_ODID_UA_TYPE_OTHER = <span class="number">15 </span>, } <span class="kw">impl </span>MavOdidUaType { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_ODID_UA_TYPE_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavOdidUaType { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EstimatorStatusFlags : u16 { <span class="kw">const </span>ESTIMATOR_ATTITUDE = <span class="number">1 </span>; <span class="kw">const </span>ESTIMATOR_VELOCITY_HORIZ = <span class="number">2 </span>; <span class="kw">const </span>ESTIMATOR_VELOCITY_VERT = <span class="number">4 </span>; <span class="kw">const </span>ESTIMATOR_POS_HORIZ_REL = <span class="number">8 </span>; <span class="kw">const </span>ESTIMATOR_POS_HORIZ_ABS = <span class="number">16 </span>; <span class="kw">const </span>ESTIMATOR_POS_VERT_ABS = <span class="number">32 </span>; <span class="kw">const </span>ESTIMATOR_POS_VERT_AGL = <span class="number">64 </span>; <span class="kw">const </span>ESTIMATOR_CONST_POS_MODE = <span class="number">128 </span>; <span class="kw">const </span>ESTIMATOR_PRED_POS_HORIZ_REL = <span class="number">256 </span>; <span class="kw">const </span>ESTIMATOR_PRED_POS_HORIZ_ABS = <span class="number">512 </span>; <span class="kw">const </span>ESTIMATOR_GPS_GLITCH = <span class="number">1024 </span>; <span class="kw">const </span>ESTIMATOR_ACCEL_ERROR = <span class="number">2048 </span>; } } <span class="kw">impl </span>EstimatorStatusFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ESTIMATOR_ATTITUDE ; } <span class="kw">impl </span>Default <span class="kw">for </span>EstimatorStatusFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GimbalAxisCalibrationRequired { GIMBAL_AXIS_CALIBRATION_REQUIRED_UNKNOWN = <span class="number">0 </span>, GIMBAL_AXIS_CALIBRATION_REQUIRED_TRUE = <span class="number">1 </span>, GIMBAL_AXIS_CALIBRATION_REQUIRED_FALSE = <span class="number">2 </span>, } <span class="kw">impl </span>GimbalAxisCalibrationRequired { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GIMBAL_AXIS_CALIBRATION_REQUIRED_UNKNOWN ; } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalAxisCalibrationRequired { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>PreflightStorageMissionAction { MISSION_READ_PERSISTENT = <span class="number">0 </span>, MISSION_WRITE_PERSISTENT = <span class="number">1 </span>, MISSION_RESET_DEFAULT = <span class="number">2 </span>, } <span class="kw">impl </span>PreflightStorageMissionAction { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MISSION_READ_PERSISTENT ; } <span class="kw">impl </span>Default <span class="kw">for </span>PreflightStorageMissionAction { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>ActuatorConfiguration { ACTUATOR_CONFIGURATION_NONE = <span class="number">0 </span>, ACTUATOR_CONFIGURATION_BEEP = <span class="number">1 </span>, ACTUATOR_CONFIGURATION_3D_MODE_ON = <span class="number">2 </span>, ACTUATOR_CONFIGURATION_3D_MODE_OFF = <span class="number">3 </span>, ACTUATOR_CONFIGURATION_SPIN_DIRECTION1 = <span class="number">4 </span>, ACTUATOR_CONFIGURATION_SPIN_DIRECTION2 = <span class="number">5 </span>, } <span class="kw">impl </span>ActuatorConfiguration { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: ACTUATOR_CONFIGURATION_NONE ; } <span class="kw">impl </span>Default <span class="kw">for </span>ActuatorConfiguration { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } bitflags ! { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GpsInputIgnoreFlags : u16 { <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_ALT = <span class="number">1 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_HDOP = <span class="number">2 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_VDOP = <span class="number">4 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_VEL_HORIZ = <span class="number">8 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_VEL_VERT = <span class="number">16 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_SPEED_ACCURACY = <span class="number">32 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_HORIZONTAL_ACCURACY = <span class="number">64 </span>; <span class="kw">const </span>GPS_INPUT_IGNORE_FLAG_VERTICAL_ACCURACY = <span class="number">128 </span>; } } <span class="kw">impl </span>GpsInputIgnoreFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GPS_INPUT_IGNORE_FLAG_ALT ; } <span class="kw">impl </span>Default <span class="kw">for </span>GpsInputIgnoreFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>CameraTrackingStatusFlags { CAMERA_TRACKING_STATUS_FLAGS_IDLE = <span class="number">0 </span>, CAMERA_TRACKING_STATUS_FLAGS_ACTIVE = <span class="number">1 </span>, CAMERA_TRACKING_STATUS_FLAGS_ERROR = <span class="number">2 </span>, } <span class="kw">impl </span>CameraTrackingStatusFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: CAMERA_TRACKING_STATUS_FLAGS_IDLE ; } <span class="kw">impl </span>Default <span class="kw">for </span>CameraTrackingStatusFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavCmdDoAuxFunctionSwitchLevel { MAV_CMD_DO_AUX_FUNCTION_SWITCH_LEVEL_LOW = <span class="number">0 </span>, MAV_CMD_DO_AUX_FUNCTION_SWITCH_LEVEL_MIDDLE = <span class="number">1 </span>, MAV_CMD_DO_AUX_FUNCTION_SWITCH_LEVEL_HIGH = <span class="number">2 </span>, } <span class="kw">impl </span>MavCmdDoAuxFunctionSwitchLevel { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: MAV_CMD_DO_AUX_FUNCTION_SWITCH_LEVEL_LOW ; } <span class="kw">impl </span>Default <span class="kw">for </span>MavCmdDoAuxFunctionSwitchLevel { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>GimbalManagerFlags { GIMBAL_MANAGER_FLAGS_RETRACT = <span class="number">1 </span>, GIMBAL_MANAGER_FLAGS_NEUTRAL = <span class="number">2 </span>, GIMBAL_MANAGER_FLAGS_ROLL_LOCK = <span class="number">4 </span>, GIMBAL_MANAGER_FLAGS_PITCH_LOCK = <span class="number">8 </span>, GIMBAL_MANAGER_FLAGS_YAW_LOCK = <span class="number">16 </span>, GIMBAL_MANAGER_FLAGS_YAW_IN_VEHICLE_FRAME = <span class="number">32 </span>, GIMBAL_MANAGER_FLAGS_YAW_IN_EARTH_FRAME = <span class="number">64 </span>, GIMBAL_MANAGER_FLAGS_ACCEPTS_YAW_IN_EARTH_FRAME = <span class="number">128 </span>, GIMBAL_MANAGER_FLAGS_RC_EXCLUSIVE = <span class="number">256 </span>, GIMBAL_MANAGER_FLAGS_RC_MIXED = <span class="number">512 </span>, } <span class="kw">impl </span>GimbalManagerFlags { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: GIMBAL_MANAGER_FLAGS_RETRACT ; } <span class="kw">impl </span>Default <span class="kw">for </span>GimbalManagerFlags { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Copy , Clone , PartialEq , FromPrimitive , ToPrimitive)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>PidTuningAxis { PID_TUNING_ROLL = <span class="number">1 </span>, PID_TUNING_PITCH = <span class="number">2 </span>, PID_TUNING_YAW = <span class="number">3 </span>, PID_TUNING_ACCZ = <span class="number">4 </span>, PID_TUNING_STEER = <span class="number">5 </span>, PID_TUNING_LANDING = <span class="number">6 </span>, } <span class="kw">impl </span>PidTuningAxis { <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>:: PID_TUNING_ROLL ; } <span class="kw">impl </span>Default <span class="kw">for </span>PidTuningAxis { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GOPRO_GET_REQUEST_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>cmd_id : GoproCommand , } <span class="kw">impl </span>GOPRO_GET_REQUEST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, cmd_id : GoproCommand :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . cmd_id = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GoproCommand&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. cmd_id <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GOPRO_GET_REQUEST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COLLISION_DATA { <span class="kw">pub </span>id : u32 , <span class="kw">pub </span>time_to_minimum_delta : f32 , <span class="kw">pub </span>altitude_minimum_delta : f32 , <span class="kw">pub </span>horizontal_minimum_delta : f32 , <span class="kw">pub </span>src : MavCollisionSrc , <span class="kw">pub </span>action : MavCollisionAction , <span class="kw">pub </span>threat_level : MavCollisionThreatLevel , } <span class="kw">impl </span>COLLISION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">19usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ id : <span class="number">0_u32 </span>, time_to_minimum_delta : <span class="number">0.0_f32 </span>, altitude_minimum_delta : <span class="number">0.0_f32 </span>, horizontal_minimum_delta : <span class="number">0.0_f32 </span>, src : MavCollisionSrc :: DEFAULT , action : MavCollisionAction :: DEFAULT , threat_level : MavCollisionThreatLevel :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . id = buf . get_u32_le () ; _struct . time_to_minimum_delta = buf . get_f32_le () ; _struct . altitude_minimum_delta = buf . get_f32_le () ; _struct . horizontal_minimum_delta = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . src = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCollisionSrc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . action = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCollisionAction&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . threat_level = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCollisionThreatLevel&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. id) ; _tmp . put_f32_le (<span class="self">self </span>. time_to_minimum_delta) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_minimum_delta) ; _tmp . put_f32_le (<span class="self">self </span>. horizontal_minimum_delta) ; _tmp . put_u8 (<span class="self">self </span>. src <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. action <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. threat_level <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>COLLISION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RC_CHANNELS_OVERRIDE_DATA { <span class="kw">pub </span>chan1_raw : u16 , <span class="kw">pub </span>chan2_raw : u16 , <span class="kw">pub </span>chan3_raw : u16 , <span class="kw">pub </span>chan4_raw : u16 , <span class="kw">pub </span>chan5_raw : u16 , <span class="kw">pub </span>chan6_raw : u16 , <span class="kw">pub </span>chan7_raw : u16 , <span class="kw">pub </span>chan8_raw : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>RC_CHANNELS_OVERRIDE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ chan1_raw : <span class="number">0_u16 </span>, chan2_raw : <span class="number">0_u16 </span>, chan3_raw : <span class="number">0_u16 </span>, chan4_raw : <span class="number">0_u16 </span>, chan5_raw : <span class="number">0_u16 </span>, chan6_raw : <span class="number">0_u16 </span>, chan7_raw : <span class="number">0_u16 </span>, chan8_raw : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . chan1_raw = buf . get_u16_le () ; _struct . chan2_raw = buf . get_u16_le () ; _struct . chan3_raw = buf . get_u16_le () ; _struct . chan4_raw = buf . get_u16_le () ; _struct . chan5_raw = buf . get_u16_le () ; _struct . chan6_raw = buf . get_u16_le () ; _struct . chan7_raw = buf . get_u16_le () ; _struct . chan8_raw = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. chan1_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan2_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan3_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan4_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan5_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan6_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan7_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan8_raw) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RC_CHANNELS_OVERRIDE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SAFETY_ALLOWED_AREA_DATA { <span class="kw">pub </span>p1x : f32 , <span class="kw">pub </span>p1y : f32 , <span class="kw">pub </span>p1z : f32 , <span class="kw">pub </span>p2x : f32 , <span class="kw">pub </span>p2y : f32 , <span class="kw">pub </span>p2z : f32 , <span class="kw">pub </span>frame : MavFrame , } <span class="kw">impl </span>SAFETY_ALLOWED_AREA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">25usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ p1x : <span class="number">0.0_f32 </span>, p1y : <span class="number">0.0_f32 </span>, p1z : <span class="number">0.0_f32 </span>, p2x : <span class="number">0.0_f32 </span>, p2y : <span class="number">0.0_f32 </span>, p2z : <span class="number">0.0_f32 </span>, frame : MavFrame :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . p1x = buf . get_f32_le () ; _struct . p1y = buf . get_f32_le () ; _struct . p1z = buf . get_f32_le () ; _struct . p2x = buf . get_f32_le () ; _struct . p2y = buf . get_f32_le () ; _struct . p2z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. p1x) ; _tmp . put_f32_le (<span class="self">self </span>. p1y) ; _tmp . put_f32_le (<span class="self">self </span>. p1z) ; _tmp . put_f32_le (<span class="self">self </span>. p2x) ; _tmp . put_f32_le (<span class="self">self </span>. p2y) ; _tmp . put_f32_le (<span class="self">self </span>. p2z) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SAFETY_ALLOWED_AREA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RC_CHANNELS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>chan1_raw : u16 , <span class="kw">pub </span>chan2_raw : u16 , <span class="kw">pub </span>chan3_raw : u16 , <span class="kw">pub </span>chan4_raw : u16 , <span class="kw">pub </span>chan5_raw : u16 , <span class="kw">pub </span>chan6_raw : u16 , <span class="kw">pub </span>chan7_raw : u16 , <span class="kw">pub </span>chan8_raw : u16 , <span class="kw">pub </span>chan9_raw : u16 , <span class="kw">pub </span>chan10_raw : u16 , <span class="kw">pub </span>chan11_raw : u16 , <span class="kw">pub </span>chan12_raw : u16 , <span class="kw">pub </span>chan13_raw : u16 , <span class="kw">pub </span>chan14_raw : u16 , <span class="kw">pub </span>chan15_raw : u16 , <span class="kw">pub </span>chan16_raw : u16 , <span class="kw">pub </span>chan17_raw : u16 , <span class="kw">pub </span>chan18_raw : u16 , <span class="kw">pub </span>chancount : u8 , <span class="kw">pub </span>rssi : u8 , } <span class="kw">impl </span>RC_CHANNELS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, chan1_raw : <span class="number">0_u16 </span>, chan2_raw : <span class="number">0_u16 </span>, chan3_raw : <span class="number">0_u16 </span>, chan4_raw : <span class="number">0_u16 </span>, chan5_raw : <span class="number">0_u16 </span>, chan6_raw : <span class="number">0_u16 </span>, chan7_raw : <span class="number">0_u16 </span>, chan8_raw : <span class="number">0_u16 </span>, chan9_raw : <span class="number">0_u16 </span>, chan10_raw : <span class="number">0_u16 </span>, chan11_raw : <span class="number">0_u16 </span>, chan12_raw : <span class="number">0_u16 </span>, chan13_raw : <span class="number">0_u16 </span>, chan14_raw : <span class="number">0_u16 </span>, chan15_raw : <span class="number">0_u16 </span>, chan16_raw : <span class="number">0_u16 </span>, chan17_raw : <span class="number">0_u16 </span>, chan18_raw : <span class="number">0_u16 </span>, chancount : <span class="number">0_u8 </span>, rssi : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . chan1_raw = buf . get_u16_le () ; _struct . chan2_raw = buf . get_u16_le () ; _struct . chan3_raw = buf . get_u16_le () ; _struct . chan4_raw = buf . get_u16_le () ; _struct . chan5_raw = buf . get_u16_le () ; _struct . chan6_raw = buf . get_u16_le () ; _struct . chan7_raw = buf . get_u16_le () ; _struct . chan8_raw = buf . get_u16_le () ; _struct . chan9_raw = buf . get_u16_le () ; _struct . chan10_raw = buf . get_u16_le () ; _struct . chan11_raw = buf . get_u16_le () ; _struct . chan12_raw = buf . get_u16_le () ; _struct . chan13_raw = buf . get_u16_le () ; _struct . chan14_raw = buf . get_u16_le () ; _struct . chan15_raw = buf . get_u16_le () ; _struct . chan16_raw = buf . get_u16_le () ; _struct . chan17_raw = buf . get_u16_le () ; _struct . chan18_raw = buf . get_u16_le () ; _struct . chancount = buf . get_u8 () ; _struct . rssi = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u16_le (<span class="self">self </span>. chan1_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan2_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan3_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan4_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan5_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan6_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan7_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan8_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan9_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan10_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan11_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan12_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan13_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan14_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan15_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan16_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan17_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan18_raw) ; _tmp . put_u8 (<span class="self">self </span>. chancount) ; _tmp . put_u8 (<span class="self">self </span>. rssi) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RC_CHANNELS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RANGEFINDER_DATA { <span class="kw">pub </span>distance : f32 , <span class="kw">pub </span>voltage : f32 , } <span class="kw">impl </span>RANGEFINDER_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">8usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ distance : <span class="number">0.0_f32 </span>, voltage : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . distance = buf . get_f32_le () ; _struct . voltage = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. distance) ; _tmp . put_f32_le (<span class="self">self </span>. voltage) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RANGEFINDER_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_DEVICE_ATTITUDE_STATUS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>angular_velocity_x : f32 , <span class="kw">pub </span>angular_velocity_y : f32 , <span class="kw">pub </span>angular_velocity_z : f32 , <span class="kw">pub </span>failure_flags : GimbalDeviceErrorFlags , <span class="kw">pub </span>flags : GimbalDeviceFlags , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>GIMBAL_DEVICE_ATTITUDE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">40usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , angular_velocity_x : <span class="number">0.0_f32 </span>, angular_velocity_y : <span class="number">0.0_f32 </span>, angular_velocity_z : <span class="number">0.0_f32 </span>, failure_flags : GimbalDeviceErrorFlags :: DEFAULT , flags : GimbalDeviceFlags :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . angular_velocity_x = buf . get_f32_le () ; _struct . angular_velocity_y = buf . get_f32_le () ; _struct . angular_velocity_z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . failure_flags = GimbalDeviceErrorFlags :: from_bits (tmp &amp; GimbalDeviceErrorFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GimbalDeviceErrorFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = GimbalDeviceFlags :: from_bits (tmp &amp; GimbalDeviceFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GimbalDeviceFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_x) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_y) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_z) ; _tmp . put_u32_le (<span class="self">self </span>. failure_flags . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GIMBAL_DEVICE_ATTITUDE_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GLOBAL_POSITION_INT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>relative_alt : i32 , <span class="kw">pub </span>vx : i16 , <span class="kw">pub </span>vy : i16 , <span class="kw">pub </span>vz : i16 , <span class="kw">pub </span>hdg : u16 , } <span class="kw">impl </span>GLOBAL_POSITION_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0_i32 </span>, relative_alt : <span class="number">0_i32 </span>, vx : <span class="number">0_i16 </span>, vy : <span class="number">0_i16 </span>, vz : <span class="number">0_i16 </span>, hdg : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . relative_alt = buf . get_i32_le () ; _struct . vx = buf . get_i16_le () ; _struct . vy = buf . get_i16_le () ; _struct . vz = buf . get_i16_le () ; _struct . hdg = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i32_le (<span class="self">self </span>. relative_alt) ; _tmp . put_i16_le (<span class="self">self </span>. vx) ; _tmp . put_i16_le (<span class="self">self </span>. vy) ; _tmp . put_i16_le (<span class="self">self </span>. vz) ; _tmp . put_u16_le (<span class="self">self </span>. hdg) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GLOBAL_POSITION_INT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_VALUE_DATA { <span class="kw">pub </span>param_value : f32 , <span class="kw">pub </span>param_count : u16 , <span class="kw">pub </span>param_index : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>param_type : MavParamType , } <span class="kw">impl </span>PARAM_VALUE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">25usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ param_value : <span class="number">0.0_f32 </span>, param_count : <span class="number">0_u16 </span>, param_index : <span class="number">0_u16 </span>, param_id : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , param_type : MavParamType :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_value = buf . get_f32_le () ; _struct . param_count = buf . get_u16_le () ; _struct . param_index = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavParamType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param_value) ; _tmp . put_u16_le (<span class="self">self </span>. param_count) ; _tmp . put_u16_le (<span class="self">self </span>. param_index) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. param_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PARAM_VALUE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EVENT_DATA { <span class="kw">pub </span>id : u32 , <span class="kw">pub </span>event_time_boot_ms : u32 , <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>destination_component : u8 , <span class="kw">pub </span>destination_system : u8 , <span class="kw">pub </span>log_levels : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>arguments : [u8 ; <span class="number">40</span>] , } <span class="kw">impl </span>EVENT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ id : <span class="number">0_u32 </span>, event_time_boot_ms : <span class="number">0_u32 </span>, sequence : <span class="number">0_u16 </span>, destination_component : <span class="number">0_u8 </span>, destination_system : <span class="number">0_u8 </span>, log_levels : <span class="number">0_u8 </span>, arguments : [<span class="number">0_u8 </span>; <span class="number">40usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . id = buf . get_u32_le () ; _struct . event_time_boot_ms = buf . get_u32_le () ; _struct . sequence = buf . get_u16_le () ; _struct . destination_component = buf . get_u8 () ; _struct . destination_system = buf . get_u8 () ; _struct . log_levels = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . arguments { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. id) ; _tmp . put_u32_le (<span class="self">self </span>. event_time_boot_ms) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u8 (<span class="self">self </span>. destination_component) ; _tmp . put_u8 (<span class="self">self </span>. destination_system) ; _tmp . put_u8 (<span class="self">self </span>. log_levels) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. arguments { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>EVENT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_IMU_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , <span class="kw">pub </span>xgyro : i16 , <span class="kw">pub </span>ygyro : i16 , <span class="kw">pub </span>zgyro : i16 , <span class="kw">pub </span>xmag : i16 , <span class="kw">pub </span>ymag : i16 , <span class="kw">pub </span>zmag : i16 , } <span class="kw">impl </span>SCALED_IMU_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, xacc : <span class="number">0_i16 </span>, yacc : <span class="number">0_i16 </span>, zacc : <span class="number">0_i16 </span>, xgyro : <span class="number">0_i16 </span>, ygyro : <span class="number">0_i16 </span>, zgyro : <span class="number">0_i16 </span>, xmag : <span class="number">0_i16 </span>, ymag : <span class="number">0_i16 </span>, zmag : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; _struct . xgyro = buf . get_i16_le () ; _struct . ygyro = buf . get_i16_le () ; _struct . zgyro = buf . get_i16_le () ; _struct . xmag = buf . get_i16_le () ; _struct . ymag = buf . get_i16_le () ; _struct . zmag = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; _tmp . put_i16_le (<span class="self">self </span>. xgyro) ; _tmp . put_i16_le (<span class="self">self </span>. ygyro) ; _tmp . put_i16_le (<span class="self">self </span>. zgyro) ; _tmp . put_i16_le (<span class="self">self </span>. xmag) ; _tmp . put_i16_le (<span class="self">self </span>. ymag) ; _tmp . put_i16_le (<span class="self">self </span>. zmag) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SCALED_IMU_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>BATTERY_STATUS_DATA { <span class="kw">pub </span>current_consumed : i32 , <span class="kw">pub </span>energy_consumed : i32 , <span class="kw">pub </span>temperature : i16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>voltages : [u16 ; <span class="number">10</span>] , <span class="kw">pub </span>current_battery : i16 , <span class="kw">pub </span>id : u8 , <span class="kw">pub </span>battery_function : MavBatteryFunction , <span class="kw">pub </span>mavtype : MavBatteryType , <span class="kw">pub </span>battery_remaining : i8 , } <span class="kw">impl </span>BATTERY_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">36usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ current_consumed : <span class="number">0_i32 </span>, energy_consumed : <span class="number">0_i32 </span>, temperature : <span class="number">0_i16 </span>, voltages : [<span class="number">0_u16 </span>; <span class="number">10usize</span>] , current_battery : <span class="number">0_i16 </span>, id : <span class="number">0_u8 </span>, battery_function : MavBatteryFunction :: DEFAULT , mavtype : MavBatteryType :: DEFAULT , battery_remaining : <span class="number">0_i8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . current_consumed = buf . get_i32_le () ; _struct . energy_consumed = buf . get_i32_le () ; _struct . temperature = buf . get_i16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . voltages { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } _struct . current_battery = buf . get_i16_le () ; _struct . id = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . battery_function = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavBatteryFunction&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavBatteryType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . battery_remaining = buf . get_i8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. current_consumed) ; _tmp . put_i32_le (<span class="self">self </span>. energy_consumed) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. voltages { _tmp . put_u16_le (* val) ; } _tmp . put_i16_le (<span class="self">self </span>. current_battery) ; _tmp . put_u8 (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. battery_function <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_i8 (<span class="self">self </span>. battery_remaining) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>BATTERY_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>V2_EXTENSION_DATA { <span class="kw">pub </span>message_type : u16 , <span class="kw">pub </span>target_network : u8 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>payload : [u8 ; <span class="number">249</span>] , } <span class="kw">impl </span>V2_EXTENSION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">254usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ message_type : <span class="number">0_u16 </span>, target_network : <span class="number">0_u8 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, payload : [<span class="number">0_u8 </span>; <span class="number">249usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . message_type = buf . get_u16_le () ; _struct . target_network = buf . get_u8 () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . payload { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. message_type) ; _tmp . put_u8 (<span class="self">self </span>. target_network) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. payload { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>V2_EXTENSION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_STATE_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>vx : i16 , <span class="kw">pub </span>vy : i16 , <span class="kw">pub </span>vz : i16 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , } <span class="kw">impl </span>HIL_STATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">56usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, rollspeed : <span class="number">0.0_f32 </span>, pitchspeed : <span class="number">0.0_f32 </span>, yawspeed : <span class="number">0.0_f32 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0_i32 </span>, vx : <span class="number">0_i16 </span>, vy : <span class="number">0_i16 </span>, vz : <span class="number">0_i16 </span>, xacc : <span class="number">0_i16 </span>, yacc : <span class="number">0_i16 </span>, zacc : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . vx = buf . get_i16_le () ; _struct . vy = buf . get_i16_le () ; _struct . vz = buf . get_i16_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i16_le (<span class="self">self </span>. vx) ; _tmp . put_i16_le (<span class="self">self </span>. vy) ; _tmp . put_i16_le (<span class="self">self </span>. vz) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HIL_STATE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AOA_SSA_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>AOA : f32 , <span class="kw">pub </span>SSA : f32 , } <span class="kw">impl </span>AOA_SSA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">16usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, AOA : <span class="number">0.0_f32 </span>, SSA : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . AOA = buf . get_f32_le () ; _struct . SSA = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. AOA) ; _tmp . put_f32_le (<span class="self">self </span>. SSA) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>AOA_SSA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>REQUEST_EVENT_DATA { <span class="kw">pub </span>first_sequence : u16 , <span class="kw">pub </span>last_sequence : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>REQUEST_EVENT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ first_sequence : <span class="number">0_u16 </span>, last_sequence : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . first_sequence = buf . get_u16_le () ; _struct . last_sequence = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. first_sequence) ; _tmp . put_u16_le (<span class="self">self </span>. last_sequence) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>REQUEST_EVENT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AIS_VESSEL_DATA { <span class="kw">pub </span>MMSI : u32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>COG : u16 , <span class="kw">pub </span>heading : u16 , <span class="kw">pub </span>velocity : u16 , <span class="kw">pub </span>dimension_bow : u16 , <span class="kw">pub </span>dimension_stern : u16 , <span class="kw">pub </span>tslc : u16 , <span class="kw">pub </span>flags : AisFlags , <span class="kw">pub </span>turn_rate : i8 , <span class="kw">pub </span>navigational_status : AisNavStatus , <span class="kw">pub </span>mavtype : AisType , <span class="kw">pub </span>dimension_port : u8 , <span class="kw">pub </span>dimension_starboard : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>callsign : [u8 ; <span class="number">7</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>name : [u8 ; <span class="number">20</span>] , } <span class="kw">impl </span>AIS_VESSEL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">58usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ MMSI : <span class="number">0_u32 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, COG : <span class="number">0_u16 </span>, heading : <span class="number">0_u16 </span>, velocity : <span class="number">0_u16 </span>, dimension_bow : <span class="number">0_u16 </span>, dimension_stern : <span class="number">0_u16 </span>, tslc : <span class="number">0_u16 </span>, flags : AisFlags :: DEFAULT , turn_rate : <span class="number">0_i8 </span>, navigational_status : AisNavStatus :: DEFAULT , mavtype : AisType :: DEFAULT , dimension_port : <span class="number">0_u8 </span>, dimension_starboard : <span class="number">0_u8 </span>, callsign : [<span class="number">0_u8 </span>; <span class="number">7usize</span>] , name : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . MMSI = buf . get_u32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . COG = buf . get_u16_le () ; _struct . heading = buf . get_u16_le () ; _struct . velocity = buf . get_u16_le () ; _struct . dimension_bow = buf . get_u16_le () ; _struct . dimension_stern = buf . get_u16_le () ; _struct . tslc = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = AisFlags :: from_bits (tmp &amp; AisFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;AisFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . turn_rate = buf . get_i8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . navigational_status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;AisNavStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;AisType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . dimension_port = buf . get_u8 () ; _struct . dimension_starboard = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . callsign { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. MMSI) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_u16_le (<span class="self">self </span>. COG) ; _tmp . put_u16_le (<span class="self">self </span>. heading) ; _tmp . put_u16_le (<span class="self">self </span>. velocity) ; _tmp . put_u16_le (<span class="self">self </span>. dimension_bow) ; _tmp . put_u16_le (<span class="self">self </span>. dimension_stern) ; _tmp . put_u16_le (<span class="self">self </span>. tslc) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; _tmp . put_i8 (<span class="self">self </span>. turn_rate) ; _tmp . put_u8 (<span class="self">self </span>. navigational_status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. dimension_port) ; _tmp . put_u8 (<span class="self">self </span>. dimension_starboard) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. callsign { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>AIS_VESSEL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DEBUG_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>value : f32 , <span class="kw">pub </span>ind : u8 , } <span class="kw">impl </span>DEBUG_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">9usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, value : <span class="number">0.0_f32 </span>, ind : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . value = buf . get_f32_le () ; _struct . ind = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. value) ; _tmp . put_u8 (<span class="self">self </span>. ind) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DEBUG_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SUPPORTED_TUNES_DATA { <span class="kw">pub </span>format : TuneFormat , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>SUPPORTED_TUNES_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ format : TuneFormat :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . format = TuneFormat :: from_bits (tmp &amp; TuneFormat :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;TuneFormat&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. format . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SUPPORTED_TUNES_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DIGICAM_CONFIGURE_DATA { <span class="kw">pub </span>extra_value : f32 , <span class="kw">pub </span>shutter_speed : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>mode : u8 , <span class="kw">pub </span>aperture : u8 , <span class="kw">pub </span>iso : u8 , <span class="kw">pub </span>exposure_type : u8 , <span class="kw">pub </span>command_id : u8 , <span class="kw">pub </span>engine_cut_off : u8 , <span class="kw">pub </span>extra_param : u8 , } <span class="kw">impl </span>DIGICAM_CONFIGURE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">15usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ extra_value : <span class="number">0.0_f32 </span>, shutter_speed : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, mode : <span class="number">0_u8 </span>, aperture : <span class="number">0_u8 </span>, iso : <span class="number">0_u8 </span>, exposure_type : <span class="number">0_u8 </span>, command_id : <span class="number">0_u8 </span>, engine_cut_off : <span class="number">0_u8 </span>, extra_param : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . extra_value = buf . get_f32_le () ; _struct . shutter_speed = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . mode = buf . get_u8 () ; _struct . aperture = buf . get_u8 () ; _struct . iso = buf . get_u8 () ; _struct . exposure_type = buf . get_u8 () ; _struct . command_id = buf . get_u8 () ; _struct . engine_cut_off = buf . get_u8 () ; _struct . extra_param = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. extra_value) ; _tmp . put_u16_le (<span class="self">self </span>. shutter_speed) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. mode) ; _tmp . put_u8 (<span class="self">self </span>. aperture) ; _tmp . put_u8 (<span class="self">self </span>. iso) ; _tmp . put_u8 (<span class="self">self </span>. exposure_type) ; _tmp . put_u8 (<span class="self">self </span>. command_id) ; _tmp . put_u8 (<span class="self">self </span>. engine_cut_off) ; _tmp . put_u8 (<span class="self">self </span>. extra_param) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DIGICAM_CONFIGURE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LED_CONTROL_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>instance : u8 , <span class="kw">pub </span>pattern : u8 , <span class="kw">pub </span>custom_len : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>custom_bytes : [u8 ; <span class="number">24</span>] , } <span class="kw">impl </span>LED_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">29usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, instance : <span class="number">0_u8 </span>, pattern : <span class="number">0_u8 </span>, custom_len : <span class="number">0_u8 </span>, custom_bytes : [<span class="number">0_u8 </span>; <span class="number">24usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . instance = buf . get_u8 () ; _struct . pattern = buf . get_u8 () ; _struct . custom_len = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . custom_bytes { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. instance) ; _tmp . put_u8 (<span class="self">self </span>. pattern) ; _tmp . put_u8 (<span class="self">self </span>. custom_len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. custom_bytes { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LED_CONTROL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_EXT_REQUEST_READ_DATA { <span class="kw">pub </span>param_index : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , } <span class="kw">impl </span>PARAM_EXT_REQUEST_READ_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ param_index : <span class="number">0_i16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, param_id : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_index = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. param_index) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PARAM_EXT_REQUEST_READ_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AUTH_KEY_DATA { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>key : [u8 ; <span class="number">32</span>] , } <span class="kw">impl </span>AUTH_KEY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ key : [<span class="number">0_u8 </span>; <span class="number">32usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . key { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. key { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>AUTH_KEY_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ONBOARD_COMPUTER_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>uptime : u32 , <span class="kw">pub </span>ram_usage : u32 , <span class="kw">pub </span>ram_total : u32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>storage_type : [u32 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>storage_usage : [u32 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>storage_total : [u32 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>link_type : [u32 ; <span class="number">6</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>link_tx_rate : [u32 ; <span class="number">6</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>link_rx_rate : [u32 ; <span class="number">6</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>link_tx_max : [u32 ; <span class="number">6</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>link_rx_max : [u32 ; <span class="number">6</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>fan_speed : [i16 ; <span class="number">4</span>] , <span class="kw">pub </span>mavtype : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>cpu_cores : [u8 ; <span class="number">8</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>cpu_combined : [u8 ; <span class="number">10</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>gpu_cores : [u8 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>gpu_combined : [u8 ; <span class="number">10</span>] , <span class="kw">pub </span>temperature_board : i8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>temperature_core : [i8 ; <span class="number">8</span>] , } <span class="kw">impl </span>ONBOARD_COMPUTER_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">238usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, uptime : <span class="number">0_u32 </span>, ram_usage : <span class="number">0_u32 </span>, ram_total : <span class="number">0_u32 </span>, storage_type : [<span class="number">0_u32 </span>; <span class="number">4usize</span>] , storage_usage : [<span class="number">0_u32 </span>; <span class="number">4usize</span>] , storage_total : [<span class="number">0_u32 </span>; <span class="number">4usize</span>] , link_type : [<span class="number">0_u32 </span>; <span class="number">6usize</span>] , link_tx_rate : [<span class="number">0_u32 </span>; <span class="number">6usize</span>] , link_rx_rate : [<span class="number">0_u32 </span>; <span class="number">6usize</span>] , link_tx_max : [<span class="number">0_u32 </span>; <span class="number">6usize</span>] , link_rx_max : [<span class="number">0_u32 </span>; <span class="number">6usize</span>] , fan_speed : [<span class="number">0_i16 </span>; <span class="number">4usize</span>] , mavtype : <span class="number">0_u8 </span>, cpu_cores : [<span class="number">0_u8 </span>; <span class="number">8usize</span>] , cpu_combined : [<span class="number">0_u8 </span>; <span class="number">10usize</span>] , gpu_cores : [<span class="number">0_u8 </span>; <span class="number">4usize</span>] , gpu_combined : [<span class="number">0_u8 </span>; <span class="number">10usize</span>] , temperature_board : <span class="number">0_i8 </span>, temperature_core : [<span class="number">0_i8 </span>; <span class="number">8usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . uptime = buf . get_u32_le () ; _struct . ram_usage = buf . get_u32_le () ; _struct . ram_total = buf . get_u32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . storage_type { <span class="kw">let </span>val = buf . get_u32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . storage_usage { <span class="kw">let </span>val = buf . get_u32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . storage_total { <span class="kw">let </span>val = buf . get_u32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . link_type { <span class="kw">let </span>val = buf . get_u32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . link_tx_rate { <span class="kw">let </span>val = buf . get_u32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . link_rx_rate { <span class="kw">let </span>val = buf . get_u32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . link_tx_max { <span class="kw">let </span>val = buf . get_u32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . link_rx_max { <span class="kw">let </span>val = buf . get_u32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . fan_speed { <span class="kw">let </span>val = buf . get_i16_le () ; * v = val ; } _struct . mavtype = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . cpu_cores { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . cpu_combined { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . gpu_cores { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . gpu_combined { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } _struct . temperature_board = buf . get_i8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . temperature_core { <span class="kw">let </span>val = buf . get_i8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. uptime) ; _tmp . put_u32_le (<span class="self">self </span>. ram_usage) ; _tmp . put_u32_le (<span class="self">self </span>. ram_total) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. storage_type { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. storage_usage { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. storage_total { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. link_type { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. link_tx_rate { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. link_rx_rate { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. link_tx_max { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. link_rx_max { _tmp . put_u32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. fan_speed { _tmp . put_i16_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. mavtype) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. cpu_cores { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. cpu_combined { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. gpu_cores { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. gpu_combined { _tmp . put_u8 (* val) ; } _tmp . put_i8 (<span class="self">self </span>. temperature_board) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. temperature_core { _tmp . put_i8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ONBOARD_COMPUTER_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>WIFI_CONFIG_AP_DATA { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>ssid : [u8 ; <span class="number">32</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>password : [u8 ; <span class="number">64</span>] , } <span class="kw">impl </span>WIFI_CONFIG_AP_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">96usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ ssid : [<span class="number">0_u8 </span>; <span class="number">32usize</span>] , password : [<span class="number">0_u8 </span>; <span class="number">64usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . ssid { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . password { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. ssid { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. password { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>WIFI_CONFIG_AP_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>WHEEL_DISTANCE_DATA { <span class="kw">pub </span>time_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>distance : [f64 ; <span class="number">16</span>] , <span class="kw">pub </span>count : u8 , } <span class="kw">impl </span>WHEEL_DISTANCE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">137usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, distance : [<span class="number">0.0_f64 </span>; <span class="number">16usize</span>] , count : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . distance { <span class="kw">let </span>val = buf . get_f64_le () ; * v = val ; } _struct . count = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. distance { _tmp . put_f64_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. count) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>WHEEL_DISTANCE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>NAMED_VALUE_INT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>value : i32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>name : [u8 ; <span class="number">10</span>] , } <span class="kw">impl </span>NAMED_VALUE_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, value : <span class="number">0_i32 </span>, name : [<span class="number">0_u8 </span>; <span class="number">10usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . value = buf . get_i32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. value) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>NAMED_VALUE_INT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PLAY_TUNE_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>tune : [u8 ; <span class="number">30</span>] , } <span class="kw">impl </span>PLAY_TUNE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, tune : [<span class="number">0_u8 </span>; <span class="number">30usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . tune { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. tune { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PLAY_TUNE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_MAP_RC_DATA { <span class="kw">pub </span>param_value0 : f32 , <span class="kw">pub </span>scale : f32 , <span class="kw">pub </span>param_value_min : f32 , <span class="kw">pub </span>param_value_max : f32 , <span class="kw">pub </span>param_index : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>parameter_rc_channel_index : u8 , } <span class="kw">impl </span>PARAM_MAP_RC_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ param_value0 : <span class="number">0.0_f32 </span>, scale : <span class="number">0.0_f32 </span>, param_value_min : <span class="number">0.0_f32 </span>, param_value_max : <span class="number">0.0_f32 </span>, param_index : <span class="number">0_i16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, param_id : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , parameter_rc_channel_index : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_value0 = buf . get_f32_le () ; _struct . scale = buf . get_f32_le () ; _struct . param_value_min = buf . get_f32_le () ; _struct . param_value_max = buf . get_f32_le () ; _struct . param_index = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } _struct . parameter_rc_channel_index = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param_value0) ; _tmp . put_f32_le (<span class="self">self </span>. scale) ; _tmp . put_f32_le (<span class="self">self </span>. param_value_min) ; _tmp . put_f32_le (<span class="self">self </span>. param_value_max) ; _tmp . put_i16_le (<span class="self">self </span>. param_index) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. parameter_rc_channel_index) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PARAM_MAP_RC_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_INJECT_DATA_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>len : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">110</span>] , } <span class="kw">impl </span>GPS_INJECT_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">113usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, len : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">110usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GPS_INJECT_DATA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CANFD_FRAME_DATA { <span class="kw">pub </span>id : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>bus : u8 , <span class="kw">pub </span>len : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">64</span>] , } <span class="kw">impl </span>CANFD_FRAME_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">72usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ id : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, bus : <span class="number">0_u8 </span>, len : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">64usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . id = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . bus = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. bus) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CANFD_FRAME_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ADAP_TUNING_DATA { <span class="kw">pub </span>desired : f32 , <span class="kw">pub </span>achieved : f32 , <span class="kw">pub </span>error : f32 , <span class="kw">pub </span>theta : f32 , <span class="kw">pub </span>omega : f32 , <span class="kw">pub </span>sigma : f32 , <span class="kw">pub </span>theta_dot : f32 , <span class="kw">pub </span>omega_dot : f32 , <span class="kw">pub </span>sigma_dot : f32 , <span class="kw">pub </span>f : f32 , <span class="kw">pub </span>f_dot : f32 , <span class="kw">pub </span>u : f32 , <span class="kw">pub </span>axis : PidTuningAxis , } <span class="kw">impl </span>ADAP_TUNING_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">49usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ desired : <span class="number">0.0_f32 </span>, achieved : <span class="number">0.0_f32 </span>, error : <span class="number">0.0_f32 </span>, theta : <span class="number">0.0_f32 </span>, omega : <span class="number">0.0_f32 </span>, sigma : <span class="number">0.0_f32 </span>, theta_dot : <span class="number">0.0_f32 </span>, omega_dot : <span class="number">0.0_f32 </span>, sigma_dot : <span class="number">0.0_f32 </span>, f : <span class="number">0.0_f32 </span>, f_dot : <span class="number">0.0_f32 </span>, u : <span class="number">0.0_f32 </span>, axis : PidTuningAxis :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . desired = buf . get_f32_le () ; _struct . achieved = buf . get_f32_le () ; _struct . error = buf . get_f32_le () ; _struct . theta = buf . get_f32_le () ; _struct . omega = buf . get_f32_le () ; _struct . sigma = buf . get_f32_le () ; _struct . theta_dot = buf . get_f32_le () ; _struct . omega_dot = buf . get_f32_le () ; _struct . sigma_dot = buf . get_f32_le () ; _struct . f = buf . get_f32_le () ; _struct . f_dot = buf . get_f32_le () ; _struct . u = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . axis = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;PidTuningAxis&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. desired) ; _tmp . put_f32_le (<span class="self">self </span>. achieved) ; _tmp . put_f32_le (<span class="self">self </span>. error) ; _tmp . put_f32_le (<span class="self">self </span>. theta) ; _tmp . put_f32_le (<span class="self">self </span>. omega) ; _tmp . put_f32_le (<span class="self">self </span>. sigma) ; _tmp . put_f32_le (<span class="self">self </span>. theta_dot) ; _tmp . put_f32_le (<span class="self">self </span>. omega_dot) ; _tmp . put_f32_le (<span class="self">self </span>. sigma_dot) ; _tmp . put_f32_le (<span class="self">self </span>. f) ; _tmp . put_f32_le (<span class="self">self </span>. f_dot) ; _tmp . put_f32_le (<span class="self">self </span>. u) ; _tmp . put_u8 (<span class="self">self </span>. axis <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ADAP_TUNING_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_REQUEST_DATA_DATA { <span class="kw">pub </span>ofs : u32 , <span class="kw">pub </span>count : u32 , <span class="kw">pub </span>id : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>LOG_REQUEST_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">12usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ ofs : <span class="number">0_u32 </span>, count : <span class="number">0_u32 </span>, id : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . ofs = buf . get_u32_le () ; _struct . count = buf . get_u32_le () ; _struct . id = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. ofs) ; _tmp . put_u32_le (<span class="self">self </span>. count) ; _tmp . put_u16_le (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOG_REQUEST_DATA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_EXT_ACK_DATA { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_value : [u8 ; <span class="number">128</span>] , <span class="kw">pub </span>param_type : MavParamExtType , <span class="kw">pub </span>param_result : ParamAck , } <span class="kw">impl </span>PARAM_EXT_ACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">146usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ param_id : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , param_value : [<span class="number">0_u8 </span>; <span class="number">128usize</span>] , param_type : MavParamExtType :: DEFAULT , param_result : ParamAck :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_value { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavParamExtType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_result = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;ParamAck&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_value { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. param_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. param_result <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PARAM_EXT_ACK_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VIBRATION_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>vibration_x : f32 , <span class="kw">pub </span>vibration_y : f32 , <span class="kw">pub </span>vibration_z : f32 , <span class="kw">pub </span>clipping_0 : u32 , <span class="kw">pub </span>clipping_1 : u32 , <span class="kw">pub </span>clipping_2 : u32 , } <span class="kw">impl </span>VIBRATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, vibration_x : <span class="number">0.0_f32 </span>, vibration_y : <span class="number">0.0_f32 </span>, vibration_z : <span class="number">0.0_f32 </span>, clipping_0 : <span class="number">0_u32 </span>, clipping_1 : <span class="number">0_u32 </span>, clipping_2 : <span class="number">0_u32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . vibration_x = buf . get_f32_le () ; _struct . vibration_y = buf . get_f32_le () ; _struct . vibration_z = buf . get_f32_le () ; _struct . clipping_0 = buf . get_u32_le () ; _struct . clipping_1 = buf . get_u32_le () ; _struct . clipping_2 = buf . get_u32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. vibration_x) ; _tmp . put_f32_le (<span class="self">self </span>. vibration_y) ; _tmp . put_f32_le (<span class="self">self </span>. vibration_z) ; _tmp . put_u32_le (<span class="self">self </span>. clipping_0) ; _tmp . put_u32_le (<span class="self">self </span>. clipping_1) ; _tmp . put_u32_le (<span class="self">self </span>. clipping_2) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>VIBRATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EKF_STATUS_REPORT_DATA { <span class="kw">pub </span>velocity_variance : f32 , <span class="kw">pub </span>pos_horiz_variance : f32 , <span class="kw">pub </span>pos_vert_variance : f32 , <span class="kw">pub </span>compass_variance : f32 , <span class="kw">pub </span>terrain_alt_variance : f32 , <span class="kw">pub </span>flags : EkfStatusFlags , } <span class="kw">impl </span>EKF_STATUS_REPORT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ velocity_variance : <span class="number">0.0_f32 </span>, pos_horiz_variance : <span class="number">0.0_f32 </span>, pos_vert_variance : <span class="number">0.0_f32 </span>, compass_variance : <span class="number">0.0_f32 </span>, terrain_alt_variance : <span class="number">0.0_f32 </span>, flags : EkfStatusFlags :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . velocity_variance = buf . get_f32_le () ; _struct . pos_horiz_variance = buf . get_f32_le () ; _struct . pos_vert_variance = buf . get_f32_le () ; _struct . compass_variance = buf . get_f32_le () ; _struct . terrain_alt_variance = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = EkfStatusFlags :: from_bits (tmp &amp; EkfStatusFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;EkfStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. velocity_variance) ; _tmp . put_f32_le (<span class="self">self </span>. pos_horiz_variance) ; _tmp . put_f32_le (<span class="self">self </span>. pos_vert_variance) ; _tmp . put_f32_le (<span class="self">self </span>. compass_variance) ; _tmp . put_f32_le (<span class="self">self </span>. terrain_alt_variance) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>EKF_STATUS_REPORT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>STORAGE_INFORMATION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>total_capacity : f32 , <span class="kw">pub </span>used_capacity : f32 , <span class="kw">pub </span>available_capacity : f32 , <span class="kw">pub </span>read_speed : f32 , <span class="kw">pub </span>write_speed : f32 , <span class="kw">pub </span>storage_id : u8 , <span class="kw">pub </span>storage_count : u8 , <span class="kw">pub </span>status : StorageStatus , } <span class="kw">impl </span>STORAGE_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">27usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, total_capacity : <span class="number">0.0_f32 </span>, used_capacity : <span class="number">0.0_f32 </span>, available_capacity : <span class="number">0.0_f32 </span>, read_speed : <span class="number">0.0_f32 </span>, write_speed : <span class="number">0.0_f32 </span>, storage_id : <span class="number">0_u8 </span>, storage_count : <span class="number">0_u8 </span>, status : StorageStatus :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . total_capacity = buf . get_f32_le () ; _struct . used_capacity = buf . get_f32_le () ; _struct . available_capacity = buf . get_f32_le () ; _struct . read_speed = buf . get_f32_le () ; _struct . write_speed = buf . get_f32_le () ; _struct . storage_id = buf . get_u8 () ; _struct . storage_count = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;StorageStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. total_capacity) ; _tmp . put_f32_le (<span class="self">self </span>. used_capacity) ; _tmp . put_f32_le (<span class="self">self </span>. available_capacity) ; _tmp . put_f32_le (<span class="self">self </span>. read_speed) ; _tmp . put_f32_le (<span class="self">self </span>. write_speed) ; _tmp . put_u8 (<span class="self">self </span>. storage_id) ; _tmp . put_u8 (<span class="self">self </span>. storage_count) ; _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>STORAGE_INFORMATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DEVICE_OP_READ_DATA { <span class="kw">pub </span>request_id : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>bustype : DeviceOpBustype , <span class="kw">pub </span>bus : u8 , <span class="kw">pub </span>address : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>busname : [u8 ; <span class="number">40</span>] , <span class="kw">pub </span>regstart : u8 , <span class="kw">pub </span>count : u8 , } <span class="kw">impl </span>DEVICE_OP_READ_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">51usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ request_id : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, bustype : DeviceOpBustype :: DEFAULT , bus : <span class="number">0_u8 </span>, address : <span class="number">0_u8 </span>, busname : [<span class="number">0_u8 </span>; <span class="number">40usize</span>] , regstart : <span class="number">0_u8 </span>, count : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . request_id = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . bustype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;DeviceOpBustype&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . bus = buf . get_u8 () ; _struct . address = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . busname { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } _struct . regstart = buf . get_u8 () ; _struct . count = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. request_id) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. bustype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. bus) ; _tmp . put_u8 (<span class="self">self </span>. address) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. busname { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. regstart) ; _tmp . put_u8 (<span class="self">self </span>. count) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DEVICE_OP_READ_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OSD_PARAM_SHOW_CONFIG_DATA { <span class="kw">pub </span>request_id : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>osd_screen : u8 , <span class="kw">pub </span>osd_index : u8 , } <span class="kw">impl </span>OSD_PARAM_SHOW_CONFIG_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">8usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ request_id : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, osd_screen : <span class="number">0_u8 </span>, osd_index : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . request_id = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . osd_screen = buf . get_u8 () ; _struct . osd_index = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. request_id) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. osd_screen) ; _tmp . put_u8 (<span class="self">self </span>. osd_index) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OSD_PARAM_SHOW_CONFIG_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOGGING_DATA_ACKED_DATA { <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>length : u8 , <span class="kw">pub </span>first_message_offset : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">249</span>] , } <span class="kw">impl </span>LOGGING_DATA_ACKED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">255usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ sequence : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, length : <span class="number">0_u8 </span>, first_message_offset : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">249usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . sequence = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . length = buf . get_u8 () ; _struct . first_message_offset = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. length) ; _tmp . put_u8 (<span class="self">self </span>. first_message_offset) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOGGING_DATA_ACKED_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HYGROMETER_SENSOR_DATA { <span class="kw">pub </span>temperature : i16 , <span class="kw">pub </span>humidity : u16 , <span class="kw">pub </span>id : u8 , } <span class="kw">impl </span>HYGROMETER_SENSOR_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">5usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ temperature : <span class="number">0_i16 </span>, humidity : <span class="number">0_u16 </span>, id : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . temperature = buf . get_i16_le () ; _struct . humidity = buf . get_u16_le () ; _struct . id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; _tmp . put_u16_le (<span class="self">self </span>. humidity) ; _tmp . put_u8 (<span class="self">self </span>. id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HYGROMETER_SENSOR_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VFR_HUD_DATA { <span class="kw">pub </span>airspeed : f32 , <span class="kw">pub </span>groundspeed : f32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>climb : f32 , <span class="kw">pub </span>heading : i16 , <span class="kw">pub </span>throttle : u16 , } <span class="kw">impl </span>VFR_HUD_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ airspeed : <span class="number">0.0_f32 </span>, groundspeed : <span class="number">0.0_f32 </span>, alt : <span class="number">0.0_f32 </span>, climb : <span class="number">0.0_f32 </span>, heading : <span class="number">0_i16 </span>, throttle : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . airspeed = buf . get_f32_le () ; _struct . groundspeed = buf . get_f32_le () ; _struct . alt = buf . get_f32_le () ; _struct . climb = buf . get_f32_le () ; _struct . heading = buf . get_i16_le () ; _struct . throttle = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. airspeed) ; _tmp . put_f32_le (<span class="self">self </span>. groundspeed) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. climb) ; _tmp . put_i16_le (<span class="self">self </span>. heading) ; _tmp . put_u16_le (<span class="self">self </span>. throttle) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>VFR_HUD_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UAVIONIX_ADSB_OUT_DYNAMIC_DATA { <span class="kw">pub </span>utcTime : u32 , <span class="kw">pub </span>gpsLat : i32 , <span class="kw">pub </span>gpsLon : i32 , <span class="kw">pub </span>gpsAlt : i32 , <span class="kw">pub </span>baroAltMSL : i32 , <span class="kw">pub </span>accuracyHor : u32 , <span class="kw">pub </span>accuracyVert : u16 , <span class="kw">pub </span>accuracyVel : u16 , <span class="kw">pub </span>velVert : i16 , <span class="kw">pub </span>velNS : i16 , <span class="kw">pub </span>VelEW : i16 , <span class="kw">pub </span>state : UavionixAdsbOutDynamicState , <span class="kw">pub </span>squawk : u16 , <span class="kw">pub </span>gpsFix : UavionixAdsbOutDynamicGpsFix , <span class="kw">pub </span>numSats : u8 , <span class="kw">pub </span>emergencyStatus : UavionixAdsbEmergencyStatus , } <span class="kw">impl </span>UAVIONIX_ADSB_OUT_DYNAMIC_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">41usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ utcTime : <span class="number">0_u32 </span>, gpsLat : <span class="number">0_i32 </span>, gpsLon : <span class="number">0_i32 </span>, gpsAlt : <span class="number">0_i32 </span>, baroAltMSL : <span class="number">0_i32 </span>, accuracyHor : <span class="number">0_u32 </span>, accuracyVert : <span class="number">0_u16 </span>, accuracyVel : <span class="number">0_u16 </span>, velVert : <span class="number">0_i16 </span>, velNS : <span class="number">0_i16 </span>, VelEW : <span class="number">0_i16 </span>, state : UavionixAdsbOutDynamicState :: DEFAULT , squawk : <span class="number">0_u16 </span>, gpsFix : UavionixAdsbOutDynamicGpsFix :: DEFAULT , numSats : <span class="number">0_u8 </span>, emergencyStatus : UavionixAdsbEmergencyStatus :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . utcTime = buf . get_u32_le () ; _struct . gpsLat = buf . get_i32_le () ; _struct . gpsLon = buf . get_i32_le () ; _struct . gpsAlt = buf . get_i32_le () ; _struct . baroAltMSL = buf . get_i32_le () ; _struct . accuracyHor = buf . get_u32_le () ; _struct . accuracyVert = buf . get_u16_le () ; _struct . accuracyVel = buf . get_u16_le () ; _struct . velVert = buf . get_i16_le () ; _struct . velNS = buf . get_i16_le () ; _struct . VelEW = buf . get_i16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . state = UavionixAdsbOutDynamicState :: from_bits (tmp &amp; UavionixAdsbOutDynamicState :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;UavionixAdsbOutDynamicState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . squawk = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . gpsFix = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavionixAdsbOutDynamicGpsFix&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . numSats = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . emergencyStatus = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavionixAdsbEmergencyStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. utcTime) ; _tmp . put_i32_le (<span class="self">self </span>. gpsLat) ; _tmp . put_i32_le (<span class="self">self </span>. gpsLon) ; _tmp . put_i32_le (<span class="self">self </span>. gpsAlt) ; _tmp . put_i32_le (<span class="self">self </span>. baroAltMSL) ; _tmp . put_u32_le (<span class="self">self </span>. accuracyHor) ; _tmp . put_u16_le (<span class="self">self </span>. accuracyVert) ; _tmp . put_u16_le (<span class="self">self </span>. accuracyVel) ; _tmp . put_i16_le (<span class="self">self </span>. velVert) ; _tmp . put_i16_le (<span class="self">self </span>. velNS) ; _tmp . put_i16_le (<span class="self">self </span>. VelEW) ; _tmp . put_u16_le (<span class="self">self </span>. state . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. squawk) ; _tmp . put_u8 (<span class="self">self </span>. gpsFix <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. numSats) ; _tmp . put_u8 (<span class="self">self </span>. emergencyStatus <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>UAVIONIX_ADSB_OUT_DYNAMIC_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOCAL_POSITION_NED_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , } <span class="kw">impl </span>LOCAL_POSITION_NED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, vx : <span class="number">0.0_f32 </span>, vy : <span class="number">0.0_f32 </span>, vz : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOCAL_POSITION_NED_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TERRAIN_REQUEST_DATA { <span class="kw">pub </span>mask : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>grid_spacing : u16 , } <span class="kw">impl </span>TERRAIN_REQUEST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ mask : <span class="number">0_u64 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, grid_spacing : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . mask = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . grid_spacing = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. mask) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_u16_le (<span class="self">self </span>. grid_spacing) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>TERRAIN_REQUEST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_SETTINGS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>mode_id : CameraMode , } <span class="kw">impl </span>CAMERA_SETTINGS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">5usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, mode_id : CameraMode :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mode_id = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u8 (<span class="self">self </span>. mode_id <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAMERA_SETTINGS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>FENCE_POINT_DATA { <span class="kw">pub </span>lat : f32 , <span class="kw">pub </span>lng : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>idx : u8 , <span class="kw">pub </span>count : u8 , } <span class="kw">impl </span>FENCE_POINT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">12usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ lat : <span class="number">0.0_f32 </span>, lng : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, idx : <span class="number">0_u8 </span>, count : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . lat = buf . get_f32_le () ; _struct . lng = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . idx = buf . get_u8 () ; _struct . count = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. lat) ; _tmp . put_f32_le (<span class="self">self </span>. lng) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. idx) ; _tmp . put_u8 (<span class="self">self </span>. count) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>FENCE_POINT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPTICAL_FLOW_RAD_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>integration_time_us : u32 , <span class="kw">pub </span>integrated_x : f32 , <span class="kw">pub </span>integrated_y : f32 , <span class="kw">pub </span>integrated_xgyro : f32 , <span class="kw">pub </span>integrated_ygyro : f32 , <span class="kw">pub </span>integrated_zgyro : f32 , <span class="kw">pub </span>time_delta_distance_us : u32 , <span class="kw">pub </span>distance : f32 , <span class="kw">pub </span>temperature : i16 , <span class="kw">pub </span>sensor_id : u8 , <span class="kw">pub </span>quality : u8 , } <span class="kw">impl </span>OPTICAL_FLOW_RAD_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, integration_time_us : <span class="number">0_u32 </span>, integrated_x : <span class="number">0.0_f32 </span>, integrated_y : <span class="number">0.0_f32 </span>, integrated_xgyro : <span class="number">0.0_f32 </span>, integrated_ygyro : <span class="number">0.0_f32 </span>, integrated_zgyro : <span class="number">0.0_f32 </span>, time_delta_distance_us : <span class="number">0_u32 </span>, distance : <span class="number">0.0_f32 </span>, temperature : <span class="number">0_i16 </span>, sensor_id : <span class="number">0_u8 </span>, quality : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . integration_time_us = buf . get_u32_le () ; _struct . integrated_x = buf . get_f32_le () ; _struct . integrated_y = buf . get_f32_le () ; _struct . integrated_xgyro = buf . get_f32_le () ; _struct . integrated_ygyro = buf . get_f32_le () ; _struct . integrated_zgyro = buf . get_f32_le () ; _struct . time_delta_distance_us = buf . get_u32_le () ; _struct . distance = buf . get_f32_le () ; _struct . temperature = buf . get_i16_le () ; _struct . sensor_id = buf . get_u8 () ; _struct . quality = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. integration_time_us) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_x) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_y) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_xgyro) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_ygyro) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_zgyro) ; _tmp . put_u32_le (<span class="self">self </span>. time_delta_distance_us) ; _tmp . put_f32_le (<span class="self">self </span>. distance) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; _tmp . put_u8 (<span class="self">self </span>. sensor_id) ; _tmp . put_u8 (<span class="self">self </span>. quality) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OPTICAL_FLOW_RAD_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_STATE_QUATERNION_DATA { <span class="kw">pub </span>time_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>attitude_quaternion : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>vx : i16 , <span class="kw">pub </span>vy : i16 , <span class="kw">pub </span>vz : i16 , <span class="kw">pub </span>ind_airspeed : u16 , <span class="kw">pub </span>true_airspeed : u16 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , } <span class="kw">impl </span>HIL_STATE_QUATERNION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">64usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, attitude_quaternion : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , rollspeed : <span class="number">0.0_f32 </span>, pitchspeed : <span class="number">0.0_f32 </span>, yawspeed : <span class="number">0.0_f32 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0_i32 </span>, vx : <span class="number">0_i16 </span>, vy : <span class="number">0_i16 </span>, vz : <span class="number">0_i16 </span>, ind_airspeed : <span class="number">0_u16 </span>, true_airspeed : <span class="number">0_u16 </span>, xacc : <span class="number">0_i16 </span>, yacc : <span class="number">0_i16 </span>, zacc : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . attitude_quaternion { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . vx = buf . get_i16_le () ; _struct . vy = buf . get_i16_le () ; _struct . vz = buf . get_i16_le () ; _struct . ind_airspeed = buf . get_u16_le () ; _struct . true_airspeed = buf . get_u16_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. attitude_quaternion { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i16_le (<span class="self">self </span>. vx) ; _tmp . put_i16_le (<span class="self">self </span>. vy) ; _tmp . put_i16_le (<span class="self">self </span>. vz) ; _tmp . put_u16_le (<span class="self">self </span>. ind_airspeed) ; _tmp . put_u16_le (<span class="self">self </span>. true_airspeed) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HIL_STATE_QUATERNION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_PRESSURE2_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>press_abs : f32 , <span class="kw">pub </span>press_diff : f32 , <span class="kw">pub </span>temperature : i16 , } <span class="kw">impl </span>SCALED_PRESSURE2_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, press_abs : <span class="number">0.0_f32 </span>, press_diff : <span class="number">0.0_f32 </span>, temperature : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . press_abs = buf . get_f32_le () ; _struct . press_diff = buf . get_f32_le () ; _struct . temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. press_abs) ; _tmp . put_f32_le (<span class="self">self </span>. press_diff) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SCALED_PRESSURE2_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CHANGE_OPERATOR_CONTROL_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>control_request : u8 , <span class="kw">pub </span>version : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>passkey : [u8 ; <span class="number">25</span>] , } <span class="kw">impl </span>CHANGE_OPERATOR_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, control_request : <span class="number">0_u8 </span>, version : <span class="number">0_u8 </span>, passkey : [<span class="number">0_u8 </span>; <span class="number">25usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . control_request = buf . get_u8 () ; _struct . version = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . passkey { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. control_request) ; _tmp . put_u8 (<span class="self">self </span>. version) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. passkey { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CHANGE_OPERATOR_CONTROL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMPASSMOT_STATUS_DATA { <span class="kw">pub </span>current : f32 , <span class="kw">pub </span>CompensationX : f32 , <span class="kw">pub </span>CompensationY : f32 , <span class="kw">pub </span>CompensationZ : f32 , <span class="kw">pub </span>throttle : u16 , <span class="kw">pub </span>interference : u16 , } <span class="kw">impl </span>COMPASSMOT_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ current : <span class="number">0.0_f32 </span>, CompensationX : <span class="number">0.0_f32 </span>, CompensationY : <span class="number">0.0_f32 </span>, CompensationZ : <span class="number">0.0_f32 </span>, throttle : <span class="number">0_u16 </span>, interference : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . current = buf . get_f32_le () ; _struct . CompensationX = buf . get_f32_le () ; _struct . CompensationY = buf . get_f32_le () ; _struct . CompensationZ = buf . get_f32_le () ; _struct . throttle = buf . get_u16_le () ; _struct . interference = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. current) ; _tmp . put_f32_le (<span class="self">self </span>. CompensationX) ; _tmp . put_f32_le (<span class="self">self </span>. CompensationY) ; _tmp . put_f32_le (<span class="self">self </span>. CompensationZ) ; _tmp . put_u16_le (<span class="self">self </span>. throttle) ; _tmp . put_u16_le (<span class="self">self </span>. interference) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>COMPASSMOT_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_ARM_STATUS_DATA { <span class="kw">pub </span>status : MavOdidArmStatus , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>error : [u8 ; <span class="number">50</span>] , } <span class="kw">impl </span>OPEN_DRONE_ID_ARM_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">51usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ status : MavOdidArmStatus :: DEFAULT , error : [<span class="number">0_u8 </span>; <span class="number">50usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidArmStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . error { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. error { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OPEN_DRONE_ID_ARM_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOGGING_ACK_DATA { <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>LOGGING_ACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ sequence : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . sequence = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOGGING_ACK_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_MANAGER_SET_ATTITUDE_DATA { <span class="kw">pub </span>flags : GimbalManagerFlags , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>angular_velocity_x : f32 , <span class="kw">pub </span>angular_velocity_y : f32 , <span class="kw">pub </span>angular_velocity_z : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>gimbal_device_id : u8 , } <span class="kw">impl </span>GIMBAL_MANAGER_SET_ATTITUDE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">35usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ flags : GimbalManagerFlags :: DEFAULT , q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , angular_velocity_x : <span class="number">0.0_f32 </span>, angular_velocity_y : <span class="number">0.0_f32 </span>, angular_velocity_z : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, gimbal_device_id : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . flags = FromPrimitive :: from_u32 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GimbalManagerFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . angular_velocity_x = buf . get_f32_le () ; _struct . angular_velocity_y = buf . get_f32_le () ; _struct . angular_velocity_z = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . gimbal_device_id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. flags <span class="kw">as </span>u32) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_x) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_y) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_z) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. gimbal_device_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GIMBAL_MANAGER_SET_ATTITUDE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TIME_ESTIMATE_TO_TARGET_DATA { <span class="kw">pub </span>safe_return : i32 , <span class="kw">pub </span>land : i32 , <span class="kw">pub </span>mission_next_item : i32 , <span class="kw">pub </span>mission_end : i32 , <span class="kw">pub </span>commanded_action : i32 , } <span class="kw">impl </span>TIME_ESTIMATE_TO_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ safe_return : <span class="number">0_i32 </span>, land : <span class="number">0_i32 </span>, mission_next_item : <span class="number">0_i32 </span>, mission_end : <span class="number">0_i32 </span>, commanded_action : <span class="number">0_i32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . safe_return = buf . get_i32_le () ; _struct . land = buf . get_i32_le () ; _struct . mission_next_item = buf . get_i32_le () ; _struct . mission_end = buf . get_i32_le () ; _struct . commanded_action = buf . get_i32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. safe_return) ; _tmp . put_i32_le (<span class="self">self </span>. land) ; _tmp . put_i32_le (<span class="self">self </span>. mission_next_item) ; _tmp . put_i32_le (<span class="self">self </span>. mission_end) ; _tmp . put_i32_le (<span class="self">self </span>. commanded_action) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>TIME_ESTIMATE_TO_TARGET_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_MODE_DATA { <span class="kw">pub </span>custom_mode : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>base_mode : MavMode , } <span class="kw">impl </span>SET_MODE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ custom_mode : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, base_mode : MavMode :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . custom_mode = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . base_mode = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. custom_mode) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. base_mode <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SET_MODE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RALLY_FETCH_POINT_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>idx : u8 , } <span class="kw">impl </span>RALLY_FETCH_POINT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, idx : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . idx = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. idx) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RALLY_FETCH_POINT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMMAND_CANCEL_DATA { <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>COMMAND_CANCEL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ command : MavCmd :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>COMMAND_CANCEL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>REQUEST_DATA_STREAM_DATA { <span class="kw">pub </span>req_message_rate : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>req_stream_id : u8 , <span class="kw">pub </span>start_stop : u8 , } <span class="kw">impl </span>REQUEST_DATA_STREAM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ req_message_rate : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, req_stream_id : <span class="number">0_u8 </span>, start_stop : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . req_message_rate = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . req_stream_id = buf . get_u8 () ; _struct . start_stop = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. req_message_rate) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. req_stream_id) ; _tmp . put_u8 (<span class="self">self </span>. start_stop) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>REQUEST_DATA_STREAM_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_REQUEST_LIST_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>PARAM_REQUEST_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PARAM_REQUEST_LIST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VISION_POSITION_ESTIMATE_DATA { <span class="kw">pub </span>usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , } <span class="kw">impl </span>VISION_POSITION_ESTIMATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ usec : <span class="number">0_u64 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>VISION_POSITION_ESTIMATE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_IMAGE_CAPTURED_DATA { <span class="kw">pub </span>time_utc : u64 , <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>relative_alt : i32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>image_index : i32 , <span class="kw">pub </span>camera_id : u8 , <span class="kw">pub </span>capture_result : i8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>file_url : [u8 ; <span class="number">205</span>] , } <span class="kw">impl </span>CAMERA_IMAGE_CAPTURED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">255usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_utc : <span class="number">0_u64 </span>, time_boot_ms : <span class="number">0_u32 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0_i32 </span>, relative_alt : <span class="number">0_i32 </span>, q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , image_index : <span class="number">0_i32 </span>, camera_id : <span class="number">0_u8 </span>, capture_result : <span class="number">0_i8 </span>, file_url : [<span class="number">0_u8 </span>; <span class="number">205usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_utc = buf . get_u64_le () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . relative_alt = buf . get_i32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . image_index = buf . get_i32_le () ; _struct . camera_id = buf . get_u8 () ; _struct . capture_result = buf . get_i8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . file_url { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_utc) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i32_le (<span class="self">self </span>. relative_alt) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_i32_le (<span class="self">self </span>. image_index) ; _tmp . put_u8 (<span class="self">self </span>. camera_id) ; _tmp . put_i8 (<span class="self">self </span>. capture_result) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. file_url { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAMERA_IMAGE_CAPTURED_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>FOLLOW_TARGET_DATA { <span class="kw">pub </span>timestamp : u64 , <span class="kw">pub </span>custom_state : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : f32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>vel : [f32 ; <span class="number">3</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>acc : [f32 ; <span class="number">3</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>attitude_q : [f32 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>rates : [f32 ; <span class="number">3</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>position_cov : [f32 ; <span class="number">3</span>] , <span class="kw">pub </span>est_capabilities : u8 , } <span class="kw">impl </span>FOLLOW_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">93usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ timestamp : <span class="number">0_u64 </span>, custom_state : <span class="number">0_u64 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0.0_f32 </span>, vel : [<span class="number">0.0_f32 </span>; <span class="number">3usize</span>] , acc : [<span class="number">0.0_f32 </span>; <span class="number">3usize</span>] , attitude_q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , rates : [<span class="number">0.0_f32 </span>; <span class="number">3usize</span>] , position_cov : [<span class="number">0.0_f32 </span>; <span class="number">3usize</span>] , est_capabilities : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . timestamp = buf . get_u64_le () ; _struct . custom_state = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_f32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . vel { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . acc { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . attitude_q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . rates { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . position_cov { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . est_capabilities = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. timestamp) ; _tmp . put_u64_le (<span class="self">self </span>. custom_state) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. acc { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. attitude_q { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. rates { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. position_cov { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. est_capabilities) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>FOLLOW_TARGET_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HEARTBEAT_DATA { <span class="kw">pub </span>custom_mode : u32 , <span class="kw">pub </span>mavtype : MavType , <span class="kw">pub </span>autopilot : MavAutopilot , <span class="kw">pub </span>base_mode : MavModeFlag , <span class="kw">pub </span>system_status : MavState , <span class="kw">pub </span>mavlink_version : u8 , } <span class="kw">impl </span>HEARTBEAT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">9usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ custom_mode : <span class="number">0_u32 </span>, mavtype : MavType :: DEFAULT , autopilot : MavAutopilot :: DEFAULT , base_mode : MavModeFlag :: DEFAULT , system_status : MavState :: DEFAULT , mavlink_version : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . custom_mode = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . autopilot = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavAutopilot&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . base_mode = MavModeFlag :: from_bits (tmp &amp; MavModeFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavModeFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . system_status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . mavlink_version = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. custom_mode) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. autopilot <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. base_mode . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. system_status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mavlink_version) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HEARTBEAT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DATA64_DATA { <span class="kw">pub </span>mavtype : u8 , <span class="kw">pub </span>len : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">64</span>] , } <span class="kw">impl </span>DATA64_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">66usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ mavtype : <span class="number">0_u8 </span>, len : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">64usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . mavtype = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. mavtype) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DATA64_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HERELINK_VIDEO_STREAM_INFORMATION_DATA { <span class="kw">pub </span>framerate : f32 , <span class="kw">pub </span>bitrate : u32 , <span class="kw">pub </span>resolution_h : u16 , <span class="kw">pub </span>resolution_v : u16 , <span class="kw">pub </span>rotation : u16 , <span class="kw">pub </span>camera_id : u8 , <span class="kw">pub </span>status : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>uri : [u8 ; <span class="number">230</span>] , } <span class="kw">impl </span>HERELINK_VIDEO_STREAM_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">246usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ framerate : <span class="number">0.0_f32 </span>, bitrate : <span class="number">0_u32 </span>, resolution_h : <span class="number">0_u16 </span>, resolution_v : <span class="number">0_u16 </span>, rotation : <span class="number">0_u16 </span>, camera_id : <span class="number">0_u8 </span>, status : <span class="number">0_u8 </span>, uri : [<span class="number">0_u8 </span>; <span class="number">230usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . framerate = buf . get_f32_le () ; _struct . bitrate = buf . get_u32_le () ; _struct . resolution_h = buf . get_u16_le () ; _struct . resolution_v = buf . get_u16_le () ; _struct . rotation = buf . get_u16_le () ; _struct . camera_id = buf . get_u8 () ; _struct . status = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . uri { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. framerate) ; _tmp . put_u32_le (<span class="self">self </span>. bitrate) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_h) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_v) ; _tmp . put_u16_le (<span class="self">self </span>. rotation) ; _tmp . put_u8 (<span class="self">self </span>. camera_id) ; _tmp . put_u8 (<span class="self">self </span>. status) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. uri { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HERELINK_VIDEO_STREAM_INFORMATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GOPRO_HEARTBEAT_DATA { <span class="kw">pub </span>status : GoproHeartbeatStatus , <span class="kw">pub </span>capture_mode : GoproCaptureMode , <span class="kw">pub </span>flags : GoproHeartbeatFlags , } <span class="kw">impl </span>GOPRO_HEARTBEAT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ status : GoproHeartbeatStatus :: DEFAULT , capture_mode : GoproCaptureMode :: DEFAULT , flags : GoproHeartbeatFlags :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GoproHeartbeatStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . capture_mode = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GoproCaptureMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . flags = GoproHeartbeatFlags :: from_bits (tmp &amp; GoproHeartbeatFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GoproHeartbeatFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. capture_mode <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. flags . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GOPRO_HEARTBEAT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RC_CHANNELS_SCALED_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>chan1_scaled : i16 , <span class="kw">pub </span>chan2_scaled : i16 , <span class="kw">pub </span>chan3_scaled : i16 , <span class="kw">pub </span>chan4_scaled : i16 , <span class="kw">pub </span>chan5_scaled : i16 , <span class="kw">pub </span>chan6_scaled : i16 , <span class="kw">pub </span>chan7_scaled : i16 , <span class="kw">pub </span>chan8_scaled : i16 , <span class="kw">pub </span>port : u8 , <span class="kw">pub </span>rssi : u8 , } <span class="kw">impl </span>RC_CHANNELS_SCALED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, chan1_scaled : <span class="number">0_i16 </span>, chan2_scaled : <span class="number">0_i16 </span>, chan3_scaled : <span class="number">0_i16 </span>, chan4_scaled : <span class="number">0_i16 </span>, chan5_scaled : <span class="number">0_i16 </span>, chan6_scaled : <span class="number">0_i16 </span>, chan7_scaled : <span class="number">0_i16 </span>, chan8_scaled : <span class="number">0_i16 </span>, port : <span class="number">0_u8 </span>, rssi : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . chan1_scaled = buf . get_i16_le () ; _struct . chan2_scaled = buf . get_i16_le () ; _struct . chan3_scaled = buf . get_i16_le () ; _struct . chan4_scaled = buf . get_i16_le () ; _struct . chan5_scaled = buf . get_i16_le () ; _struct . chan6_scaled = buf . get_i16_le () ; _struct . chan7_scaled = buf . get_i16_le () ; _struct . chan8_scaled = buf . get_i16_le () ; _struct . port = buf . get_u8 () ; _struct . rssi = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i16_le (<span class="self">self </span>. chan1_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan2_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan3_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan4_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan5_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan6_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan7_scaled) ; _tmp . put_i16_le (<span class="self">self </span>. chan8_scaled) ; _tmp . put_u8 (<span class="self">self </span>. port) ; _tmp . put_u8 (<span class="self">self </span>. rssi) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RC_CHANNELS_SCALED_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_REQUEST_INT_DATA { <span class="kw">pub </span>seq : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_REQUEST_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ seq : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seq = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_REQUEST_INT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAN_FRAME_DATA { <span class="kw">pub </span>id : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>bus : u8 , <span class="kw">pub </span>len : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">8</span>] , } <span class="kw">impl </span>CAN_FRAME_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">16usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ id : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, bus : <span class="number">0_u8 </span>, len : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">8usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . id = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . bus = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. bus) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAN_FRAME_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_GPS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>eph : u16 , <span class="kw">pub </span>epv : u16 , <span class="kw">pub </span>vel : u16 , <span class="kw">pub </span>vn : i16 , <span class="kw">pub </span>ve : i16 , <span class="kw">pub </span>vd : i16 , <span class="kw">pub </span>cog : u16 , <span class="kw">pub </span>fix_type : u8 , <span class="kw">pub </span>satellites_visible : u8 , } <span class="kw">impl </span>HIL_GPS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">36usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0_i32 </span>, eph : <span class="number">0_u16 </span>, epv : <span class="number">0_u16 </span>, vel : <span class="number">0_u16 </span>, vn : <span class="number">0_i16 </span>, ve : <span class="number">0_i16 </span>, vd : <span class="number">0_i16 </span>, cog : <span class="number">0_u16 </span>, fix_type : <span class="number">0_u8 </span>, satellites_visible : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . eph = buf . get_u16_le () ; _struct . epv = buf . get_u16_le () ; _struct . vel = buf . get_u16_le () ; _struct . vn = buf . get_i16_le () ; _struct . ve = buf . get_i16_le () ; _struct . vd = buf . get_i16_le () ; _struct . cog = buf . get_u16_le () ; _struct . fix_type = buf . get_u8 () ; _struct . satellites_visible = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_u16_le (<span class="self">self </span>. eph) ; _tmp . put_u16_le (<span class="self">self </span>. epv) ; _tmp . put_u16_le (<span class="self">self </span>. vel) ; _tmp . put_i16_le (<span class="self">self </span>. vn) ; _tmp . put_i16_le (<span class="self">self </span>. ve) ; _tmp . put_i16_le (<span class="self">self </span>. vd) ; _tmp . put_u16_le (<span class="self">self </span>. cog) ; _tmp . put_u8 (<span class="self">self </span>. fix_type) ; _tmp . put_u8 (<span class="self">self </span>. satellites_visible) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HIL_GPS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GENERATOR_STATUS_DATA { <span class="kw">pub </span>status : MavGeneratorStatusFlag , <span class="kw">pub </span>battery_current : f32 , <span class="kw">pub </span>load_current : f32 , <span class="kw">pub </span>power_generated : f32 , <span class="kw">pub </span>bus_voltage : f32 , <span class="kw">pub </span>bat_current_setpoint : f32 , <span class="kw">pub </span>runtime : u32 , <span class="kw">pub </span>time_until_maintenance : i32 , <span class="kw">pub </span>generator_speed : u16 , <span class="kw">pub </span>rectifier_temperature : i16 , <span class="kw">pub </span>generator_temperature : i16 , } <span class="kw">impl </span>GENERATOR_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ status : MavGeneratorStatusFlag :: DEFAULT , battery_current : <span class="number">0.0_f32 </span>, load_current : <span class="number">0.0_f32 </span>, power_generated : <span class="number">0.0_f32 </span>, bus_voltage : <span class="number">0.0_f32 </span>, bat_current_setpoint : <span class="number">0.0_f32 </span>, runtime : <span class="number">0_u32 </span>, time_until_maintenance : <span class="number">0_i32 </span>, generator_speed : <span class="number">0_u16 </span>, rectifier_temperature : <span class="number">0_i16 </span>, generator_temperature : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u64_le () ; _struct . status = MavGeneratorStatusFlag :: from_bits (tmp &amp; MavGeneratorStatusFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavGeneratorStatusFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . battery_current = buf . get_f32_le () ; _struct . load_current = buf . get_f32_le () ; _struct . power_generated = buf . get_f32_le () ; _struct . bus_voltage = buf . get_f32_le () ; _struct . bat_current_setpoint = buf . get_f32_le () ; _struct . runtime = buf . get_u32_le () ; _struct . time_until_maintenance = buf . get_i32_le () ; _struct . generator_speed = buf . get_u16_le () ; _struct . rectifier_temperature = buf . get_i16_le () ; _struct . generator_temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. status . bits ()) ; _tmp . put_f32_le (<span class="self">self </span>. battery_current) ; _tmp . put_f32_le (<span class="self">self </span>. load_current) ; _tmp . put_f32_le (<span class="self">self </span>. power_generated) ; _tmp . put_f32_le (<span class="self">self </span>. bus_voltage) ; _tmp . put_f32_le (<span class="self">self </span>. bat_current_setpoint) ; _tmp . put_u32_le (<span class="self">self </span>. runtime) ; _tmp . put_i32_le (<span class="self">self </span>. time_until_maintenance) ; _tmp . put_u16_le (<span class="self">self </span>. generator_speed) ; _tmp . put_i16_le (<span class="self">self </span>. rectifier_temperature) ; _tmp . put_i16_le (<span class="self">self </span>. generator_temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GENERATOR_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_MANAGER_INFORMATION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>cap_flags : GimbalManagerCapFlags , <span class="kw">pub </span>roll_min : f32 , <span class="kw">pub </span>roll_max : f32 , <span class="kw">pub </span>pitch_min : f32 , <span class="kw">pub </span>pitch_max : f32 , <span class="kw">pub </span>yaw_min : f32 , <span class="kw">pub </span>yaw_max : f32 , <span class="kw">pub </span>gimbal_device_id : u8 , } <span class="kw">impl </span>GIMBAL_MANAGER_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">33usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, cap_flags : GimbalManagerCapFlags :: DEFAULT , roll_min : <span class="number">0.0_f32 </span>, roll_max : <span class="number">0.0_f32 </span>, pitch_min : <span class="number">0.0_f32 </span>, pitch_max : <span class="number">0.0_f32 </span>, yaw_min : <span class="number">0.0_f32 </span>, yaw_max : <span class="number">0.0_f32 </span>, gimbal_device_id : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . cap_flags = GimbalManagerCapFlags :: from_bits (tmp &amp; GimbalManagerCapFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GimbalManagerCapFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . roll_min = buf . get_f32_le () ; _struct . roll_max = buf . get_f32_le () ; _struct . pitch_min = buf . get_f32_le () ; _struct . pitch_max = buf . get_f32_le () ; _struct . yaw_min = buf . get_f32_le () ; _struct . yaw_max = buf . get_f32_le () ; _struct . gimbal_device_id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. cap_flags . bits ()) ; _tmp . put_f32_le (<span class="self">self </span>. roll_min) ; _tmp . put_f32_le (<span class="self">self </span>. roll_max) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_min) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_max) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_min) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_max) ; _tmp . put_u8 (<span class="self">self </span>. gimbal_device_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GIMBAL_MANAGER_INFORMATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TERRAIN_CHECK_DATA { <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , } <span class="kw">impl </span>TERRAIN_CHECK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">8usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>TERRAIN_CHECK_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>BATTERY2_DATA { <span class="kw">pub </span>voltage : u16 , <span class="kw">pub </span>current_battery : i16 , } <span class="kw">impl </span>BATTERY2_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ voltage : <span class="number">0_u16 </span>, current_battery : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . voltage = buf . get_u16_le () ; _struct . current_battery = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. voltage) ; _tmp . put_i16_le (<span class="self">self </span>. current_battery) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>BATTERY2_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_FOV_STATUS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>lat_camera : i32 , <span class="kw">pub </span>lon_camera : i32 , <span class="kw">pub </span>alt_camera : i32 , <span class="kw">pub </span>lat_image : i32 , <span class="kw">pub </span>lon_image : i32 , <span class="kw">pub </span>alt_image : i32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>hfov : f32 , <span class="kw">pub </span>vfov : f32 , } <span class="kw">impl </span>CAMERA_FOV_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">52usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, lat_camera : <span class="number">0_i32 </span>, lon_camera : <span class="number">0_i32 </span>, alt_camera : <span class="number">0_i32 </span>, lat_image : <span class="number">0_i32 </span>, lon_image : <span class="number">0_i32 </span>, alt_image : <span class="number">0_i32 </span>, q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , hfov : <span class="number">0.0_f32 </span>, vfov : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . lat_camera = buf . get_i32_le () ; _struct . lon_camera = buf . get_i32_le () ; _struct . alt_camera = buf . get_i32_le () ; _struct . lat_image = buf . get_i32_le () ; _struct . lon_image = buf . get_i32_le () ; _struct . alt_image = buf . get_i32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . hfov = buf . get_f32_le () ; _struct . vfov = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat_camera) ; _tmp . put_i32_le (<span class="self">self </span>. lon_camera) ; _tmp . put_i32_le (<span class="self">self </span>. alt_camera) ; _tmp . put_i32_le (<span class="self">self </span>. lat_image) ; _tmp . put_i32_le (<span class="self">self </span>. lon_image) ; _tmp . put_i32_le (<span class="self">self </span>. alt_image) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. hfov) ; _tmp . put_f32_le (<span class="self">self </span>. vfov) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAMERA_FOV_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_REQUEST_READ_DATA { <span class="kw">pub </span>param_index : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , } <span class="kw">impl </span>PARAM_REQUEST_READ_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ param_index : <span class="number">0_i16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, param_id : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_index = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. param_index) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PARAM_REQUEST_READ_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_WRITE_PARTIAL_LIST_DATA { <span class="kw">pub </span>start_index : i16 , <span class="kw">pub </span>end_index : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_WRITE_PARTIAL_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ start_index : <span class="number">0_i16 </span>, end_index : <span class="number">0_i16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . start_index = buf . get_i16_le () ; _struct . end_index = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. start_index) ; _tmp . put_i16_le (<span class="self">self </span>. end_index) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_WRITE_PARTIAL_LIST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UAVIONIX_ADSB_OUT_CFG_DATA { <span class="kw">pub </span>ICAO : u32 , <span class="kw">pub </span>stallSpeed : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>callsign : [u8 ; <span class="number">9</span>] , <span class="kw">pub </span>emitterType : AdsbEmitterType , <span class="kw">pub </span>aircraftSize : UavionixAdsbOutCfgAircraftSize , <span class="kw">pub </span>gpsOffsetLat : UavionixAdsbOutCfgGpsOffsetLat , <span class="kw">pub </span>gpsOffsetLon : UavionixAdsbOutCfgGpsOffsetLon , <span class="kw">pub </span>rfSelect : UavionixAdsbOutRfSelect , } <span class="kw">impl </span>UAVIONIX_ADSB_OUT_CFG_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ ICAO : <span class="number">0_u32 </span>, stallSpeed : <span class="number">0_u16 </span>, callsign : [<span class="number">0_u8 </span>; <span class="number">9usize</span>] , emitterType : AdsbEmitterType :: DEFAULT , aircraftSize : UavionixAdsbOutCfgAircraftSize :: DEFAULT , gpsOffsetLat : UavionixAdsbOutCfgGpsOffsetLat :: DEFAULT , gpsOffsetLon : UavionixAdsbOutCfgGpsOffsetLon :: DEFAULT , rfSelect : UavionixAdsbOutRfSelect :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . ICAO = buf . get_u32_le () ; _struct . stallSpeed = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . callsign { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . emitterType = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;AdsbEmitterType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . aircraftSize = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavionixAdsbOutCfgAircraftSize&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . gpsOffsetLat = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavionixAdsbOutCfgGpsOffsetLat&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . gpsOffsetLon = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavionixAdsbOutCfgGpsOffsetLon&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . rfSelect = UavionixAdsbOutRfSelect :: from_bits (tmp &amp; UavionixAdsbOutRfSelect :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;UavionixAdsbOutRfSelect&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. ICAO) ; _tmp . put_u16_le (<span class="self">self </span>. stallSpeed) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. callsign { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. emitterType <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. aircraftSize <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. gpsOffsetLat <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. gpsOffsetLon <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. rfSelect . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>UAVIONIX_ADSB_OUT_CFG_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_INFORMATION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>firmware_version : u32 , <span class="kw">pub </span>focal_length : f32 , <span class="kw">pub </span>sensor_size_h : f32 , <span class="kw">pub </span>sensor_size_v : f32 , <span class="kw">pub </span>flags : CameraCapFlags , <span class="kw">pub </span>resolution_h : u16 , <span class="kw">pub </span>resolution_v : u16 , <span class="kw">pub </span>cam_definition_version : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>vendor_name : [u8 ; <span class="number">32</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>model_name : [u8 ; <span class="number">32</span>] , <span class="kw">pub </span>lens_id : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>cam_definition_uri : [u8 ; <span class="number">140</span>] , } <span class="kw">impl </span>CAMERA_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">235usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, firmware_version : <span class="number">0_u32 </span>, focal_length : <span class="number">0.0_f32 </span>, sensor_size_h : <span class="number">0.0_f32 </span>, sensor_size_v : <span class="number">0.0_f32 </span>, flags : CameraCapFlags :: DEFAULT , resolution_h : <span class="number">0_u16 </span>, resolution_v : <span class="number">0_u16 </span>, cam_definition_version : <span class="number">0_u16 </span>, vendor_name : [<span class="number">0_u8 </span>; <span class="number">32usize</span>] , model_name : [<span class="number">0_u8 </span>; <span class="number">32usize</span>] , lens_id : <span class="number">0_u8 </span>, cam_definition_uri : [<span class="number">0_u8 </span>; <span class="number">140usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . firmware_version = buf . get_u32_le () ; _struct . focal_length = buf . get_f32_le () ; _struct . sensor_size_h = buf . get_f32_le () ; _struct . sensor_size_v = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . flags = CameraCapFlags :: from_bits (tmp &amp; CameraCapFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;CameraCapFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . resolution_h = buf . get_u16_le () ; _struct . resolution_v = buf . get_u16_le () ; _struct . cam_definition_version = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . vendor_name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . model_name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } _struct . lens_id = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . cam_definition_uri { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. firmware_version) ; _tmp . put_f32_le (<span class="self">self </span>. focal_length) ; _tmp . put_f32_le (<span class="self">self </span>. sensor_size_h) ; _tmp . put_f32_le (<span class="self">self </span>. sensor_size_v) ; _tmp . put_u32_le (<span class="self">self </span>. flags . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_h) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_v) ; _tmp . put_u16_le (<span class="self">self </span>. cam_definition_version) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vendor_name { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. model_name { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. lens_id) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. cam_definition_uri { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAMERA_INFORMATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>WATER_DEPTH_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lng : i32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>distance : f32 , <span class="kw">pub </span>temperature : f32 , <span class="kw">pub </span>id : u8 , <span class="kw">pub </span>healthy : u8 , } <span class="kw">impl </span>WATER_DEPTH_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">38usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, lat : <span class="number">0_i32 </span>, lng : <span class="number">0_i32 </span>, alt : <span class="number">0.0_f32 </span>, roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, distance : <span class="number">0.0_f32 </span>, temperature : <span class="number">0.0_f32 </span>, id : <span class="number">0_u8 </span>, healthy : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lng = buf . get_i32_le () ; _struct . alt = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . distance = buf . get_f32_le () ; _struct . temperature = buf . get_f32_le () ; _struct . id = buf . get_u8 () ; _struct . healthy = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lng) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. distance) ; _tmp . put_f32_le (<span class="self">self </span>. temperature) ; _tmp . put_u8 (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. healthy) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>WATER_DEPTH_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DATA_STREAM_DATA { <span class="kw">pub </span>message_rate : u16 , <span class="kw">pub </span>stream_id : u8 , <span class="kw">pub </span>on_off : u8 , } <span class="kw">impl </span>DATA_STREAM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ message_rate : <span class="number">0_u16 </span>, stream_id : <span class="number">0_u8 </span>, on_off : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . message_rate = buf . get_u16_le () ; _struct . stream_id = buf . get_u8 () ; _struct . on_off = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. message_rate) ; _tmp . put_u8 (<span class="self">self </span>. stream_id) ; _tmp . put_u8 (<span class="self">self </span>. on_off) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DATA_STREAM_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMMAND_LONG_DATA { <span class="kw">pub </span>param1 : f32 , <span class="kw">pub </span>param2 : f32 , <span class="kw">pub </span>param3 : f32 , <span class="kw">pub </span>param4 : f32 , <span class="kw">pub </span>param5 : f32 , <span class="kw">pub </span>param6 : f32 , <span class="kw">pub </span>param7 : f32 , <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>confirmation : u8 , } <span class="kw">impl </span>COMMAND_LONG_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">33usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ param1 : <span class="number">0.0_f32 </span>, param2 : <span class="number">0.0_f32 </span>, param3 : <span class="number">0.0_f32 </span>, param4 : <span class="number">0.0_f32 </span>, param5 : <span class="number">0.0_f32 </span>, param6 : <span class="number">0.0_f32 </span>, param7 : <span class="number">0.0_f32 </span>, command : MavCmd :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, confirmation : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param1 = buf . get_f32_le () ; _struct . param2 = buf . get_f32_le () ; _struct . param3 = buf . get_f32_le () ; _struct . param4 = buf . get_f32_le () ; _struct . param5 = buf . get_f32_le () ; _struct . param6 = buf . get_f32_le () ; _struct . param7 = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . confirmation = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param1) ; _tmp . put_f32_le (<span class="self">self </span>. param2) ; _tmp . put_f32_le (<span class="self">self </span>. param3) ; _tmp . put_f32_le (<span class="self">self </span>. param4) ; _tmp . put_f32_le (<span class="self">self </span>. param5) ; _tmp . put_f32_le (<span class="self">self </span>. param6) ; _tmp . put_f32_le (<span class="self">self </span>. param7) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. confirmation) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>COMMAND_LONG_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SETUP_SIGNING_DATA { <span class="kw">pub </span>initial_timestamp : u64 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>secret_key : [u8 ; <span class="number">32</span>] , } <span class="kw">impl </span>SETUP_SIGNING_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ initial_timestamp : <span class="number">0_u64 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, secret_key : [<span class="number">0_u8 </span>; <span class="number">32usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . initial_timestamp = buf . get_u64_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . secret_key { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. initial_timestamp) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. secret_key { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SETUP_SIGNING_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_CONTROLS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>roll_ailerons : f32 , <span class="kw">pub </span>pitch_elevator : f32 , <span class="kw">pub </span>yaw_rudder : f32 , <span class="kw">pub </span>throttle : f32 , <span class="kw">pub </span>aux1 : f32 , <span class="kw">pub </span>aux2 : f32 , <span class="kw">pub </span>aux3 : f32 , <span class="kw">pub </span>aux4 : f32 , <span class="kw">pub </span>mode : MavMode , <span class="kw">pub </span>nav_mode : u8 , } <span class="kw">impl </span>HIL_CONTROLS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, roll_ailerons : <span class="number">0.0_f32 </span>, pitch_elevator : <span class="number">0.0_f32 </span>, yaw_rudder : <span class="number">0.0_f32 </span>, throttle : <span class="number">0.0_f32 </span>, aux1 : <span class="number">0.0_f32 </span>, aux2 : <span class="number">0.0_f32 </span>, aux3 : <span class="number">0.0_f32 </span>, aux4 : <span class="number">0.0_f32 </span>, mode : MavMode :: DEFAULT , nav_mode : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . roll_ailerons = buf . get_f32_le () ; _struct . pitch_elevator = buf . get_f32_le () ; _struct . yaw_rudder = buf . get_f32_le () ; _struct . throttle = buf . get_f32_le () ; _struct . aux1 = buf . get_f32_le () ; _struct . aux2 = buf . get_f32_le () ; _struct . aux3 = buf . get_f32_le () ; _struct . aux4 = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mode = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . nav_mode = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. roll_ailerons) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_elevator) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rudder) ; _tmp . put_f32_le (<span class="self">self </span>. throttle) ; _tmp . put_f32_le (<span class="self">self </span>. aux1) ; _tmp . put_f32_le (<span class="self">self </span>. aux2) ; _tmp . put_f32_le (<span class="self">self </span>. aux3) ; _tmp . put_f32_le (<span class="self">self </span>. aux4) ; _tmp . put_u8 (<span class="self">self </span>. mode <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. nav_mode) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HIL_CONTROLS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>REMOTE_LOG_DATA_BLOCK_DATA { <span class="kw">pub </span>seqno : MavRemoteLogDataBlockCommands , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">200</span>] , } <span class="kw">impl </span>REMOTE_LOG_DATA_BLOCK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">206usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ seqno : MavRemoteLogDataBlockCommands :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">200usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . seqno = FromPrimitive :: from_u32 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavRemoteLogDataBlockCommands&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. seqno <span class="kw">as </span>u32) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>REMOTE_LOG_DATA_BLOCK_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIGHRES_IMU_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>xacc : f32 , <span class="kw">pub </span>yacc : f32 , <span class="kw">pub </span>zacc : f32 , <span class="kw">pub </span>xgyro : f32 , <span class="kw">pub </span>ygyro : f32 , <span class="kw">pub </span>zgyro : f32 , <span class="kw">pub </span>xmag : f32 , <span class="kw">pub </span>ymag : f32 , <span class="kw">pub </span>zmag : f32 , <span class="kw">pub </span>abs_pressure : f32 , <span class="kw">pub </span>diff_pressure : f32 , <span class="kw">pub </span>pressure_alt : f32 , <span class="kw">pub </span>temperature : f32 , <span class="kw">pub </span>fields_updated : HighresImuUpdatedFlags , } <span class="kw">impl </span>HIGHRES_IMU_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">62usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, xacc : <span class="number">0.0_f32 </span>, yacc : <span class="number">0.0_f32 </span>, zacc : <span class="number">0.0_f32 </span>, xgyro : <span class="number">0.0_f32 </span>, ygyro : <span class="number">0.0_f32 </span>, zgyro : <span class="number">0.0_f32 </span>, xmag : <span class="number">0.0_f32 </span>, ymag : <span class="number">0.0_f32 </span>, zmag : <span class="number">0.0_f32 </span>, abs_pressure : <span class="number">0.0_f32 </span>, diff_pressure : <span class="number">0.0_f32 </span>, pressure_alt : <span class="number">0.0_f32 </span>, temperature : <span class="number">0.0_f32 </span>, fields_updated : HighresImuUpdatedFlags :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . xacc = buf . get_f32_le () ; _struct . yacc = buf . get_f32_le () ; _struct . zacc = buf . get_f32_le () ; _struct . xgyro = buf . get_f32_le () ; _struct . ygyro = buf . get_f32_le () ; _struct . zgyro = buf . get_f32_le () ; _struct . xmag = buf . get_f32_le () ; _struct . ymag = buf . get_f32_le () ; _struct . zmag = buf . get_f32_le () ; _struct . abs_pressure = buf . get_f32_le () ; _struct . diff_pressure = buf . get_f32_le () ; _struct . pressure_alt = buf . get_f32_le () ; _struct . temperature = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . fields_updated = HighresImuUpdatedFlags :: from_bits (tmp &amp; HighresImuUpdatedFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;HighresImuUpdatedFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. xacc) ; _tmp . put_f32_le (<span class="self">self </span>. yacc) ; _tmp . put_f32_le (<span class="self">self </span>. zacc) ; _tmp . put_f32_le (<span class="self">self </span>. xgyro) ; _tmp . put_f32_le (<span class="self">self </span>. ygyro) ; _tmp . put_f32_le (<span class="self">self </span>. zgyro) ; _tmp . put_f32_le (<span class="self">self </span>. xmag) ; _tmp . put_f32_le (<span class="self">self </span>. ymag) ; _tmp . put_f32_le (<span class="self">self </span>. zmag) ; _tmp . put_f32_le (<span class="self">self </span>. abs_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. diff_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. pressure_alt) ; _tmp . put_f32_le (<span class="self">self </span>. temperature) ; _tmp . put_u16_le (<span class="self">self </span>. fields_updated . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HIGHRES_IMU_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ORBIT_EXECUTION_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>radius : f32 , <span class="kw">pub </span>x : i32 , <span class="kw">pub </span>y : i32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>frame : MavFrame , } <span class="kw">impl </span>ORBIT_EXECUTION_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">25usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, radius : <span class="number">0.0_f32 </span>, x : <span class="number">0_i32 </span>, y : <span class="number">0_i32 </span>, z : <span class="number">0.0_f32 </span>, frame : MavFrame :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . radius = buf . get_f32_le () ; _struct . x = buf . get_i32_le () ; _struct . y = buf . get_i32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. radius) ; _tmp . put_i32_le (<span class="self">self </span>. x) ; _tmp . put_i32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ORBIT_EXECUTION_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_IMU2_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , <span class="kw">pub </span>xgyro : i16 , <span class="kw">pub </span>ygyro : i16 , <span class="kw">pub </span>zgyro : i16 , <span class="kw">pub </span>xmag : i16 , <span class="kw">pub </span>ymag : i16 , <span class="kw">pub </span>zmag : i16 , } <span class="kw">impl </span>SCALED_IMU2_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, xacc : <span class="number">0_i16 </span>, yacc : <span class="number">0_i16 </span>, zacc : <span class="number">0_i16 </span>, xgyro : <span class="number">0_i16 </span>, ygyro : <span class="number">0_i16 </span>, zgyro : <span class="number">0_i16 </span>, xmag : <span class="number">0_i16 </span>, ymag : <span class="number">0_i16 </span>, zmag : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; _struct . xgyro = buf . get_i16_le () ; _struct . ygyro = buf . get_i16_le () ; _struct . zgyro = buf . get_i16_le () ; _struct . xmag = buf . get_i16_le () ; _struct . ymag = buf . get_i16_le () ; _struct . zmag = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; _tmp . put_i16_le (<span class="self">self </span>. xgyro) ; _tmp . put_i16_le (<span class="self">self </span>. ygyro) ; _tmp . put_i16_le (<span class="self">self </span>. zgyro) ; _tmp . put_i16_le (<span class="self">self </span>. xmag) ; _tmp . put_i16_le (<span class="self">self </span>. ymag) ; _tmp . put_i16_le (<span class="self">self </span>. zmag) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SCALED_IMU2_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MOUNT_CONFIGURE_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>mount_mode : MavMountMode , <span class="kw">pub </span>stab_roll : u8 , <span class="kw">pub </span>stab_pitch : u8 , <span class="kw">pub </span>stab_yaw : u8 , } <span class="kw">impl </span>MOUNT_CONFIGURE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, mount_mode : MavMountMode :: DEFAULT , stab_roll : <span class="number">0_u8 </span>, stab_pitch : <span class="number">0_u8 </span>, stab_yaw : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mount_mode = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavMountMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . stab_roll = buf . get_u8 () ; _struct . stab_pitch = buf . get_u8 () ; _struct . stab_yaw = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. mount_mode <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. stab_roll) ; _tmp . put_u8 (<span class="self">self </span>. stab_pitch) ; _tmp . put_u8 (<span class="self">self </span>. stab_yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MOUNT_CONFIGURE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MANUAL_CONTROL_DATA { <span class="kw">pub </span>x : i16 , <span class="kw">pub </span>y : i16 , <span class="kw">pub </span>z : i16 , <span class="kw">pub </span>r : i16 , <span class="kw">pub </span>buttons : u16 , <span class="kw">pub </span>target : u8 , } <span class="kw">impl </span>MANUAL_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">11usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ x : <span class="number">0_i16 </span>, y : <span class="number">0_i16 </span>, z : <span class="number">0_i16 </span>, r : <span class="number">0_i16 </span>, buttons : <span class="number">0_u16 </span>, target : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . x = buf . get_i16_le () ; _struct . y = buf . get_i16_le () ; _struct . z = buf . get_i16_le () ; _struct . r = buf . get_i16_le () ; _struct . buttons = buf . get_u16_le () ; _struct . target = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. x) ; _tmp . put_i16_le (<span class="self">self </span>. y) ; _tmp . put_i16_le (<span class="self">self </span>. z) ; _tmp . put_i16_le (<span class="self">self </span>. r) ; _tmp . put_u16_le (<span class="self">self </span>. buttons) ; _tmp . put_u8 (<span class="self">self </span>. target) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MANUAL_CONTROL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SAFETY_SET_ALLOWED_AREA_DATA { <span class="kw">pub </span>p1x : f32 , <span class="kw">pub </span>p1y : f32 , <span class="kw">pub </span>p1z : f32 , <span class="kw">pub </span>p2x : f32 , <span class="kw">pub </span>p2y : f32 , <span class="kw">pub </span>p2z : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>frame : MavFrame , } <span class="kw">impl </span>SAFETY_SET_ALLOWED_AREA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">27usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ p1x : <span class="number">0.0_f32 </span>, p1y : <span class="number">0.0_f32 </span>, p1z : <span class="number">0.0_f32 </span>, p2x : <span class="number">0.0_f32 </span>, p2y : <span class="number">0.0_f32 </span>, p2z : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, frame : MavFrame :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . p1x = buf . get_f32_le () ; _struct . p1y = buf . get_f32_le () ; _struct . p1z = buf . get_f32_le () ; _struct . p2x = buf . get_f32_le () ; _struct . p2y = buf . get_f32_le () ; _struct . p2z = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. p1x) ; _tmp . put_f32_le (<span class="self">self </span>. p1y) ; _tmp . put_f32_le (<span class="self">self </span>. p1z) ; _tmp . put_f32_le (<span class="self">self </span>. p2x) ; _tmp . put_f32_le (<span class="self">self </span>. p2y) ; _tmp . put_f32_le (<span class="self">self </span>. p2z) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SAFETY_SET_ALLOWED_AREA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HWSTATUS_DATA { <span class="kw">pub </span>Vcc : u16 , <span class="kw">pub </span>I2Cerr : u8 , } <span class="kw">impl </span>HWSTATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ Vcc : <span class="number">0_u16 </span>, I2Cerr : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . Vcc = buf . get_u16_le () ; _struct . I2Cerr = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. Vcc) ; _tmp . put_u8 (<span class="self">self </span>. I2Cerr) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HWSTATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AUTOPILOT_VERSION_REQUEST_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>AUTOPILOT_VERSION_REQUEST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>AUTOPILOT_VERSION_REQUEST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT_DATA { <span class="kw">pub </span>rfHealth : UavionixAdsbRfHealth , } <span class="kw">impl </span>UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">1usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ rfHealth : UavionixAdsbRfHealth :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . rfHealth = UavionixAdsbRfHealth :: from_bits (tmp &amp; UavionixAdsbRfHealth :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;UavionixAdsbRfHealth&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. rfHealth . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_REQUEST_LIST_DATA { <span class="kw">pub </span>start : u16 , <span class="kw">pub </span>end : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>LOG_REQUEST_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ start : <span class="number">0_u16 </span>, end : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . start = buf . get_u16_le () ; _struct . end = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. start) ; _tmp . put_u16_le (<span class="self">self </span>. end) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOG_REQUEST_LIST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS2_RTK_DATA { <span class="kw">pub </span>time_last_baseline_ms : u32 , <span class="kw">pub </span>tow : u32 , <span class="kw">pub </span>baseline_a_mm : i32 , <span class="kw">pub </span>baseline_b_mm : i32 , <span class="kw">pub </span>baseline_c_mm : i32 , <span class="kw">pub </span>accuracy : u32 , <span class="kw">pub </span>iar_num_hypotheses : i32 , <span class="kw">pub </span>wn : u16 , <span class="kw">pub </span>rtk_receiver_id : u8 , <span class="kw">pub </span>rtk_health : u8 , <span class="kw">pub </span>rtk_rate : u8 , <span class="kw">pub </span>nsats : u8 , <span class="kw">pub </span>baseline_coords_type : RtkBaselineCoordinateSystem , } <span class="kw">impl </span>GPS2_RTK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">35usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_last_baseline_ms : <span class="number">0_u32 </span>, tow : <span class="number">0_u32 </span>, baseline_a_mm : <span class="number">0_i32 </span>, baseline_b_mm : <span class="number">0_i32 </span>, baseline_c_mm : <span class="number">0_i32 </span>, accuracy : <span class="number">0_u32 </span>, iar_num_hypotheses : <span class="number">0_i32 </span>, wn : <span class="number">0_u16 </span>, rtk_receiver_id : <span class="number">0_u8 </span>, rtk_health : <span class="number">0_u8 </span>, rtk_rate : <span class="number">0_u8 </span>, nsats : <span class="number">0_u8 </span>, baseline_coords_type : RtkBaselineCoordinateSystem :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_last_baseline_ms = buf . get_u32_le () ; _struct . tow = buf . get_u32_le () ; _struct . baseline_a_mm = buf . get_i32_le () ; _struct . baseline_b_mm = buf . get_i32_le () ; _struct . baseline_c_mm = buf . get_i32_le () ; _struct . accuracy = buf . get_u32_le () ; _struct . iar_num_hypotheses = buf . get_i32_le () ; _struct . wn = buf . get_u16_le () ; _struct . rtk_receiver_id = buf . get_u8 () ; _struct . rtk_health = buf . get_u8 () ; _struct . rtk_rate = buf . get_u8 () ; _struct . nsats = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . baseline_coords_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;RtkBaselineCoordinateSystem&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_last_baseline_ms) ; _tmp . put_u32_le (<span class="self">self </span>. tow) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_a_mm) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_b_mm) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_c_mm) ; _tmp . put_u32_le (<span class="self">self </span>. accuracy) ; _tmp . put_i32_le (<span class="self">self </span>. iar_num_hypotheses) ; _tmp . put_u16_le (<span class="self">self </span>. wn) ; _tmp . put_u8 (<span class="self">self </span>. rtk_receiver_id) ; _tmp . put_u8 (<span class="self">self </span>. rtk_health) ; _tmp . put_u8 (<span class="self">self </span>. rtk_rate) ; _tmp . put_u8 (<span class="self">self </span>. nsats) ; _tmp . put_u8 (<span class="self">self </span>. baseline_coords_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GPS2_RTK_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>WIND_COV_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>wind_x : f32 , <span class="kw">pub </span>wind_y : f32 , <span class="kw">pub </span>wind_z : f32 , <span class="kw">pub </span>var_horiz : f32 , <span class="kw">pub </span>var_vert : f32 , <span class="kw">pub </span>wind_alt : f32 , <span class="kw">pub </span>horiz_accuracy : f32 , <span class="kw">pub </span>vert_accuracy : f32 , } <span class="kw">impl </span>WIND_COV_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">40usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, wind_x : <span class="number">0.0_f32 </span>, wind_y : <span class="number">0.0_f32 </span>, wind_z : <span class="number">0.0_f32 </span>, var_horiz : <span class="number">0.0_f32 </span>, var_vert : <span class="number">0.0_f32 </span>, wind_alt : <span class="number">0.0_f32 </span>, horiz_accuracy : <span class="number">0.0_f32 </span>, vert_accuracy : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . wind_x = buf . get_f32_le () ; _struct . wind_y = buf . get_f32_le () ; _struct . wind_z = buf . get_f32_le () ; _struct . var_horiz = buf . get_f32_le () ; _struct . var_vert = buf . get_f32_le () ; _struct . wind_alt = buf . get_f32_le () ; _struct . horiz_accuracy = buf . get_f32_le () ; _struct . vert_accuracy = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. wind_x) ; _tmp . put_f32_le (<span class="self">self </span>. wind_y) ; _tmp . put_f32_le (<span class="self">self </span>. wind_z) ; _tmp . put_f32_le (<span class="self">self </span>. var_horiz) ; _tmp . put_f32_le (<span class="self">self </span>. var_vert) ; _tmp . put_f32_le (<span class="self">self </span>. wind_alt) ; _tmp . put_f32_le (<span class="self">self </span>. horiz_accuracy) ; _tmp . put_f32_le (<span class="self">self </span>. vert_accuracy) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>WIND_COV_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DEVICE_OP_READ_REPLY_DATA { <span class="kw">pub </span>request_id : u32 , <span class="kw">pub </span>result : u8 , <span class="kw">pub </span>regstart : u8 , <span class="kw">pub </span>count : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">128</span>] , } <span class="kw">impl </span>DEVICE_OP_READ_REPLY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">135usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ request_id : <span class="number">0_u32 </span>, result : <span class="number">0_u8 </span>, regstart : <span class="number">0_u8 </span>, count : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">128usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . request_id = buf . get_u32_le () ; _struct . result = buf . get_u8 () ; _struct . regstart = buf . get_u8 () ; _struct . count = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. request_id) ; _tmp . put_u8 (<span class="self">self </span>. result) ; _tmp . put_u8 (<span class="self">self </span>. regstart) ; _tmp . put_u8 (<span class="self">self </span>. count) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DEVICE_OP_READ_REPLY_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DISTANCE_SENSOR_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>min_distance : u16 , <span class="kw">pub </span>max_distance : u16 , <span class="kw">pub </span>current_distance : u16 , <span class="kw">pub </span>mavtype : MavDistanceSensor , <span class="kw">pub </span>id : u8 , <span class="kw">pub </span>orientation : MavSensorOrientation , <span class="kw">pub </span>covariance : u8 , } <span class="kw">impl </span>DISTANCE_SENSOR_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, min_distance : <span class="number">0_u16 </span>, max_distance : <span class="number">0_u16 </span>, current_distance : <span class="number">0_u16 </span>, mavtype : MavDistanceSensor :: DEFAULT , id : <span class="number">0_u8 </span>, orientation : MavSensorOrientation :: DEFAULT , covariance : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . min_distance = buf . get_u16_le () ; _struct . max_distance = buf . get_u16_le () ; _struct . current_distance = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavDistanceSensor&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . id = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . orientation = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavSensorOrientation&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . covariance = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u16_le (<span class="self">self </span>. min_distance) ; _tmp . put_u16_le (<span class="self">self </span>. max_distance) ; _tmp . put_u16_le (<span class="self">self </span>. current_distance) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. orientation <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. covariance) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DISTANCE_SENSOR_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SERIAL_CONTROL_DATA { <span class="kw">pub </span>baudrate : u32 , <span class="kw">pub </span>timeout : u16 , <span class="kw">pub </span>device : SerialControlDev , <span class="kw">pub </span>flags : SerialControlFlag , <span class="kw">pub </span>count : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">70</span>] , } <span class="kw">impl </span>SERIAL_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">79usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ baudrate : <span class="number">0_u32 </span>, timeout : <span class="number">0_u16 </span>, device : SerialControlDev :: DEFAULT , flags : SerialControlFlag :: DEFAULT , count : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">70usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . baudrate = buf . get_u32_le () ; _struct . timeout = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . device = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;SerialControlDev&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . flags = SerialControlFlag :: from_bits (tmp &amp; SerialControlFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;SerialControlFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . count = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. baudrate) ; _tmp . put_u16_le (<span class="self">self </span>. timeout) ; _tmp . put_u8 (<span class="self">self </span>. device <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. flags . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. count) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SERIAL_CONTROL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_ERASE_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>LOG_ERASE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOG_ERASE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPTICAL_FLOW_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>flow_comp_m_x : f32 , <span class="kw">pub </span>flow_comp_m_y : f32 , <span class="kw">pub </span>ground_distance : f32 , <span class="kw">pub </span>flow_x : i16 , <span class="kw">pub </span>flow_y : i16 , <span class="kw">pub </span>sensor_id : u8 , <span class="kw">pub </span>quality : u8 , } <span class="kw">impl </span>OPTICAL_FLOW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">26usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, flow_comp_m_x : <span class="number">0.0_f32 </span>, flow_comp_m_y : <span class="number">0.0_f32 </span>, ground_distance : <span class="number">0.0_f32 </span>, flow_x : <span class="number">0_i16 </span>, flow_y : <span class="number">0_i16 </span>, sensor_id : <span class="number">0_u8 </span>, quality : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . flow_comp_m_x = buf . get_f32_le () ; _struct . flow_comp_m_y = buf . get_f32_le () ; _struct . ground_distance = buf . get_f32_le () ; _struct . flow_x = buf . get_i16_le () ; _struct . flow_y = buf . get_i16_le () ; _struct . sensor_id = buf . get_u8 () ; _struct . quality = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. flow_comp_m_x) ; _tmp . put_f32_le (<span class="self">self </span>. flow_comp_m_y) ; _tmp . put_f32_le (<span class="self">self </span>. ground_distance) ; _tmp . put_i16_le (<span class="self">self </span>. flow_x) ; _tmp . put_i16_le (<span class="self">self </span>. flow_y) ; _tmp . put_u8 (<span class="self">self </span>. sensor_id) ; _tmp . put_u8 (<span class="self">self </span>. quality) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OPTICAL_FLOW_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ENCAPSULATED_DATA_DATA { <span class="kw">pub </span>seqnr : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">253</span>] , } <span class="kw">impl </span>ENCAPSULATED_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">255usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ seqnr : <span class="number">0_u16 </span>, data : [<span class="number">0_u8 </span>; <span class="number">253usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seqnr = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seqnr) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ENCAPSULATED_DATA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_ENTRY_DATA { <span class="kw">pub </span>time_utc : u32 , <span class="kw">pub </span>size : u32 , <span class="kw">pub </span>id : u16 , <span class="kw">pub </span>num_logs : u16 , <span class="kw">pub </span>last_log_num : u16 , } <span class="kw">impl </span>LOG_ENTRY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_utc : <span class="number">0_u32 </span>, size : <span class="number">0_u32 </span>, id : <span class="number">0_u16 </span>, num_logs : <span class="number">0_u16 </span>, last_log_num : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_utc = buf . get_u32_le () ; _struct . size = buf . get_u32_le () ; _struct . id = buf . get_u16_le () ; _struct . num_logs = buf . get_u16_le () ; _struct . last_log_num = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_utc) ; _tmp . put_u32_le (<span class="self">self </span>. size) ; _tmp . put_u16_le (<span class="self">self </span>. id) ; _tmp . put_u16_le (<span class="self">self </span>. num_logs) ; _tmp . put_u16_le (<span class="self">self </span>. last_log_num) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOG_ENTRY_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIGH_LATENCY2_DATA { <span class="kw">pub </span>timestamp : u32 , <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>custom_mode : u16 , <span class="kw">pub </span>altitude : i16 , <span class="kw">pub </span>target_altitude : i16 , <span class="kw">pub </span>target_distance : u16 , <span class="kw">pub </span>wp_num : u16 , <span class="kw">pub </span>failure_flags : HlFailureFlag , <span class="kw">pub </span>mavtype : MavType , <span class="kw">pub </span>autopilot : MavAutopilot , <span class="kw">pub </span>heading : u8 , <span class="kw">pub </span>target_heading : u8 , <span class="kw">pub </span>throttle : u8 , <span class="kw">pub </span>airspeed : u8 , <span class="kw">pub </span>airspeed_sp : u8 , <span class="kw">pub </span>groundspeed : u8 , <span class="kw">pub </span>windspeed : u8 , <span class="kw">pub </span>wind_heading : u8 , <span class="kw">pub </span>eph : u8 , <span class="kw">pub </span>epv : u8 , <span class="kw">pub </span>temperature_air : i8 , <span class="kw">pub </span>climb_rate : i8 , <span class="kw">pub </span>battery : i8 , <span class="kw">pub </span>custom0 : i8 , <span class="kw">pub </span>custom1 : i8 , <span class="kw">pub </span>custom2 : i8 , } <span class="kw">impl </span>HIGH_LATENCY2_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ timestamp : <span class="number">0_u32 </span>, latitude : <span class="number">0_i32 </span>, longitude : <span class="number">0_i32 </span>, custom_mode : <span class="number">0_u16 </span>, altitude : <span class="number">0_i16 </span>, target_altitude : <span class="number">0_i16 </span>, target_distance : <span class="number">0_u16 </span>, wp_num : <span class="number">0_u16 </span>, failure_flags : HlFailureFlag :: DEFAULT , mavtype : MavType :: DEFAULT , autopilot : MavAutopilot :: DEFAULT , heading : <span class="number">0_u8 </span>, target_heading : <span class="number">0_u8 </span>, throttle : <span class="number">0_u8 </span>, airspeed : <span class="number">0_u8 </span>, airspeed_sp : <span class="number">0_u8 </span>, groundspeed : <span class="number">0_u8 </span>, windspeed : <span class="number">0_u8 </span>, wind_heading : <span class="number">0_u8 </span>, eph : <span class="number">0_u8 </span>, epv : <span class="number">0_u8 </span>, temperature_air : <span class="number">0_i8 </span>, climb_rate : <span class="number">0_i8 </span>, battery : <span class="number">0_i8 </span>, custom0 : <span class="number">0_i8 </span>, custom1 : <span class="number">0_i8 </span>, custom2 : <span class="number">0_i8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . timestamp = buf . get_u32_le () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . custom_mode = buf . get_u16_le () ; _struct . altitude = buf . get_i16_le () ; _struct . target_altitude = buf . get_i16_le () ; _struct . target_distance = buf . get_u16_le () ; _struct . wp_num = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . failure_flags = HlFailureFlag :: from_bits (tmp &amp; HlFailureFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;HlFailureFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . autopilot = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavAutopilot&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . heading = buf . get_u8 () ; _struct . target_heading = buf . get_u8 () ; _struct . throttle = buf . get_u8 () ; _struct . airspeed = buf . get_u8 () ; _struct . airspeed_sp = buf . get_u8 () ; _struct . groundspeed = buf . get_u8 () ; _struct . windspeed = buf . get_u8 () ; _struct . wind_heading = buf . get_u8 () ; _struct . eph = buf . get_u8 () ; _struct . epv = buf . get_u8 () ; _struct . temperature_air = buf . get_i8 () ; _struct . climb_rate = buf . get_i8 () ; _struct . battery = buf . get_i8 () ; _struct . custom0 = buf . get_i8 () ; _struct . custom1 = buf . get_i8 () ; _struct . custom2 = buf . get_i8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. timestamp) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_u16_le (<span class="self">self </span>. custom_mode) ; _tmp . put_i16_le (<span class="self">self </span>. altitude) ; _tmp . put_i16_le (<span class="self">self </span>. target_altitude) ; _tmp . put_u16_le (<span class="self">self </span>. target_distance) ; _tmp . put_u16_le (<span class="self">self </span>. wp_num) ; _tmp . put_u16_le (<span class="self">self </span>. failure_flags . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. autopilot <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. heading) ; _tmp . put_u8 (<span class="self">self </span>. target_heading) ; _tmp . put_u8 (<span class="self">self </span>. throttle) ; _tmp . put_u8 (<span class="self">self </span>. airspeed) ; _tmp . put_u8 (<span class="self">self </span>. airspeed_sp) ; _tmp . put_u8 (<span class="self">self </span>. groundspeed) ; _tmp . put_u8 (<span class="self">self </span>. windspeed) ; _tmp . put_u8 (<span class="self">self </span>. wind_heading) ; _tmp . put_u8 (<span class="self">self </span>. eph) ; _tmp . put_u8 (<span class="self">self </span>. epv) ; _tmp . put_i8 (<span class="self">self </span>. temperature_air) ; _tmp . put_i8 (<span class="self">self </span>. climb_rate) ; _tmp . put_i8 (<span class="self">self </span>. battery) ; _tmp . put_i8 (<span class="self">self </span>. custom0) ; _tmp . put_i8 (<span class="self">self </span>. custom1) ; _tmp . put_i8 (<span class="self">self </span>. custom2) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HIGH_LATENCY2_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ISBD_LINK_STATUS_DATA { <span class="kw">pub </span>timestamp : u64 , <span class="kw">pub </span>last_heartbeat : u64 , <span class="kw">pub </span>failed_sessions : u16 , <span class="kw">pub </span>successful_sessions : u16 , <span class="kw">pub </span>signal_quality : u8 , <span class="kw">pub </span>ring_pending : u8 , <span class="kw">pub </span>tx_session_pending : u8 , <span class="kw">pub </span>rx_session_pending : u8 , } <span class="kw">impl </span>ISBD_LINK_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">24usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ timestamp : <span class="number">0_u64 </span>, last_heartbeat : <span class="number">0_u64 </span>, failed_sessions : <span class="number">0_u16 </span>, successful_sessions : <span class="number">0_u16 </span>, signal_quality : <span class="number">0_u8 </span>, ring_pending : <span class="number">0_u8 </span>, tx_session_pending : <span class="number">0_u8 </span>, rx_session_pending : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . timestamp = buf . get_u64_le () ; _struct . last_heartbeat = buf . get_u64_le () ; _struct . failed_sessions = buf . get_u16_le () ; _struct . successful_sessions = buf . get_u16_le () ; _struct . signal_quality = buf . get_u8 () ; _struct . ring_pending = buf . get_u8 () ; _struct . tx_session_pending = buf . get_u8 () ; _struct . rx_session_pending = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. timestamp) ; _tmp . put_u64_le (<span class="self">self </span>. last_heartbeat) ; _tmp . put_u16_le (<span class="self">self </span>. failed_sessions) ; _tmp . put_u16_le (<span class="self">self </span>. successful_sessions) ; _tmp . put_u8 (<span class="self">self </span>. signal_quality) ; _tmp . put_u8 (<span class="self">self </span>. ring_pending) ; _tmp . put_u8 (<span class="self">self </span>. tx_session_pending) ; _tmp . put_u8 (<span class="self">self </span>. rx_session_pending) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ISBD_LINK_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RESPONSE_EVENT_ERROR_DATA { <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>sequence_oldest_available : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>reason : MavEventErrorReason , } <span class="kw">impl </span>RESPONSE_EVENT_ERROR_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">7usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ sequence : <span class="number">0_u16 </span>, sequence_oldest_available : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, reason : MavEventErrorReason :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . sequence = buf . get_u16_le () ; _struct . sequence_oldest_available = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . reason = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavEventErrorReason&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u16_le (<span class="self">self </span>. sequence_oldest_available) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. reason <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RESPONSE_EVENT_ERROR_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ESTIMATOR_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>vel_ratio : f32 , <span class="kw">pub </span>pos_horiz_ratio : f32 , <span class="kw">pub </span>pos_vert_ratio : f32 , <span class="kw">pub </span>mag_ratio : f32 , <span class="kw">pub </span>hagl_ratio : f32 , <span class="kw">pub </span>tas_ratio : f32 , <span class="kw">pub </span>pos_horiz_accuracy : f32 , <span class="kw">pub </span>pos_vert_accuracy : f32 , <span class="kw">pub </span>flags : EstimatorStatusFlags , } <span class="kw">impl </span>ESTIMATOR_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, vel_ratio : <span class="number">0.0_f32 </span>, pos_horiz_ratio : <span class="number">0.0_f32 </span>, pos_vert_ratio : <span class="number">0.0_f32 </span>, mag_ratio : <span class="number">0.0_f32 </span>, hagl_ratio : <span class="number">0.0_f32 </span>, tas_ratio : <span class="number">0.0_f32 </span>, pos_horiz_accuracy : <span class="number">0.0_f32 </span>, pos_vert_accuracy : <span class="number">0.0_f32 </span>, flags : EstimatorStatusFlags :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . vel_ratio = buf . get_f32_le () ; _struct . pos_horiz_ratio = buf . get_f32_le () ; _struct . pos_vert_ratio = buf . get_f32_le () ; _struct . mag_ratio = buf . get_f32_le () ; _struct . hagl_ratio = buf . get_f32_le () ; _struct . tas_ratio = buf . get_f32_le () ; _struct . pos_horiz_accuracy = buf . get_f32_le () ; _struct . pos_vert_accuracy = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = EstimatorStatusFlags :: from_bits (tmp &amp; EstimatorStatusFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;EstimatorStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. vel_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. pos_horiz_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. pos_vert_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. mag_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. hagl_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. tas_ratio) ; _tmp . put_f32_le (<span class="self">self </span>. pos_horiz_accuracy) ; _tmp . put_f32_le (<span class="self">self </span>. pos_vert_accuracy) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ESTIMATOR_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MCU_STATUS_DATA { <span class="kw">pub </span>MCU_temperature : i16 , <span class="kw">pub </span>MCU_voltage : u16 , <span class="kw">pub </span>MCU_voltage_min : u16 , <span class="kw">pub </span>MCU_voltage_max : u16 , <span class="kw">pub </span>id : u8 , } <span class="kw">impl </span>MCU_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">9usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ MCU_temperature : <span class="number">0_i16 </span>, MCU_voltage : <span class="number">0_u16 </span>, MCU_voltage_min : <span class="number">0_u16 </span>, MCU_voltage_max : <span class="number">0_u16 </span>, id : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . MCU_temperature = buf . get_i16_le () ; _struct . MCU_voltage = buf . get_u16_le () ; _struct . MCU_voltage_min = buf . get_u16_le () ; _struct . MCU_voltage_max = buf . get_u16_le () ; _struct . id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. MCU_temperature) ; _tmp . put_u16_le (<span class="self">self </span>. MCU_voltage) ; _tmp . put_u16_le (<span class="self">self </span>. MCU_voltage_min) ; _tmp . put_u16_le (<span class="self">self </span>. MCU_voltage_max) ; _tmp . put_u8 (<span class="self">self </span>. id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MCU_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RC_CHANNELS_RAW_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>chan1_raw : u16 , <span class="kw">pub </span>chan2_raw : u16 , <span class="kw">pub </span>chan3_raw : u16 , <span class="kw">pub </span>chan4_raw : u16 , <span class="kw">pub </span>chan5_raw : u16 , <span class="kw">pub </span>chan6_raw : u16 , <span class="kw">pub </span>chan7_raw : u16 , <span class="kw">pub </span>chan8_raw : u16 , <span class="kw">pub </span>port : u8 , <span class="kw">pub </span>rssi : u8 , } <span class="kw">impl </span>RC_CHANNELS_RAW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, chan1_raw : <span class="number">0_u16 </span>, chan2_raw : <span class="number">0_u16 </span>, chan3_raw : <span class="number">0_u16 </span>, chan4_raw : <span class="number">0_u16 </span>, chan5_raw : <span class="number">0_u16 </span>, chan6_raw : <span class="number">0_u16 </span>, chan7_raw : <span class="number">0_u16 </span>, chan8_raw : <span class="number">0_u16 </span>, port : <span class="number">0_u8 </span>, rssi : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . chan1_raw = buf . get_u16_le () ; _struct . chan2_raw = buf . get_u16_le () ; _struct . chan3_raw = buf . get_u16_le () ; _struct . chan4_raw = buf . get_u16_le () ; _struct . chan5_raw = buf . get_u16_le () ; _struct . chan6_raw = buf . get_u16_le () ; _struct . chan7_raw = buf . get_u16_le () ; _struct . chan8_raw = buf . get_u16_le () ; _struct . port = buf . get_u8 () ; _struct . rssi = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u16_le (<span class="self">self </span>. chan1_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan2_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan3_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan4_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan5_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan6_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan7_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan8_raw) ; _tmp . put_u8 (<span class="self">self </span>. port) ; _tmp . put_u8 (<span class="self">self </span>. rssi) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RC_CHANNELS_RAW_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DATA_TRANSMISSION_HANDSHAKE_DATA { <span class="kw">pub </span>size : u32 , <span class="kw">pub </span>width : u16 , <span class="kw">pub </span>height : u16 , <span class="kw">pub </span>packets : u16 , <span class="kw">pub </span>mavtype : MavlinkDataStreamType , <span class="kw">pub </span>payload : u8 , <span class="kw">pub </span>jpg_quality : u8 , } <span class="kw">impl </span>DATA_TRANSMISSION_HANDSHAKE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">13usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ size : <span class="number">0_u32 </span>, width : <span class="number">0_u16 </span>, height : <span class="number">0_u16 </span>, packets : <span class="number">0_u16 </span>, mavtype : MavlinkDataStreamType :: DEFAULT , payload : <span class="number">0_u8 </span>, jpg_quality : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . size = buf . get_u32_le () ; _struct . width = buf . get_u16_le () ; _struct . height = buf . get_u16_le () ; _struct . packets = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavlinkDataStreamType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . payload = buf . get_u8 () ; _struct . jpg_quality = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. size) ; _tmp . put_u16_le (<span class="self">self </span>. width) ; _tmp . put_u16_le (<span class="self">self </span>. height) ; _tmp . put_u16_le (<span class="self">self </span>. packets) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. payload) ; _tmp . put_u8 (<span class="self">self </span>. jpg_quality) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DATA_TRANSMISSION_HANDSHAKE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_CAPTURE_STATUS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>image_interval : f32 , <span class="kw">pub </span>recording_time_ms : u32 , <span class="kw">pub </span>available_capacity : f32 , <span class="kw">pub </span>image_status : u8 , <span class="kw">pub </span>video_status : u8 , } <span class="kw">impl </span>CAMERA_CAPTURE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, image_interval : <span class="number">0.0_f32 </span>, recording_time_ms : <span class="number">0_u32 </span>, available_capacity : <span class="number">0.0_f32 </span>, image_status : <span class="number">0_u8 </span>, video_status : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . image_interval = buf . get_f32_le () ; _struct . recording_time_ms = buf . get_u32_le () ; _struct . available_capacity = buf . get_f32_le () ; _struct . image_status = buf . get_u8 () ; _struct . video_status = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. image_interval) ; _tmp . put_u32_le (<span class="self">self </span>. recording_time_ms) ; _tmp . put_f32_le (<span class="self">self </span>. available_capacity) ; _tmp . put_u8 (<span class="self">self </span>. image_status) ; _tmp . put_u8 (<span class="self">self </span>. video_status) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAMERA_CAPTURE_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RAW_RPM_DATA { <span class="kw">pub </span>frequency : f32 , <span class="kw">pub </span>index : u8 , } <span class="kw">impl </span>RAW_RPM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">5usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ frequency : <span class="number">0.0_f32 </span>, index : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . frequency = buf . get_f32_le () ; _struct . index = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. frequency) ; _tmp . put_u8 (<span class="self">self </span>. index) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RAW_RPM_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_RTCM_DATA_DATA { <span class="kw">pub </span>flags : u8 , <span class="kw">pub </span>len : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">180</span>] , } <span class="kw">impl </span>GPS_RTCM_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">182usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ flags : <span class="number">0_u8 </span>, len : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">180usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . flags = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. flags) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GPS_RTCM_DATA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOCAL_POSITION_NED_COV_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>ax : f32 , <span class="kw">pub </span>ay : f32 , <span class="kw">pub </span>az : f32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>covariance : [f32 ; <span class="number">45</span>] , <span class="kw">pub </span>estimator_type : MavEstimatorType , } <span class="kw">impl </span>LOCAL_POSITION_NED_COV_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">225usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, vx : <span class="number">0.0_f32 </span>, vy : <span class="number">0.0_f32 </span>, vz : <span class="number">0.0_f32 </span>, ax : <span class="number">0.0_f32 </span>, ay : <span class="number">0.0_f32 </span>, az : <span class="number">0.0_f32 </span>, covariance : [<span class="number">0.0_f32 </span>; <span class="number">45usize</span>] , estimator_type : MavEstimatorType :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . ax = buf . get_f32_le () ; _struct . ay = buf . get_f32_le () ; _struct . az = buf . get_f32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . covariance { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . estimator_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavEstimatorType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. ax) ; _tmp . put_f32_le (<span class="self">self </span>. ay) ; _tmp . put_f32_le (<span class="self">self </span>. az) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. covariance { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. estimator_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOCAL_POSITION_NED_COV_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GOPRO_GET_RESPONSE_DATA { <span class="kw">pub </span>cmd_id : GoproCommand , <span class="kw">pub </span>status : GoproRequestStatus , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>value : [u8 ; <span class="number">4</span>] , } <span class="kw">impl </span>GOPRO_GET_RESPONSE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ cmd_id : GoproCommand :: DEFAULT , status : GoproRequestStatus :: DEFAULT , value : [<span class="number">0_u8 </span>; <span class="number">4usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . cmd_id = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GoproCommand&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GoproRequestStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . value { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. cmd_id <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. value { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GOPRO_GET_RESPONSE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_SELF_ID_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>description_type : MavOdidDescType , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>description : [u8 ; <span class="number">23</span>] , } <span class="kw">impl </span>OPEN_DRONE_ID_SELF_ID_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">46usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, id_or_mac : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , description_type : MavOdidDescType :: DEFAULT , description : [<span class="number">0_u8 </span>; <span class="number">23usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . id_or_mac { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . description_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidDescType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . description { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. description_type <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. description { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OPEN_DRONE_ID_SELF_ID_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ESC_TELEMETRY_9_TO_12_DATA { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>voltage : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>current : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>totalcurrent : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>rpm : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>count : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>temperature : [u8 ; <span class="number">4</span>] , } <span class="kw">impl </span>ESC_TELEMETRY_9_TO_12_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ voltage : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , current : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , totalcurrent : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , rpm : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , count : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , temperature : [<span class="number">0_u8 </span>; <span class="number">4usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . voltage { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . current { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . totalcurrent { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . rpm { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . count { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . temperature { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. voltage { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. current { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. totalcurrent { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. rpm { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. count { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. temperature { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ESC_TELEMETRY_9_TO_12_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>POWER_STATUS_DATA { <span class="kw">pub </span>Vcc : u16 , <span class="kw">pub </span>Vservo : u16 , <span class="kw">pub </span>flags : MavPowerStatus , } <span class="kw">impl </span>POWER_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ Vcc : <span class="number">0_u16 </span>, Vservo : <span class="number">0_u16 </span>, flags : MavPowerStatus :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . Vcc = buf . get_u16_le () ; _struct . Vservo = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = MavPowerStatus :: from_bits (tmp &amp; MavPowerStatus :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavPowerStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. Vcc) ; _tmp . put_u16_le (<span class="self">self </span>. Vservo) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>POWER_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>FILE_TRANSFER_PROTOCOL_DATA { <span class="kw">pub </span>target_network : u8 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>payload : [u8 ; <span class="number">251</span>] , } <span class="kw">impl </span>FILE_TRANSFER_PROTOCOL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">254usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_network : <span class="number">0_u8 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, payload : [<span class="number">0_u8 </span>; <span class="number">251usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_network = buf . get_u8 () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . payload { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_network) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. payload { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>FILE_TRANSFER_PROTOCOL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_RTK_DATA { <span class="kw">pub </span>time_last_baseline_ms : u32 , <span class="kw">pub </span>tow : u32 , <span class="kw">pub </span>baseline_a_mm : i32 , <span class="kw">pub </span>baseline_b_mm : i32 , <span class="kw">pub </span>baseline_c_mm : i32 , <span class="kw">pub </span>accuracy : u32 , <span class="kw">pub </span>iar_num_hypotheses : i32 , <span class="kw">pub </span>wn : u16 , <span class="kw">pub </span>rtk_receiver_id : u8 , <span class="kw">pub </span>rtk_health : u8 , <span class="kw">pub </span>rtk_rate : u8 , <span class="kw">pub </span>nsats : u8 , <span class="kw">pub </span>baseline_coords_type : RtkBaselineCoordinateSystem , } <span class="kw">impl </span>GPS_RTK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">35usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_last_baseline_ms : <span class="number">0_u32 </span>, tow : <span class="number">0_u32 </span>, baseline_a_mm : <span class="number">0_i32 </span>, baseline_b_mm : <span class="number">0_i32 </span>, baseline_c_mm : <span class="number">0_i32 </span>, accuracy : <span class="number">0_u32 </span>, iar_num_hypotheses : <span class="number">0_i32 </span>, wn : <span class="number">0_u16 </span>, rtk_receiver_id : <span class="number">0_u8 </span>, rtk_health : <span class="number">0_u8 </span>, rtk_rate : <span class="number">0_u8 </span>, nsats : <span class="number">0_u8 </span>, baseline_coords_type : RtkBaselineCoordinateSystem :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_last_baseline_ms = buf . get_u32_le () ; _struct . tow = buf . get_u32_le () ; _struct . baseline_a_mm = buf . get_i32_le () ; _struct . baseline_b_mm = buf . get_i32_le () ; _struct . baseline_c_mm = buf . get_i32_le () ; _struct . accuracy = buf . get_u32_le () ; _struct . iar_num_hypotheses = buf . get_i32_le () ; _struct . wn = buf . get_u16_le () ; _struct . rtk_receiver_id = buf . get_u8 () ; _struct . rtk_health = buf . get_u8 () ; _struct . rtk_rate = buf . get_u8 () ; _struct . nsats = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . baseline_coords_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;RtkBaselineCoordinateSystem&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_last_baseline_ms) ; _tmp . put_u32_le (<span class="self">self </span>. tow) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_a_mm) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_b_mm) ; _tmp . put_i32_le (<span class="self">self </span>. baseline_c_mm) ; _tmp . put_u32_le (<span class="self">self </span>. accuracy) ; _tmp . put_i32_le (<span class="self">self </span>. iar_num_hypotheses) ; _tmp . put_u16_le (<span class="self">self </span>. wn) ; _tmp . put_u8 (<span class="self">self </span>. rtk_receiver_id) ; _tmp . put_u8 (<span class="self">self </span>. rtk_health) ; _tmp . put_u8 (<span class="self">self </span>. rtk_rate) ; _tmp . put_u8 (<span class="self">self </span>. nsats) ; _tmp . put_u8 (<span class="self">self </span>. baseline_coords_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GPS_RTK_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_CLEAR_ALL_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_CLEAR_ALL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_CLEAR_ALL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_REQUEST_DATA { <span class="kw">pub </span>seq : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_REQUEST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ seq : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seq = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_REQUEST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_AUTHENTICATION_DATA { <span class="kw">pub </span>timestamp : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>authentication_type : MavOdidAuthType , <span class="kw">pub </span>data_page : u8 , <span class="kw">pub </span>last_page_index : u8 , <span class="kw">pub </span>length : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>authentication_data : [u8 ; <span class="number">23</span>] , } <span class="kw">impl </span>OPEN_DRONE_ID_AUTHENTICATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ timestamp : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, id_or_mac : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , authentication_type : MavOdidAuthType :: DEFAULT , data_page : <span class="number">0_u8 </span>, last_page_index : <span class="number">0_u8 </span>, length : <span class="number">0_u8 </span>, authentication_data : [<span class="number">0_u8 </span>; <span class="number">23usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . timestamp = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . id_or_mac { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . authentication_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidAuthType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . data_page = buf . get_u8 () ; _struct . last_page_index = buf . get_u8 () ; _struct . length = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . authentication_data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. timestamp) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. authentication_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. data_page) ; _tmp . put_u8 (<span class="self">self </span>. last_page_index) ; _tmp . put_u8 (<span class="self">self </span>. length) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. authentication_data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OPEN_DRONE_ID_AUTHENTICATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>FENCE_FETCH_POINT_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>idx : u8 , } <span class="kw">impl </span>FENCE_FETCH_POINT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, idx : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . idx = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. idx) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>FENCE_FETCH_POINT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GOPRO_SET_REQUEST_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>cmd_id : GoproCommand , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>value : [u8 ; <span class="number">4</span>] , } <span class="kw">impl </span>GOPRO_SET_REQUEST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">7usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, cmd_id : GoproCommand :: DEFAULT , value : [<span class="number">0_u8 </span>; <span class="number">4usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . cmd_id = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GoproCommand&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . value { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. cmd_id <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. value { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GOPRO_SET_REQUEST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_ACTUATOR_CONTROLS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>flags : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>controls : [f32 ; <span class="number">16</span>] , <span class="kw">pub </span>mode : MavModeFlag , } <span class="kw">impl </span>HIL_ACTUATOR_CONTROLS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">81usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, flags : <span class="number">0_u64 </span>, controls : [<span class="number">0.0_f32 </span>; <span class="number">16usize</span>] , mode : MavModeFlag :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . flags = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . controls { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mode = MavModeFlag :: from_bits (tmp &amp; MavModeFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavModeFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u64_le (<span class="self">self </span>. flags) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. controls { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. mode . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HIL_ACTUATOR_CONTROLS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OBSTACLE_DISTANCE_3D_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>min_distance : f32 , <span class="kw">pub </span>max_distance : f32 , <span class="kw">pub </span>obstacle_id : u16 , <span class="kw">pub </span>sensor_type : MavDistanceSensor , <span class="kw">pub </span>frame : MavFrame , } <span class="kw">impl </span>OBSTACLE_DISTANCE_3D_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, min_distance : <span class="number">0.0_f32 </span>, max_distance : <span class="number">0.0_f32 </span>, obstacle_id : <span class="number">0_u16 </span>, sensor_type : MavDistanceSensor :: DEFAULT , frame : MavFrame :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . min_distance = buf . get_f32_le () ; _struct . max_distance = buf . get_f32_le () ; _struct . obstacle_id = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . sensor_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavDistanceSensor&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. min_distance) ; _tmp . put_f32_le (<span class="self">self </span>. max_distance) ; _tmp . put_u16_le (<span class="self">self </span>. obstacle_id) ; _tmp . put_u8 (<span class="self">self </span>. sensor_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OBSTACLE_DISTANCE_3D_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ATT_POS_MOCAP_DATA { <span class="kw">pub </span>time_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , } <span class="kw">impl </span>ATT_POS_MOCAP_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">36usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ATT_POS_MOCAP_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_SYSTEM_UPDATE_DATA { <span class="kw">pub </span>operator_latitude : i32 , <span class="kw">pub </span>operator_longitude : i32 , <span class="kw">pub </span>operator_altitude_geo : f32 , <span class="kw">pub </span>timestamp : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>OPEN_DRONE_ID_SYSTEM_UPDATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ operator_latitude : <span class="number">0_i32 </span>, operator_longitude : <span class="number">0_i32 </span>, operator_altitude_geo : <span class="number">0.0_f32 </span>, timestamp : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . operator_latitude = buf . get_i32_le () ; _struct . operator_longitude = buf . get_i32_le () ; _struct . operator_altitude_geo = buf . get_f32_le () ; _struct . timestamp = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. operator_latitude) ; _tmp . put_i32_le (<span class="self">self </span>. operator_longitude) ; _tmp . put_f32_le (<span class="self">self </span>. operator_altitude_geo) ; _tmp . put_u32_le (<span class="self">self </span>. timestamp) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OPEN_DRONE_ID_SYSTEM_UPDATE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_POSITION_TARGET_GLOBAL_INT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>lat_int : i32 , <span class="kw">pub </span>lon_int : i32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>afx : f32 , <span class="kw">pub </span>afy : f32 , <span class="kw">pub </span>afz : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>type_mask : PositionTargetTypemask , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>coordinate_frame : MavFrame , } <span class="kw">impl </span>SET_POSITION_TARGET_GLOBAL_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, lat_int : <span class="number">0_i32 </span>, lon_int : <span class="number">0_i32 </span>, alt : <span class="number">0.0_f32 </span>, vx : <span class="number">0.0_f32 </span>, vy : <span class="number">0.0_f32 </span>, vz : <span class="number">0.0_f32 </span>, afx : <span class="number">0.0_f32 </span>, afy : <span class="number">0.0_f32 </span>, afz : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, yaw_rate : <span class="number">0.0_f32 </span>, type_mask : PositionTargetTypemask :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, coordinate_frame : MavFrame :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . lat_int = buf . get_i32_le () ; _struct . lon_int = buf . get_i32_le () ; _struct . alt = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . afx = buf . get_f32_le () ; _struct . afy = buf . get_f32_le () ; _struct . afz = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . type_mask = PositionTargetTypemask :: from_bits (tmp &amp; PositionTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;PositionTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . coordinate_frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat_int) ; _tmp . put_i32_le (<span class="self">self </span>. lon_int) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. afx) ; _tmp . put_f32_le (<span class="self">self </span>. afy) ; _tmp . put_f32_le (<span class="self">self </span>. afz) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u16_le (<span class="self">self </span>. type_mask . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. coordinate_frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SET_POSITION_TARGET_GLOBAL_INT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RESOURCE_REQUEST_DATA { <span class="kw">pub </span>request_id : u8 , <span class="kw">pub </span>uri_type : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>uri : [u8 ; <span class="number">120</span>] , <span class="kw">pub </span>transfer_type : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>storage : [u8 ; <span class="number">120</span>] , } <span class="kw">impl </span>RESOURCE_REQUEST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">243usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ request_id : <span class="number">0_u8 </span>, uri_type : <span class="number">0_u8 </span>, uri : [<span class="number">0_u8 </span>; <span class="number">120usize</span>] , transfer_type : <span class="number">0_u8 </span>, storage : [<span class="number">0_u8 </span>; <span class="number">120usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . request_id = buf . get_u8 () ; _struct . uri_type = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . uri { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } _struct . transfer_type = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . storage { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. request_id) ; _tmp . put_u8 (<span class="self">self </span>. uri_type) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. uri { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. transfer_type) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. storage { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RESOURCE_REQUEST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MAG_CAL_REPORT_DATA { <span class="kw">pub </span>fitness : f32 , <span class="kw">pub </span>ofs_x : f32 , <span class="kw">pub </span>ofs_y : f32 , <span class="kw">pub </span>ofs_z : f32 , <span class="kw">pub </span>diag_x : f32 , <span class="kw">pub </span>diag_y : f32 , <span class="kw">pub </span>diag_z : f32 , <span class="kw">pub </span>offdiag_x : f32 , <span class="kw">pub </span>offdiag_y : f32 , <span class="kw">pub </span>offdiag_z : f32 , <span class="kw">pub </span>compass_id : u8 , <span class="kw">pub </span>cal_mask : u8 , <span class="kw">pub </span>cal_status : MagCalStatus , <span class="kw">pub </span>autosaved : u8 , } <span class="kw">impl </span>MAG_CAL_REPORT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ fitness : <span class="number">0.0_f32 </span>, ofs_x : <span class="number">0.0_f32 </span>, ofs_y : <span class="number">0.0_f32 </span>, ofs_z : <span class="number">0.0_f32 </span>, diag_x : <span class="number">0.0_f32 </span>, diag_y : <span class="number">0.0_f32 </span>, diag_z : <span class="number">0.0_f32 </span>, offdiag_x : <span class="number">0.0_f32 </span>, offdiag_y : <span class="number">0.0_f32 </span>, offdiag_z : <span class="number">0.0_f32 </span>, compass_id : <span class="number">0_u8 </span>, cal_mask : <span class="number">0_u8 </span>, cal_status : MagCalStatus :: DEFAULT , autosaved : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . fitness = buf . get_f32_le () ; _struct . ofs_x = buf . get_f32_le () ; _struct . ofs_y = buf . get_f32_le () ; _struct . ofs_z = buf . get_f32_le () ; _struct . diag_x = buf . get_f32_le () ; _struct . diag_y = buf . get_f32_le () ; _struct . diag_z = buf . get_f32_le () ; _struct . offdiag_x = buf . get_f32_le () ; _struct . offdiag_y = buf . get_f32_le () ; _struct . offdiag_z = buf . get_f32_le () ; _struct . compass_id = buf . get_u8 () ; _struct . cal_mask = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . cal_status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MagCalStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . autosaved = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. fitness) ; _tmp . put_f32_le (<span class="self">self </span>. ofs_x) ; _tmp . put_f32_le (<span class="self">self </span>. ofs_y) ; _tmp . put_f32_le (<span class="self">self </span>. ofs_z) ; _tmp . put_f32_le (<span class="self">self </span>. diag_x) ; _tmp . put_f32_le (<span class="self">self </span>. diag_y) ; _tmp . put_f32_le (<span class="self">self </span>. diag_z) ; _tmp . put_f32_le (<span class="self">self </span>. offdiag_x) ; _tmp . put_f32_le (<span class="self">self </span>. offdiag_y) ; _tmp . put_f32_le (<span class="self">self </span>. offdiag_z) ; _tmp . put_u8 (<span class="self">self </span>. compass_id) ; _tmp . put_u8 (<span class="self">self </span>. cal_mask) ; _tmp . put_u8 (<span class="self">self </span>. cal_status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. autosaved) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MAG_CAL_REPORT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_RC_INPUTS_RAW_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>chan1_raw : u16 , <span class="kw">pub </span>chan2_raw : u16 , <span class="kw">pub </span>chan3_raw : u16 , <span class="kw">pub </span>chan4_raw : u16 , <span class="kw">pub </span>chan5_raw : u16 , <span class="kw">pub </span>chan6_raw : u16 , <span class="kw">pub </span>chan7_raw : u16 , <span class="kw">pub </span>chan8_raw : u16 , <span class="kw">pub </span>chan9_raw : u16 , <span class="kw">pub </span>chan10_raw : u16 , <span class="kw">pub </span>chan11_raw : u16 , <span class="kw">pub </span>chan12_raw : u16 , <span class="kw">pub </span>rssi : u8 , } <span class="kw">impl </span>HIL_RC_INPUTS_RAW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">33usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, chan1_raw : <span class="number">0_u16 </span>, chan2_raw : <span class="number">0_u16 </span>, chan3_raw : <span class="number">0_u16 </span>, chan4_raw : <span class="number">0_u16 </span>, chan5_raw : <span class="number">0_u16 </span>, chan6_raw : <span class="number">0_u16 </span>, chan7_raw : <span class="number">0_u16 </span>, chan8_raw : <span class="number">0_u16 </span>, chan9_raw : <span class="number">0_u16 </span>, chan10_raw : <span class="number">0_u16 </span>, chan11_raw : <span class="number">0_u16 </span>, chan12_raw : <span class="number">0_u16 </span>, rssi : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . chan1_raw = buf . get_u16_le () ; _struct . chan2_raw = buf . get_u16_le () ; _struct . chan3_raw = buf . get_u16_le () ; _struct . chan4_raw = buf . get_u16_le () ; _struct . chan5_raw = buf . get_u16_le () ; _struct . chan6_raw = buf . get_u16_le () ; _struct . chan7_raw = buf . get_u16_le () ; _struct . chan8_raw = buf . get_u16_le () ; _struct . chan9_raw = buf . get_u16_le () ; _struct . chan10_raw = buf . get_u16_le () ; _struct . chan11_raw = buf . get_u16_le () ; _struct . chan12_raw = buf . get_u16_le () ; _struct . rssi = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u16_le (<span class="self">self </span>. chan1_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan2_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan3_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan4_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan5_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan6_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan7_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan8_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan9_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan10_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan11_raw) ; _tmp . put_u16_le (<span class="self">self </span>. chan12_raw) ; _tmp . put_u8 (<span class="self">self </span>. rssi) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HIL_RC_INPUTS_RAW_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_REQUEST_PARTIAL_LIST_DATA { <span class="kw">pub </span>start_index : i16 , <span class="kw">pub </span>end_index : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_REQUEST_PARTIAL_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ start_index : <span class="number">0_i16 </span>, end_index : <span class="number">0_i16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . start_index = buf . get_i16_le () ; _struct . end_index = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. start_index) ; _tmp . put_i16_le (<span class="self">self </span>. end_index) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_REQUEST_PARTIAL_LIST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HOME_POSITION_DATA { <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>altitude : i32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>approach_x : f32 , <span class="kw">pub </span>approach_y : f32 , <span class="kw">pub </span>approach_z : f32 , } <span class="kw">impl </span>HOME_POSITION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">52usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ latitude : <span class="number">0_i32 </span>, longitude : <span class="number">0_i32 </span>, altitude : <span class="number">0_i32 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , approach_x : <span class="number">0.0_f32 </span>, approach_y : <span class="number">0.0_f32 </span>, approach_z : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . altitude = buf . get_i32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . approach_x = buf . get_f32_le () ; _struct . approach_y = buf . get_f32_le () ; _struct . approach_z = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_i32_le (<span class="self">self </span>. altitude) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. approach_x) ; _tmp . put_f32_le (<span class="self">self </span>. approach_y) ; _tmp . put_f32_le (<span class="self">self </span>. approach_z) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HOME_POSITION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RAW_PRESSURE_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>press_abs : i16 , <span class="kw">pub </span>press_diff1 : i16 , <span class="kw">pub </span>press_diff2 : i16 , <span class="kw">pub </span>temperature : i16 , } <span class="kw">impl </span>RAW_PRESSURE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">16usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, press_abs : <span class="number">0_i16 </span>, press_diff1 : <span class="number">0_i16 </span>, press_diff2 : <span class="number">0_i16 </span>, temperature : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . press_abs = buf . get_i16_le () ; _struct . press_diff1 = buf . get_i16_le () ; _struct . press_diff2 = buf . get_i16_le () ; _struct . temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i16_le (<span class="self">self </span>. press_abs) ; _tmp . put_i16_le (<span class="self">self </span>. press_diff1) ; _tmp . put_i16_le (<span class="self">self </span>. press_diff2) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RAW_PRESSURE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DIGICAM_CONTROL_DATA { <span class="kw">pub </span>extra_value : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>session : u8 , <span class="kw">pub </span>zoom_pos : u8 , <span class="kw">pub </span>zoom_step : i8 , <span class="kw">pub </span>focus_lock : u8 , <span class="kw">pub </span>shot : u8 , <span class="kw">pub </span>command_id : u8 , <span class="kw">pub </span>extra_param : u8 , } <span class="kw">impl </span>DIGICAM_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">13usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ extra_value : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, session : <span class="number">0_u8 </span>, zoom_pos : <span class="number">0_u8 </span>, zoom_step : <span class="number">0_i8 </span>, focus_lock : <span class="number">0_u8 </span>, shot : <span class="number">0_u8 </span>, command_id : <span class="number">0_u8 </span>, extra_param : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . extra_value = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . session = buf . get_u8 () ; _struct . zoom_pos = buf . get_u8 () ; _struct . zoom_step = buf . get_i8 () ; _struct . focus_lock = buf . get_u8 () ; _struct . shot = buf . get_u8 () ; _struct . command_id = buf . get_u8 () ; _struct . extra_param = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. extra_value) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. session) ; _tmp . put_u8 (<span class="self">self </span>. zoom_pos) ; _tmp . put_i8 (<span class="self">self </span>. zoom_step) ; _tmp . put_u8 (<span class="self">self </span>. focus_lock) ; _tmp . put_u8 (<span class="self">self </span>. shot) ; _tmp . put_u8 (<span class="self">self </span>. command_id) ; _tmp . put_u8 (<span class="self">self </span>. extra_param) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DIGICAM_CONTROL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_CURRENT_DATA { <span class="kw">pub </span>seq : u16 , } <span class="kw">impl </span>MISSION_CURRENT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ seq : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seq = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_CURRENT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ESC_TELEMETRY_1_TO_4_DATA { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>voltage : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>current : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>totalcurrent : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>rpm : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>count : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>temperature : [u8 ; <span class="number">4</span>] , } <span class="kw">impl </span>ESC_TELEMETRY_1_TO_4_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ voltage : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , current : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , totalcurrent : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , rpm : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , count : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , temperature : [<span class="number">0_u8 </span>; <span class="number">4usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . voltage { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . current { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . totalcurrent { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . rpm { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . count { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . temperature { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. voltage { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. current { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. totalcurrent { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. rpm { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. count { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. temperature { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ESC_TELEMETRY_1_TO_4_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_LOCATION_DATA { <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>altitude_barometric : f32 , <span class="kw">pub </span>altitude_geodetic : f32 , <span class="kw">pub </span>height : f32 , <span class="kw">pub </span>timestamp : f32 , <span class="kw">pub </span>direction : u16 , <span class="kw">pub </span>speed_horizontal : u16 , <span class="kw">pub </span>speed_vertical : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>status : MavOdidStatus , <span class="kw">pub </span>height_reference : MavOdidHeightRef , <span class="kw">pub </span>horizontal_accuracy : MavOdidHorAcc , <span class="kw">pub </span>vertical_accuracy : MavOdidVerAcc , <span class="kw">pub </span>barometer_accuracy : MavOdidVerAcc , <span class="kw">pub </span>speed_accuracy : MavOdidSpeedAcc , <span class="kw">pub </span>timestamp_accuracy : MavOdidTimeAcc , } <span class="kw">impl </span>OPEN_DRONE_ID_LOCATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">59usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ latitude : <span class="number">0_i32 </span>, longitude : <span class="number">0_i32 </span>, altitude_barometric : <span class="number">0.0_f32 </span>, altitude_geodetic : <span class="number">0.0_f32 </span>, height : <span class="number">0.0_f32 </span>, timestamp : <span class="number">0.0_f32 </span>, direction : <span class="number">0_u16 </span>, speed_horizontal : <span class="number">0_u16 </span>, speed_vertical : <span class="number">0_i16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, id_or_mac : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , status : MavOdidStatus :: DEFAULT , height_reference : MavOdidHeightRef :: DEFAULT , horizontal_accuracy : MavOdidHorAcc :: DEFAULT , vertical_accuracy : MavOdidVerAcc :: DEFAULT , barometer_accuracy : MavOdidVerAcc :: DEFAULT , speed_accuracy : MavOdidSpeedAcc :: DEFAULT , timestamp_accuracy : MavOdidTimeAcc :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . altitude_barometric = buf . get_f32_le () ; _struct . altitude_geodetic = buf . get_f32_le () ; _struct . height = buf . get_f32_le () ; _struct . timestamp = buf . get_f32_le () ; _struct . direction = buf . get_u16_le () ; _struct . speed_horizontal = buf . get_u16_le () ; _struct . speed_vertical = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . id_or_mac { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . height_reference = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidHeightRef&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . horizontal_accuracy = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidHorAcc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . vertical_accuracy = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidVerAcc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . barometer_accuracy = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidVerAcc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . speed_accuracy = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidSpeedAcc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . timestamp_accuracy = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidTimeAcc&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_barometric) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_geodetic) ; _tmp . put_f32_le (<span class="self">self </span>. height) ; _tmp . put_f32_le (<span class="self">self </span>. timestamp) ; _tmp . put_u16_le (<span class="self">self </span>. direction) ; _tmp . put_u16_le (<span class="self">self </span>. speed_horizontal) ; _tmp . put_i16_le (<span class="self">self </span>. speed_vertical) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. height_reference <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. horizontal_accuracy <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. vertical_accuracy <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. barometer_accuracy <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. speed_accuracy <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. timestamp_accuracy <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OPEN_DRONE_ID_LOCATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MAG_CAL_PROGRESS_DATA { <span class="kw">pub </span>direction_x : f32 , <span class="kw">pub </span>direction_y : f32 , <span class="kw">pub </span>direction_z : f32 , <span class="kw">pub </span>compass_id : u8 , <span class="kw">pub </span>cal_mask : u8 , <span class="kw">pub </span>cal_status : MagCalStatus , <span class="kw">pub </span>attempt : u8 , <span class="kw">pub </span>completion_pct : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>completion_mask : [u8 ; <span class="number">10</span>] , } <span class="kw">impl </span>MAG_CAL_PROGRESS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">27usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ direction_x : <span class="number">0.0_f32 </span>, direction_y : <span class="number">0.0_f32 </span>, direction_z : <span class="number">0.0_f32 </span>, compass_id : <span class="number">0_u8 </span>, cal_mask : <span class="number">0_u8 </span>, cal_status : MagCalStatus :: DEFAULT , attempt : <span class="number">0_u8 </span>, completion_pct : <span class="number">0_u8 </span>, completion_mask : [<span class="number">0_u8 </span>; <span class="number">10usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . direction_x = buf . get_f32_le () ; _struct . direction_y = buf . get_f32_le () ; _struct . direction_z = buf . get_f32_le () ; _struct . compass_id = buf . get_u8 () ; _struct . cal_mask = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . cal_status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MagCalStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . attempt = buf . get_u8 () ; _struct . completion_pct = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . completion_mask { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. direction_x) ; _tmp . put_f32_le (<span class="self">self </span>. direction_y) ; _tmp . put_f32_le (<span class="self">self </span>. direction_z) ; _tmp . put_u8 (<span class="self">self </span>. compass_id) ; _tmp . put_u8 (<span class="self">self </span>. cal_mask) ; _tmp . put_u8 (<span class="self">self </span>. cal_status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. attempt) ; _tmp . put_u8 (<span class="self">self </span>. completion_pct) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. completion_mask { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MAG_CAL_PROGRESS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMPONENT_METADATA_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>file_crc : u32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>uri : [u8 ; <span class="number">100</span>] , } <span class="kw">impl </span>COMPONENT_METADATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">108usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, file_crc : <span class="number">0_u32 </span>, uri : [<span class="number">0_u8 </span>; <span class="number">100usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . file_crc = buf . get_u32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . uri { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. file_crc) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. uri { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>COMPONENT_METADATA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UTM_GLOBAL_POSITION_DATA { <span class="kw">pub </span>time : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>relative_alt : i32 , <span class="kw">pub </span>next_lat : i32 , <span class="kw">pub </span>next_lon : i32 , <span class="kw">pub </span>next_alt : i32 , <span class="kw">pub </span>vx : i16 , <span class="kw">pub </span>vy : i16 , <span class="kw">pub </span>vz : i16 , <span class="kw">pub </span>h_acc : u16 , <span class="kw">pub </span>v_acc : u16 , <span class="kw">pub </span>vel_acc : u16 , <span class="kw">pub </span>update_rate : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>uas_id : [u8 ; <span class="number">18</span>] , <span class="kw">pub </span>flight_state : UtmFlightState , <span class="kw">pub </span>flags : UtmDataAvailFlags , } <span class="kw">impl </span>UTM_GLOBAL_POSITION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">70usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time : <span class="number">0_u64 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0_i32 </span>, relative_alt : <span class="number">0_i32 </span>, next_lat : <span class="number">0_i32 </span>, next_lon : <span class="number">0_i32 </span>, next_alt : <span class="number">0_i32 </span>, vx : <span class="number">0_i16 </span>, vy : <span class="number">0_i16 </span>, vz : <span class="number">0_i16 </span>, h_acc : <span class="number">0_u16 </span>, v_acc : <span class="number">0_u16 </span>, vel_acc : <span class="number">0_u16 </span>, update_rate : <span class="number">0_u16 </span>, uas_id : [<span class="number">0_u8 </span>; <span class="number">18usize</span>] , flight_state : UtmFlightState :: DEFAULT , flags : UtmDataAvailFlags :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . relative_alt = buf . get_i32_le () ; _struct . next_lat = buf . get_i32_le () ; _struct . next_lon = buf . get_i32_le () ; _struct . next_alt = buf . get_i32_le () ; _struct . vx = buf . get_i16_le () ; _struct . vy = buf . get_i16_le () ; _struct . vz = buf . get_i16_le () ; _struct . h_acc = buf . get_u16_le () ; _struct . v_acc = buf . get_u16_le () ; _struct . vel_acc = buf . get_u16_le () ; _struct . update_rate = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . uas_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . flight_state = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UtmFlightState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . flags = UtmDataAvailFlags :: from_bits (tmp &amp; UtmDataAvailFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;UtmDataAvailFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i32_le (<span class="self">self </span>. relative_alt) ; _tmp . put_i32_le (<span class="self">self </span>. next_lat) ; _tmp . put_i32_le (<span class="self">self </span>. next_lon) ; _tmp . put_i32_le (<span class="self">self </span>. next_alt) ; _tmp . put_i16_le (<span class="self">self </span>. vx) ; _tmp . put_i16_le (<span class="self">self </span>. vy) ; _tmp . put_i16_le (<span class="self">self </span>. vz) ; _tmp . put_u16_le (<span class="self">self </span>. h_acc) ; _tmp . put_u16_le (<span class="self">self </span>. v_acc) ; _tmp . put_u16_le (<span class="self">self </span>. vel_acc) ; _tmp . put_u16_le (<span class="self">self </span>. update_rate) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. uas_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. flight_state <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. flags . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>UTM_GLOBAL_POSITION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>POSITION_TARGET_LOCAL_NED_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>afx : f32 , <span class="kw">pub </span>afy : f32 , <span class="kw">pub </span>afz : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>type_mask : PositionTargetTypemask , <span class="kw">pub </span>coordinate_frame : MavFrame , } <span class="kw">impl </span>POSITION_TARGET_LOCAL_NED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">51usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, vx : <span class="number">0.0_f32 </span>, vy : <span class="number">0.0_f32 </span>, vz : <span class="number">0.0_f32 </span>, afx : <span class="number">0.0_f32 </span>, afy : <span class="number">0.0_f32 </span>, afz : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, yaw_rate : <span class="number">0.0_f32 </span>, type_mask : PositionTargetTypemask :: DEFAULT , coordinate_frame : MavFrame :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . afx = buf . get_f32_le () ; _struct . afy = buf . get_f32_le () ; _struct . afz = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . type_mask = PositionTargetTypemask :: from_bits (tmp &amp; PositionTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;PositionTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . coordinate_frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. afx) ; _tmp . put_f32_le (<span class="self">self </span>. afy) ; _tmp . put_f32_le (<span class="self">self </span>. afz) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u16_le (<span class="self">self </span>. type_mask . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. coordinate_frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>POSITION_TARGET_LOCAL_NED_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_DEVICE_SET_ATTITUDE_DATA { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>angular_velocity_x : f32 , <span class="kw">pub </span>angular_velocity_y : f32 , <span class="kw">pub </span>angular_velocity_z : f32 , <span class="kw">pub </span>flags : GimbalDeviceFlags , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>GIMBAL_DEVICE_SET_ATTITUDE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , angular_velocity_x : <span class="number">0.0_f32 </span>, angular_velocity_y : <span class="number">0.0_f32 </span>, angular_velocity_z : <span class="number">0.0_f32 </span>, flags : GimbalDeviceFlags :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . angular_velocity_x = buf . get_f32_le () ; _struct . angular_velocity_y = buf . get_f32_le () ; _struct . angular_velocity_z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = GimbalDeviceFlags :: from_bits (tmp &amp; GimbalDeviceFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GimbalDeviceFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_x) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_y) ; _tmp . put_f32_le (<span class="self">self </span>. angular_velocity_z) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GIMBAL_DEVICE_SET_ATTITUDE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VISION_POSITION_DELTA_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>time_delta_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>angle_delta : [f32 ; <span class="number">3</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>position_delta : [f32 ; <span class="number">3</span>] , <span class="kw">pub </span>confidence : f32 , } <span class="kw">impl </span>VISION_POSITION_DELTA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, time_delta_usec : <span class="number">0_u64 </span>, angle_delta : [<span class="number">0.0_f32 </span>; <span class="number">3usize</span>] , position_delta : [<span class="number">0.0_f32 </span>; <span class="number">3usize</span>] , confidence : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . time_delta_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . angle_delta { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . position_delta { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . confidence = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u64_le (<span class="self">self </span>. time_delta_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. angle_delta { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. position_delta { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. confidence) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>VISION_POSITION_DELTA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIGH_LATENCY_DATA { <span class="kw">pub </span>custom_mode : u32 , <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>roll : i16 , <span class="kw">pub </span>pitch : i16 , <span class="kw">pub </span>heading : u16 , <span class="kw">pub </span>heading_sp : i16 , <span class="kw">pub </span>altitude_amsl : i16 , <span class="kw">pub </span>altitude_sp : i16 , <span class="kw">pub </span>wp_distance : u16 , <span class="kw">pub </span>base_mode : MavModeFlag , <span class="kw">pub </span>landed_state : MavLandedState , <span class="kw">pub </span>throttle : i8 , <span class="kw">pub </span>airspeed : u8 , <span class="kw">pub </span>airspeed_sp : u8 , <span class="kw">pub </span>groundspeed : u8 , <span class="kw">pub </span>climb_rate : i8 , <span class="kw">pub </span>gps_nsat : u8 , <span class="kw">pub </span>gps_fix_type : GpsFixType , <span class="kw">pub </span>battery_remaining : u8 , <span class="kw">pub </span>temperature : i8 , <span class="kw">pub </span>temperature_air : i8 , <span class="kw">pub </span>failsafe : u8 , <span class="kw">pub </span>wp_num : u8 , } <span class="kw">impl </span>HIGH_LATENCY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">40usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ custom_mode : <span class="number">0_u32 </span>, latitude : <span class="number">0_i32 </span>, longitude : <span class="number">0_i32 </span>, roll : <span class="number">0_i16 </span>, pitch : <span class="number">0_i16 </span>, heading : <span class="number">0_u16 </span>, heading_sp : <span class="number">0_i16 </span>, altitude_amsl : <span class="number">0_i16 </span>, altitude_sp : <span class="number">0_i16 </span>, wp_distance : <span class="number">0_u16 </span>, base_mode : MavModeFlag :: DEFAULT , landed_state : MavLandedState :: DEFAULT , throttle : <span class="number">0_i8 </span>, airspeed : <span class="number">0_u8 </span>, airspeed_sp : <span class="number">0_u8 </span>, groundspeed : <span class="number">0_u8 </span>, climb_rate : <span class="number">0_i8 </span>, gps_nsat : <span class="number">0_u8 </span>, gps_fix_type : GpsFixType :: DEFAULT , battery_remaining : <span class="number">0_u8 </span>, temperature : <span class="number">0_i8 </span>, temperature_air : <span class="number">0_i8 </span>, failsafe : <span class="number">0_u8 </span>, wp_num : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . custom_mode = buf . get_u32_le () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . roll = buf . get_i16_le () ; _struct . pitch = buf . get_i16_le () ; _struct . heading = buf . get_u16_le () ; _struct . heading_sp = buf . get_i16_le () ; _struct . altitude_amsl = buf . get_i16_le () ; _struct . altitude_sp = buf . get_i16_le () ; _struct . wp_distance = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . base_mode = MavModeFlag :: from_bits (tmp &amp; MavModeFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavModeFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . landed_state = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavLandedState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . throttle = buf . get_i8 () ; _struct . airspeed = buf . get_u8 () ; _struct . airspeed_sp = buf . get_u8 () ; _struct . groundspeed = buf . get_u8 () ; _struct . climb_rate = buf . get_i8 () ; _struct . gps_nsat = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . gps_fix_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GpsFixType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . battery_remaining = buf . get_u8 () ; _struct . temperature = buf . get_i8 () ; _struct . temperature_air = buf . get_i8 () ; _struct . failsafe = buf . get_u8 () ; _struct . wp_num = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. custom_mode) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_i16_le (<span class="self">self </span>. roll) ; _tmp . put_i16_le (<span class="self">self </span>. pitch) ; _tmp . put_u16_le (<span class="self">self </span>. heading) ; _tmp . put_i16_le (<span class="self">self </span>. heading_sp) ; _tmp . put_i16_le (<span class="self">self </span>. altitude_amsl) ; _tmp . put_i16_le (<span class="self">self </span>. altitude_sp) ; _tmp . put_u16_le (<span class="self">self </span>. wp_distance) ; _tmp . put_u8 (<span class="self">self </span>. base_mode . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. landed_state <span class="kw">as </span>u8) ; _tmp . put_i8 (<span class="self">self </span>. throttle) ; _tmp . put_u8 (<span class="self">self </span>. airspeed) ; _tmp . put_u8 (<span class="self">self </span>. airspeed_sp) ; _tmp . put_u8 (<span class="self">self </span>. groundspeed) ; _tmp . put_i8 (<span class="self">self </span>. climb_rate) ; _tmp . put_u8 (<span class="self">self </span>. gps_nsat) ; _tmp . put_u8 (<span class="self">self </span>. gps_fix_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. battery_remaining) ; _tmp . put_i8 (<span class="self">self </span>. temperature) ; _tmp . put_i8 (<span class="self">self </span>. temperature_air) ; _tmp . put_u8 (<span class="self">self </span>. failsafe) ; _tmp . put_u8 (<span class="self">self </span>. wp_num) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HIGH_LATENCY_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TERRAIN_REPORT_DATA { <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>terrain_height : f32 , <span class="kw">pub </span>current_height : f32 , <span class="kw">pub </span>spacing : u16 , <span class="kw">pub </span>pending : u16 , <span class="kw">pub </span>loaded : u16 , } <span class="kw">impl </span>TERRAIN_REPORT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, terrain_height : <span class="number">0.0_f32 </span>, current_height : <span class="number">0.0_f32 </span>, spacing : <span class="number">0_u16 </span>, pending : <span class="number">0_u16 </span>, loaded : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . terrain_height = buf . get_f32_le () ; _struct . current_height = buf . get_f32_le () ; _struct . spacing = buf . get_u16_le () ; _struct . pending = buf . get_u16_le () ; _struct . loaded = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_f32_le (<span class="self">self </span>. terrain_height) ; _tmp . put_f32_le (<span class="self">self </span>. current_height) ; _tmp . put_u16_le (<span class="self">self </span>. spacing) ; _tmp . put_u16_le (<span class="self">self </span>. pending) ; _tmp . put_u16_le (<span class="self">self </span>. loaded) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>TERRAIN_REPORT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_ITEM_INT_DATA { <span class="kw">pub </span>param1 : f32 , <span class="kw">pub </span>param2 : f32 , <span class="kw">pub </span>param3 : f32 , <span class="kw">pub </span>param4 : f32 , <span class="kw">pub </span>x : i32 , <span class="kw">pub </span>y : i32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>seq : u16 , <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>frame : MavFrame , <span class="kw">pub </span>current : u8 , <span class="kw">pub </span>autocontinue : u8 , } <span class="kw">impl </span>MISSION_ITEM_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ param1 : <span class="number">0.0_f32 </span>, param2 : <span class="number">0.0_f32 </span>, param3 : <span class="number">0.0_f32 </span>, param4 : <span class="number">0.0_f32 </span>, x : <span class="number">0_i32 </span>, y : <span class="number">0_i32 </span>, z : <span class="number">0.0_f32 </span>, seq : <span class="number">0_u16 </span>, command : MavCmd :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, frame : MavFrame :: DEFAULT , current : <span class="number">0_u8 </span>, autocontinue : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param1 = buf . get_f32_le () ; _struct . param2 = buf . get_f32_le () ; _struct . param3 = buf . get_f32_le () ; _struct . param4 = buf . get_f32_le () ; _struct . x = buf . get_i32_le () ; _struct . y = buf . get_i32_le () ; _struct . z = buf . get_f32_le () ; _struct . seq = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . current = buf . get_u8 () ; _struct . autocontinue = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param1) ; _tmp . put_f32_le (<span class="self">self </span>. param2) ; _tmp . put_f32_le (<span class="self">self </span>. param3) ; _tmp . put_f32_le (<span class="self">self </span>. param4) ; _tmp . put_i32_le (<span class="self">self </span>. x) ; _tmp . put_i32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. current) ; _tmp . put_u8 (<span class="self">self </span>. autocontinue) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_ITEM_INT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DEEPSTALL_DATA { <span class="kw">pub </span>landing_lat : i32 , <span class="kw">pub </span>landing_lon : i32 , <span class="kw">pub </span>path_lat : i32 , <span class="kw">pub </span>path_lon : i32 , <span class="kw">pub </span>arc_entry_lat : i32 , <span class="kw">pub </span>arc_entry_lon : i32 , <span class="kw">pub </span>altitude : f32 , <span class="kw">pub </span>expected_travel_distance : f32 , <span class="kw">pub </span>cross_track_error : f32 , <span class="kw">pub </span>stage : DeepstallStage , } <span class="kw">impl </span>DEEPSTALL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ landing_lat : <span class="number">0_i32 </span>, landing_lon : <span class="number">0_i32 </span>, path_lat : <span class="number">0_i32 </span>, path_lon : <span class="number">0_i32 </span>, arc_entry_lat : <span class="number">0_i32 </span>, arc_entry_lon : <span class="number">0_i32 </span>, altitude : <span class="number">0.0_f32 </span>, expected_travel_distance : <span class="number">0.0_f32 </span>, cross_track_error : <span class="number">0.0_f32 </span>, stage : DeepstallStage :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . landing_lat = buf . get_i32_le () ; _struct . landing_lon = buf . get_i32_le () ; _struct . path_lat = buf . get_i32_le () ; _struct . path_lon = buf . get_i32_le () ; _struct . arc_entry_lat = buf . get_i32_le () ; _struct . arc_entry_lon = buf . get_i32_le () ; _struct . altitude = buf . get_f32_le () ; _struct . expected_travel_distance = buf . get_f32_le () ; _struct . cross_track_error = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . stage = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;DeepstallStage&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. landing_lat) ; _tmp . put_i32_le (<span class="self">self </span>. landing_lon) ; _tmp . put_i32_le (<span class="self">self </span>. path_lat) ; _tmp . put_i32_le (<span class="self">self </span>. path_lon) ; _tmp . put_i32_le (<span class="self">self </span>. arc_entry_lat) ; _tmp . put_i32_le (<span class="self">self </span>. arc_entry_lon) ; _tmp . put_f32_le (<span class="self">self </span>. altitude) ; _tmp . put_f32_le (<span class="self">self </span>. expected_travel_distance) ; _tmp . put_f32_le (<span class="self">self </span>. cross_track_error) ; _tmp . put_u8 (<span class="self">self </span>. stage <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DEEPSTALL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_TRIGGER_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>seq : u32 , } <span class="kw">impl </span>CAMERA_TRIGGER_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">12usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, seq : <span class="number">0_u32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . seq = buf . get_u32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. seq) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAMERA_TRIGGER_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MEMORY_VECT_DATA { <span class="kw">pub </span>address : u16 , <span class="kw">pub </span>ver : u8 , <span class="kw">pub </span>mavtype : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>value : [i8 ; <span class="number">32</span>] , } <span class="kw">impl </span>MEMORY_VECT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">36usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ address : <span class="number">0_u16 </span>, ver : <span class="number">0_u8 </span>, mavtype : <span class="number">0_u8 </span>, value : [<span class="number">0_i8 </span>; <span class="number">32usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . address = buf . get_u16_le () ; _struct . ver = buf . get_u8 () ; _struct . mavtype = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . value { <span class="kw">let </span>val = buf . get_i8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. address) ; _tmp . put_u8 (<span class="self">self </span>. ver) ; _tmp . put_u8 (<span class="self">self </span>. mavtype) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. value { _tmp . put_i8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MEMORY_VECT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LIMITS_STATUS_DATA { <span class="kw">pub </span>last_trigger : u32 , <span class="kw">pub </span>last_action : u32 , <span class="kw">pub </span>last_recovery : u32 , <span class="kw">pub </span>last_clear : u32 , <span class="kw">pub </span>breach_count : u16 , <span class="kw">pub </span>limits_state : LimitsState , <span class="kw">pub </span>mods_enabled : LimitModule , <span class="kw">pub </span>mods_required : LimitModule , <span class="kw">pub </span>mods_triggered : LimitModule , } <span class="kw">impl </span>LIMITS_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ last_trigger : <span class="number">0_u32 </span>, last_action : <span class="number">0_u32 </span>, last_recovery : <span class="number">0_u32 </span>, last_clear : <span class="number">0_u32 </span>, breach_count : <span class="number">0_u16 </span>, limits_state : LimitsState :: DEFAULT , mods_enabled : LimitModule :: DEFAULT , mods_required : LimitModule :: DEFAULT , mods_triggered : LimitModule :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . last_trigger = buf . get_u32_le () ; _struct . last_action = buf . get_u32_le () ; _struct . last_recovery = buf . get_u32_le () ; _struct . last_clear = buf . get_u32_le () ; _struct . breach_count = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . limits_state = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;LimitsState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mods_enabled = LimitModule :: from_bits (tmp &amp; LimitModule :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;LimitModule&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mods_required = LimitModule :: from_bits (tmp &amp; LimitModule :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;LimitModule&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mods_triggered = LimitModule :: from_bits (tmp &amp; LimitModule :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;LimitModule&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. last_trigger) ; _tmp . put_u32_le (<span class="self">self </span>. last_action) ; _tmp . put_u32_le (<span class="self">self </span>. last_recovery) ; _tmp . put_u32_le (<span class="self">self </span>. last_clear) ; _tmp . put_u16_le (<span class="self">self </span>. breach_count) ; _tmp . put_u8 (<span class="self">self </span>. limits_state <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mods_enabled . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. mods_required . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. mods_triggered . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LIMITS_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OSD_PARAM_SHOW_CONFIG_REPLY_DATA { <span class="kw">pub </span>request_id : u32 , <span class="kw">pub </span>min_value : f32 , <span class="kw">pub </span>max_value : f32 , <span class="kw">pub </span>increment : f32 , <span class="kw">pub </span>result : OsdParamConfigError , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>config_type : OsdParamConfigType , } <span class="kw">impl </span>OSD_PARAM_SHOW_CONFIG_REPLY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">34usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ request_id : <span class="number">0_u32 </span>, min_value : <span class="number">0.0_f32 </span>, max_value : <span class="number">0.0_f32 </span>, increment : <span class="number">0.0_f32 </span>, result : OsdParamConfigError :: DEFAULT , param_id : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , config_type : OsdParamConfigType :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . request_id = buf . get_u32_le () ; _struct . min_value = buf . get_f32_le () ; _struct . max_value = buf . get_f32_le () ; _struct . increment = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . result = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;OsdParamConfigError&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . config_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;OsdParamConfigType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. request_id) ; _tmp . put_f32_le (<span class="self">self </span>. min_value) ; _tmp . put_f32_le (<span class="self">self </span>. max_value) ; _tmp . put_f32_le (<span class="self">self </span>. increment) ; _tmp . put_u8 (<span class="self">self </span>. result <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. config_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OSD_PARAM_SHOW_CONFIG_REPLY_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>REMOTE_LOG_BLOCK_STATUS_DATA { <span class="kw">pub </span>seqno : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>status : MavRemoteLogDataBlockStatuses , } <span class="kw">impl </span>REMOTE_LOG_BLOCK_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">7usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ seqno : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, status : MavRemoteLogDataBlockStatuses :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seqno = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavRemoteLogDataBlockStatuses&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. seqno) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>REMOTE_LOG_BLOCK_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DEVICE_OP_WRITE_REPLY_DATA { <span class="kw">pub </span>request_id : u32 , <span class="kw">pub </span>result : u8 , } <span class="kw">impl </span>DEVICE_OP_WRITE_REPLY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">5usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ request_id : <span class="number">0_u32 </span>, result : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . request_id = buf . get_u32_le () ; _struct . result = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. request_id) ; _tmp . put_u8 (<span class="self">self </span>. result) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DEVICE_OP_WRITE_REPLY_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LANDING_TARGET_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>angle_x : f32 , <span class="kw">pub </span>angle_y : f32 , <span class="kw">pub </span>distance : f32 , <span class="kw">pub </span>size_x : f32 , <span class="kw">pub </span>size_y : f32 , <span class="kw">pub </span>target_num : u8 , <span class="kw">pub </span>frame : MavFrame , } <span class="kw">impl </span>LANDING_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">30usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, angle_x : <span class="number">0.0_f32 </span>, angle_y : <span class="number">0.0_f32 </span>, distance : <span class="number">0.0_f32 </span>, size_x : <span class="number">0.0_f32 </span>, size_y : <span class="number">0.0_f32 </span>, target_num : <span class="number">0_u8 </span>, frame : MavFrame :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . angle_x = buf . get_f32_le () ; _struct . angle_y = buf . get_f32_le () ; _struct . distance = buf . get_f32_le () ; _struct . size_x = buf . get_f32_le () ; _struct . size_y = buf . get_f32_le () ; _struct . target_num = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. angle_x) ; _tmp . put_f32_le (<span class="self">self </span>. angle_y) ; _tmp . put_f32_le (<span class="self">self </span>. distance) ; _tmp . put_f32_le (<span class="self">self </span>. size_x) ; _tmp . put_f32_le (<span class="self">self </span>. size_y) ; _tmp . put_u8 (<span class="self">self </span>. target_num) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LANDING_TARGET_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_REPORT_DATA { <span class="kw">pub </span>delta_time : f32 , <span class="kw">pub </span>delta_angle_x : f32 , <span class="kw">pub </span>delta_angle_y : f32 , <span class="kw">pub </span>delta_angle_z : f32 , <span class="kw">pub </span>delta_velocity_x : f32 , <span class="kw">pub </span>delta_velocity_y : f32 , <span class="kw">pub </span>delta_velocity_z : f32 , <span class="kw">pub </span>joint_roll : f32 , <span class="kw">pub </span>joint_el : f32 , <span class="kw">pub </span>joint_az : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>GIMBAL_REPORT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ delta_time : <span class="number">0.0_f32 </span>, delta_angle_x : <span class="number">0.0_f32 </span>, delta_angle_y : <span class="number">0.0_f32 </span>, delta_angle_z : <span class="number">0.0_f32 </span>, delta_velocity_x : <span class="number">0.0_f32 </span>, delta_velocity_y : <span class="number">0.0_f32 </span>, delta_velocity_z : <span class="number">0.0_f32 </span>, joint_roll : <span class="number">0.0_f32 </span>, joint_el : <span class="number">0.0_f32 </span>, joint_az : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . delta_time = buf . get_f32_le () ; _struct . delta_angle_x = buf . get_f32_le () ; _struct . delta_angle_y = buf . get_f32_le () ; _struct . delta_angle_z = buf . get_f32_le () ; _struct . delta_velocity_x = buf . get_f32_le () ; _struct . delta_velocity_y = buf . get_f32_le () ; _struct . delta_velocity_z = buf . get_f32_le () ; _struct . joint_roll = buf . get_f32_le () ; _struct . joint_el = buf . get_f32_le () ; _struct . joint_az = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. delta_time) ; _tmp . put_f32_le (<span class="self">self </span>. delta_angle_x) ; _tmp . put_f32_le (<span class="self">self </span>. delta_angle_y) ; _tmp . put_f32_le (<span class="self">self </span>. delta_angle_z) ; _tmp . put_f32_le (<span class="self">self </span>. delta_velocity_x) ; _tmp . put_f32_le (<span class="self">self </span>. delta_velocity_y) ; _tmp . put_f32_le (<span class="self">self </span>. delta_velocity_z) ; _tmp . put_f32_le (<span class="self">self </span>. joint_roll) ; _tmp . put_f32_le (<span class="self">self </span>. joint_el) ; _tmp . put_f32_le (<span class="self">self </span>. joint_az) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GIMBAL_REPORT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_TRACKING_IMAGE_STATUS_DATA { <span class="kw">pub </span>point_x : f32 , <span class="kw">pub </span>point_y : f32 , <span class="kw">pub </span>radius : f32 , <span class="kw">pub </span>rec_top_x : f32 , <span class="kw">pub </span>rec_top_y : f32 , <span class="kw">pub </span>rec_bottom_x : f32 , <span class="kw">pub </span>rec_bottom_y : f32 , <span class="kw">pub </span>tracking_status : CameraTrackingStatusFlags , <span class="kw">pub </span>tracking_mode : CameraTrackingMode , <span class="kw">pub </span>target_data : CameraTrackingTargetData , } <span class="kw">impl </span>CAMERA_TRACKING_IMAGE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">31usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ point_x : <span class="number">0.0_f32 </span>, point_y : <span class="number">0.0_f32 </span>, radius : <span class="number">0.0_f32 </span>, rec_top_x : <span class="number">0.0_f32 </span>, rec_top_y : <span class="number">0.0_f32 </span>, rec_bottom_x : <span class="number">0.0_f32 </span>, rec_bottom_y : <span class="number">0.0_f32 </span>, tracking_status : CameraTrackingStatusFlags :: DEFAULT , tracking_mode : CameraTrackingMode :: DEFAULT , target_data : CameraTrackingTargetData :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . point_x = buf . get_f32_le () ; _struct . point_y = buf . get_f32_le () ; _struct . radius = buf . get_f32_le () ; _struct . rec_top_x = buf . get_f32_le () ; _struct . rec_top_y = buf . get_f32_le () ; _struct . rec_bottom_x = buf . get_f32_le () ; _struct . rec_bottom_y = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . tracking_status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraTrackingStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . tracking_mode = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraTrackingMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . target_data = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraTrackingTargetData&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. point_x) ; _tmp . put_f32_le (<span class="self">self </span>. point_y) ; _tmp . put_f32_le (<span class="self">self </span>. radius) ; _tmp . put_f32_le (<span class="self">self </span>. rec_top_x) ; _tmp . put_f32_le (<span class="self">self </span>. rec_top_y) ; _tmp . put_f32_le (<span class="self">self </span>. rec_bottom_x) ; _tmp . put_f32_le (<span class="self">self </span>. rec_bottom_y) ; _tmp . put_u8 (<span class="self">self </span>. tracking_status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. tracking_mode <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. target_data <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAMERA_TRACKING_IMAGE_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ATTITUDE_QUATERNION_COV_DATA { <span class="kw">pub </span>time_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>covariance : [f32 ; <span class="number">9</span>] , } <span class="kw">impl </span>ATTITUDE_QUATERNION_COV_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">72usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , rollspeed : <span class="number">0.0_f32 </span>, pitchspeed : <span class="number">0.0_f32 </span>, yawspeed : <span class="number">0.0_f32 </span>, covariance : [<span class="number">0.0_f32 </span>; <span class="number">9usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . covariance { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. covariance { _tmp . put_f32_le (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ATTITUDE_QUATERNION_COV_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RALLY_POINT_DATA { <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lng : i32 , <span class="kw">pub </span>alt : i16 , <span class="kw">pub </span>break_alt : i16 , <span class="kw">pub </span>land_dir : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>idx : u8 , <span class="kw">pub </span>count : u8 , <span class="kw">pub </span>flags : RallyFlags , } <span class="kw">impl </span>RALLY_POINT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">19usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ lat : <span class="number">0_i32 </span>, lng : <span class="number">0_i32 </span>, alt : <span class="number">0_i16 </span>, break_alt : <span class="number">0_i16 </span>, land_dir : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, idx : <span class="number">0_u8 </span>, count : <span class="number">0_u8 </span>, flags : RallyFlags :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . lat = buf . get_i32_le () ; _struct . lng = buf . get_i32_le () ; _struct . alt = buf . get_i16_le () ; _struct . break_alt = buf . get_i16_le () ; _struct . land_dir = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . idx = buf . get_u8 () ; _struct . count = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . flags = RallyFlags :: from_bits (tmp &amp; RallyFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;RallyFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lng) ; _tmp . put_i16_le (<span class="self">self </span>. alt) ; _tmp . put_i16_le (<span class="self">self </span>. break_alt) ; _tmp . put_u16_le (<span class="self">self </span>. land_dir) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. idx) ; _tmp . put_u8 (<span class="self">self </span>. count) ; _tmp . put_u8 (<span class="self">self </span>. flags . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RALLY_POINT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_PRESSURE3_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>press_abs : f32 , <span class="kw">pub </span>press_diff : f32 , <span class="kw">pub </span>temperature : i16 , } <span class="kw">impl </span>SCALED_PRESSURE3_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, press_abs : <span class="number">0.0_f32 </span>, press_diff : <span class="number">0.0_f32 </span>, temperature : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . press_abs = buf . get_f32_le () ; _struct . press_diff = buf . get_f32_le () ; _struct . temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. press_abs) ; _tmp . put_f32_le (<span class="self">self </span>. press_diff) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SCALED_PRESSURE3_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SIM_STATE_DATA { <span class="kw">pub </span>q1 : f32 , <span class="kw">pub </span>q2 : f32 , <span class="kw">pub </span>q3 : f32 , <span class="kw">pub </span>q4 : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>xacc : f32 , <span class="kw">pub </span>yacc : f32 , <span class="kw">pub </span>zacc : f32 , <span class="kw">pub </span>xgyro : f32 , <span class="kw">pub </span>ygyro : f32 , <span class="kw">pub </span>zgyro : f32 , <span class="kw">pub </span>lat : f32 , <span class="kw">pub </span>lon : f32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>std_dev_horz : f32 , <span class="kw">pub </span>std_dev_vert : f32 , <span class="kw">pub </span>vn : f32 , <span class="kw">pub </span>ve : f32 , <span class="kw">pub </span>vd : f32 , } <span class="kw">impl </span>SIM_STATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">84usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ q1 : <span class="number">0.0_f32 </span>, q2 : <span class="number">0.0_f32 </span>, q3 : <span class="number">0.0_f32 </span>, q4 : <span class="number">0.0_f32 </span>, roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, xacc : <span class="number">0.0_f32 </span>, yacc : <span class="number">0.0_f32 </span>, zacc : <span class="number">0.0_f32 </span>, xgyro : <span class="number">0.0_f32 </span>, ygyro : <span class="number">0.0_f32 </span>, zgyro : <span class="number">0.0_f32 </span>, lat : <span class="number">0.0_f32 </span>, lon : <span class="number">0.0_f32 </span>, alt : <span class="number">0.0_f32 </span>, std_dev_horz : <span class="number">0.0_f32 </span>, std_dev_vert : <span class="number">0.0_f32 </span>, vn : <span class="number">0.0_f32 </span>, ve : <span class="number">0.0_f32 </span>, vd : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . q1 = buf . get_f32_le () ; _struct . q2 = buf . get_f32_le () ; _struct . q3 = buf . get_f32_le () ; _struct . q4 = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . xacc = buf . get_f32_le () ; _struct . yacc = buf . get_f32_le () ; _struct . zacc = buf . get_f32_le () ; _struct . xgyro = buf . get_f32_le () ; _struct . ygyro = buf . get_f32_le () ; _struct . zgyro = buf . get_f32_le () ; _struct . lat = buf . get_f32_le () ; _struct . lon = buf . get_f32_le () ; _struct . alt = buf . get_f32_le () ; _struct . std_dev_horz = buf . get_f32_le () ; _struct . std_dev_vert = buf . get_f32_le () ; _struct . vn = buf . get_f32_le () ; _struct . ve = buf . get_f32_le () ; _struct . vd = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. q1) ; _tmp . put_f32_le (<span class="self">self </span>. q2) ; _tmp . put_f32_le (<span class="self">self </span>. q3) ; _tmp . put_f32_le (<span class="self">self </span>. q4) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. xacc) ; _tmp . put_f32_le (<span class="self">self </span>. yacc) ; _tmp . put_f32_le (<span class="self">self </span>. zacc) ; _tmp . put_f32_le (<span class="self">self </span>. xgyro) ; _tmp . put_f32_le (<span class="self">self </span>. ygyro) ; _tmp . put_f32_le (<span class="self">self </span>. zgyro) ; _tmp . put_f32_le (<span class="self">self </span>. lat) ; _tmp . put_f32_le (<span class="self">self </span>. lon) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. std_dev_horz) ; _tmp . put_f32_le (<span class="self">self </span>. std_dev_vert) ; _tmp . put_f32_le (<span class="self">self </span>. vn) ; _tmp . put_f32_le (<span class="self">self </span>. ve) ; _tmp . put_f32_le (<span class="self">self </span>. vd) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SIM_STATE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ACTUATOR_OUTPUT_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>active : u32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>actuator : [f32 ; <span class="number">32</span>] , } <span class="kw">impl </span>ACTUATOR_OUTPUT_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">140usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, active : <span class="number">0_u32 </span>, actuator : [<span class="number">0.0_f32 </span>; <span class="number">32usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . active = buf . get_u32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . actuator { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. active) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. actuator { _tmp . put_f32_le (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ACTUATOR_OUTPUT_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_MESSAGE_PACK_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>single_message_size : u8 , <span class="kw">pub </span>msg_pack_size : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>messages : [u8 ; <span class="number">225</span>] , } <span class="kw">impl </span>OPEN_DRONE_ID_MESSAGE_PACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">249usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, id_or_mac : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , single_message_size : <span class="number">0_u8 </span>, msg_pack_size : <span class="number">0_u8 </span>, messages : [<span class="number">0_u8 </span>; <span class="number">225usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . id_or_mac { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } _struct . single_message_size = buf . get_u8 () ; _struct . msg_pack_size = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . messages { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. single_message_size) ; _tmp . put_u8 (<span class="self">self </span>. msg_pack_size) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. messages { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OPEN_DRONE_ID_MESSAGE_PACK_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VISION_SPEED_ESTIMATE_DATA { <span class="kw">pub </span>usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , } <span class="kw">impl </span>VISION_SPEED_ESTIMATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ usec : <span class="number">0_u64 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>VISION_SPEED_ESTIMATE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_BASIC_ID_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>id_type : MavOdidIdType , <span class="kw">pub </span>ua_type : MavOdidUaType , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>uas_id : [u8 ; <span class="number">20</span>] , } <span class="kw">impl </span>OPEN_DRONE_ID_BASIC_ID_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, id_or_mac : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , id_type : MavOdidIdType :: DEFAULT , ua_type : MavOdidUaType :: DEFAULT , uas_id : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . id_or_mac { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . id_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidIdType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . ua_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidUaType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . uas_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. id_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. ua_type <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. uas_id { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OPEN_DRONE_ID_BASIC_ID_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TUNNEL_DATA { <span class="kw">pub </span>payload_type : MavTunnelPayloadType , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>payload_length : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>payload : [u8 ; <span class="number">128</span>] , } <span class="kw">impl </span>TUNNEL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">133usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ payload_type : MavTunnelPayloadType :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, payload_length : <span class="number">0_u8 </span>, payload : [<span class="number">0_u8 </span>; <span class="number">128usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . payload_type = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavTunnelPayloadType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . payload_length = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . payload { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. payload_type <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. payload_length) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. payload { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>TUNNEL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>POSITION_TARGET_GLOBAL_INT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>lat_int : i32 , <span class="kw">pub </span>lon_int : i32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>afx : f32 , <span class="kw">pub </span>afy : f32 , <span class="kw">pub </span>afz : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>type_mask : PositionTargetTypemask , <span class="kw">pub </span>coordinate_frame : MavFrame , } <span class="kw">impl </span>POSITION_TARGET_GLOBAL_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">51usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, lat_int : <span class="number">0_i32 </span>, lon_int : <span class="number">0_i32 </span>, alt : <span class="number">0.0_f32 </span>, vx : <span class="number">0.0_f32 </span>, vy : <span class="number">0.0_f32 </span>, vz : <span class="number">0.0_f32 </span>, afx : <span class="number">0.0_f32 </span>, afy : <span class="number">0.0_f32 </span>, afz : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, yaw_rate : <span class="number">0.0_f32 </span>, type_mask : PositionTargetTypemask :: DEFAULT , coordinate_frame : MavFrame :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . lat_int = buf . get_i32_le () ; _struct . lon_int = buf . get_i32_le () ; _struct . alt = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . afx = buf . get_f32_le () ; _struct . afy = buf . get_f32_le () ; _struct . afz = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . type_mask = PositionTargetTypemask :: from_bits (tmp &amp; PositionTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;PositionTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . coordinate_frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat_int) ; _tmp . put_i32_le (<span class="self">self </span>. lon_int) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. afx) ; _tmp . put_f32_le (<span class="self">self </span>. afy) ; _tmp . put_f32_le (<span class="self">self </span>. afz) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u16_le (<span class="self">self </span>. type_mask . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. coordinate_frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>POSITION_TARGET_GLOBAL_INT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SENSOR_OFFSETS_DATA { <span class="kw">pub </span>mag_declination : f32 , <span class="kw">pub </span>raw_press : i32 , <span class="kw">pub </span>raw_temp : i32 , <span class="kw">pub </span>gyro_cal_x : f32 , <span class="kw">pub </span>gyro_cal_y : f32 , <span class="kw">pub </span>gyro_cal_z : f32 , <span class="kw">pub </span>accel_cal_x : f32 , <span class="kw">pub </span>accel_cal_y : f32 , <span class="kw">pub </span>accel_cal_z : f32 , <span class="kw">pub </span>mag_ofs_x : i16 , <span class="kw">pub </span>mag_ofs_y : i16 , <span class="kw">pub </span>mag_ofs_z : i16 , } <span class="kw">impl </span>SENSOR_OFFSETS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">42usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ mag_declination : <span class="number">0.0_f32 </span>, raw_press : <span class="number">0_i32 </span>, raw_temp : <span class="number">0_i32 </span>, gyro_cal_x : <span class="number">0.0_f32 </span>, gyro_cal_y : <span class="number">0.0_f32 </span>, gyro_cal_z : <span class="number">0.0_f32 </span>, accel_cal_x : <span class="number">0.0_f32 </span>, accel_cal_y : <span class="number">0.0_f32 </span>, accel_cal_z : <span class="number">0.0_f32 </span>, mag_ofs_x : <span class="number">0_i16 </span>, mag_ofs_y : <span class="number">0_i16 </span>, mag_ofs_z : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . mag_declination = buf . get_f32_le () ; _struct . raw_press = buf . get_i32_le () ; _struct . raw_temp = buf . get_i32_le () ; _struct . gyro_cal_x = buf . get_f32_le () ; _struct . gyro_cal_y = buf . get_f32_le () ; _struct . gyro_cal_z = buf . get_f32_le () ; _struct . accel_cal_x = buf . get_f32_le () ; _struct . accel_cal_y = buf . get_f32_le () ; _struct . accel_cal_z = buf . get_f32_le () ; _struct . mag_ofs_x = buf . get_i16_le () ; _struct . mag_ofs_y = buf . get_i16_le () ; _struct . mag_ofs_z = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. mag_declination) ; _tmp . put_i32_le (<span class="self">self </span>. raw_press) ; _tmp . put_i32_le (<span class="self">self </span>. raw_temp) ; _tmp . put_f32_le (<span class="self">self </span>. gyro_cal_x) ; _tmp . put_f32_le (<span class="self">self </span>. gyro_cal_y) ; _tmp . put_f32_le (<span class="self">self </span>. gyro_cal_z) ; _tmp . put_f32_le (<span class="self">self </span>. accel_cal_x) ; _tmp . put_f32_le (<span class="self">self </span>. accel_cal_y) ; _tmp . put_f32_le (<span class="self">self </span>. accel_cal_z) ; _tmp . put_i16_le (<span class="self">self </span>. mag_ofs_x) ; _tmp . put_i16_le (<span class="self">self </span>. mag_ofs_y) ; _tmp . put_i16_le (<span class="self">self </span>. mag_ofs_z) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SENSOR_OFFSETS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UAVCAN_NODE_INFO_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>uptime_sec : u32 , <span class="kw">pub </span>sw_vcs_commit : u32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>name : [u8 ; <span class="number">80</span>] , <span class="kw">pub </span>hw_version_major : u8 , <span class="kw">pub </span>hw_version_minor : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>hw_unique_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>sw_version_major : u8 , <span class="kw">pub </span>sw_version_minor : u8 , } <span class="kw">impl </span>UAVCAN_NODE_INFO_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">116usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, uptime_sec : <span class="number">0_u32 </span>, sw_vcs_commit : <span class="number">0_u32 </span>, name : [<span class="number">0_u8 </span>; <span class="number">80usize</span>] , hw_version_major : <span class="number">0_u8 </span>, hw_version_minor : <span class="number">0_u8 </span>, hw_unique_id : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , sw_version_major : <span class="number">0_u8 </span>, sw_version_minor : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . uptime_sec = buf . get_u32_le () ; _struct . sw_vcs_commit = buf . get_u32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } _struct . hw_version_major = buf . get_u8 () ; _struct . hw_version_minor = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . hw_unique_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } _struct . sw_version_major = buf . get_u8 () ; _struct . sw_version_minor = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. uptime_sec) ; _tmp . put_u32_le (<span class="self">self </span>. sw_vcs_commit) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. hw_version_major) ; _tmp . put_u8 (<span class="self">self </span>. hw_version_minor) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. hw_unique_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. sw_version_major) ; _tmp . put_u8 (<span class="self">self </span>. sw_version_minor) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>UAVCAN_NODE_INFO_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>FLIGHT_INFORMATION_DATA { <span class="kw">pub </span>arming_time_utc : u64 , <span class="kw">pub </span>takeoff_time_utc : u64 , <span class="kw">pub </span>flight_uuid : u64 , <span class="kw">pub </span>time_boot_ms : u32 , } <span class="kw">impl </span>FLIGHT_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ arming_time_utc : <span class="number">0_u64 </span>, takeoff_time_utc : <span class="number">0_u64 </span>, flight_uuid : <span class="number">0_u64 </span>, time_boot_ms : <span class="number">0_u32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . arming_time_utc = buf . get_u64_le () ; _struct . takeoff_time_utc = buf . get_u64_le () ; _struct . flight_uuid = buf . get_u64_le () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. arming_time_utc) ; _tmp . put_u64_le (<span class="self">self </span>. takeoff_time_utc) ; _tmp . put_u64_le (<span class="self">self </span>. flight_uuid) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>FLIGHT_INFORMATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RADIO_DATA { <span class="kw">pub </span>rxerrors : u16 , <span class="kw">pub </span>fixed : u16 , <span class="kw">pub </span>rssi : u8 , <span class="kw">pub </span>remrssi : u8 , <span class="kw">pub </span>txbuf : u8 , <span class="kw">pub </span>noise : u8 , <span class="kw">pub </span>remnoise : u8 , } <span class="kw">impl </span>RADIO_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">9usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ rxerrors : <span class="number">0_u16 </span>, fixed : <span class="number">0_u16 </span>, rssi : <span class="number">0_u8 </span>, remrssi : <span class="number">0_u8 </span>, txbuf : <span class="number">0_u8 </span>, noise : <span class="number">0_u8 </span>, remnoise : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . rxerrors = buf . get_u16_le () ; _struct . fixed = buf . get_u16_le () ; _struct . rssi = buf . get_u8 () ; _struct . remrssi = buf . get_u8 () ; _struct . txbuf = buf . get_u8 () ; _struct . noise = buf . get_u8 () ; _struct . remnoise = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. rxerrors) ; _tmp . put_u16_le (<span class="self">self </span>. fixed) ; _tmp . put_u8 (<span class="self">self </span>. rssi) ; _tmp . put_u8 (<span class="self">self </span>. remrssi) ; _tmp . put_u8 (<span class="self">self </span>. txbuf) ; _tmp . put_u8 (<span class="self">self </span>. noise) ; _tmp . put_u8 (<span class="self">self </span>. remnoise) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RADIO_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DATA32_DATA { <span class="kw">pub </span>mavtype : u8 , <span class="kw">pub </span>len : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">32</span>] , } <span class="kw">impl </span>DATA32_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">34usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ mavtype : <span class="number">0_u8 </span>, len : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">32usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . mavtype = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. mavtype) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DATA32_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CUBEPILOT_RAW_RC_DATA { } <span class="kw">impl </span>CUBEPILOT_RAW_RC_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">0usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: default ()) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CUBEPILOT_RAW_RC_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_IMU3_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , <span class="kw">pub </span>xgyro : i16 , <span class="kw">pub </span>ygyro : i16 , <span class="kw">pub </span>zgyro : i16 , <span class="kw">pub </span>xmag : i16 , <span class="kw">pub </span>ymag : i16 , <span class="kw">pub </span>zmag : i16 , } <span class="kw">impl </span>SCALED_IMU3_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, xacc : <span class="number">0_i16 </span>, yacc : <span class="number">0_i16 </span>, zacc : <span class="number">0_i16 </span>, xgyro : <span class="number">0_i16 </span>, ygyro : <span class="number">0_i16 </span>, zgyro : <span class="number">0_i16 </span>, xmag : <span class="number">0_i16 </span>, ymag : <span class="number">0_i16 </span>, zmag : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; _struct . xgyro = buf . get_i16_le () ; _struct . ygyro = buf . get_i16_le () ; _struct . zgyro = buf . get_i16_le () ; _struct . xmag = buf . get_i16_le () ; _struct . ymag = buf . get_i16_le () ; _struct . zmag = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; _tmp . put_i16_le (<span class="self">self </span>. xgyro) ; _tmp . put_i16_le (<span class="self">self </span>. ygyro) ; _tmp . put_i16_le (<span class="self">self </span>. zgyro) ; _tmp . put_i16_le (<span class="self">self </span>. xmag) ; _tmp . put_i16_le (<span class="self">self </span>. ymag) ; _tmp . put_i16_le (<span class="self">self </span>. zmag) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SCALED_IMU3_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_MANAGER_SET_MANUAL_CONTROL_DATA { <span class="kw">pub </span>flags : GimbalManagerFlags , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>pitch_rate : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>gimbal_device_id : u8 , } <span class="kw">impl </span>GIMBAL_MANAGER_SET_MANUAL_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">23usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ flags : GimbalManagerFlags :: DEFAULT , pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, pitch_rate : <span class="number">0.0_f32 </span>, yaw_rate : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, gimbal_device_id : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . flags = FromPrimitive :: from_u32 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GimbalManagerFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . pitch_rate = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . gimbal_device_id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. flags <span class="kw">as </span>u32) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_rate) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. gimbal_device_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GIMBAL_MANAGER_SET_MANUAL_CONTROL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_DEVICE_INFORMATION_DATA { <span class="kw">pub </span>uid : u64 , <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>firmware_version : u32 , <span class="kw">pub </span>hardware_version : u32 , <span class="kw">pub </span>roll_min : f32 , <span class="kw">pub </span>roll_max : f32 , <span class="kw">pub </span>pitch_min : f32 , <span class="kw">pub </span>pitch_max : f32 , <span class="kw">pub </span>yaw_min : f32 , <span class="kw">pub </span>yaw_max : f32 , <span class="kw">pub </span>cap_flags : GimbalDeviceCapFlags , <span class="kw">pub </span>custom_cap_flags : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>vendor_name : [u8 ; <span class="number">32</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>model_name : [u8 ; <span class="number">32</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>custom_name : [u8 ; <span class="number">32</span>] , } <span class="kw">impl </span>GIMBAL_DEVICE_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">144usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ uid : <span class="number">0_u64 </span>, time_boot_ms : <span class="number">0_u32 </span>, firmware_version : <span class="number">0_u32 </span>, hardware_version : <span class="number">0_u32 </span>, roll_min : <span class="number">0.0_f32 </span>, roll_max : <span class="number">0.0_f32 </span>, pitch_min : <span class="number">0.0_f32 </span>, pitch_max : <span class="number">0.0_f32 </span>, yaw_min : <span class="number">0.0_f32 </span>, yaw_max : <span class="number">0.0_f32 </span>, cap_flags : GimbalDeviceCapFlags :: DEFAULT , custom_cap_flags : <span class="number">0_u16 </span>, vendor_name : [<span class="number">0_u8 </span>; <span class="number">32usize</span>] , model_name : [<span class="number">0_u8 </span>; <span class="number">32usize</span>] , custom_name : [<span class="number">0_u8 </span>; <span class="number">32usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . uid = buf . get_u64_le () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . firmware_version = buf . get_u32_le () ; _struct . hardware_version = buf . get_u32_le () ; _struct . roll_min = buf . get_f32_le () ; _struct . roll_max = buf . get_f32_le () ; _struct . pitch_min = buf . get_f32_le () ; _struct . pitch_max = buf . get_f32_le () ; _struct . yaw_min = buf . get_f32_le () ; _struct . yaw_max = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . cap_flags = GimbalDeviceCapFlags :: from_bits (tmp &amp; GimbalDeviceCapFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GimbalDeviceCapFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . custom_cap_flags = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . vendor_name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . model_name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . custom_name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. uid) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. firmware_version) ; _tmp . put_u32_le (<span class="self">self </span>. hardware_version) ; _tmp . put_f32_le (<span class="self">self </span>. roll_min) ; _tmp . put_f32_le (<span class="self">self </span>. roll_max) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_min) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_max) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_min) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_max) ; _tmp . put_u16_le (<span class="self">self </span>. cap_flags . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. custom_cap_flags) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vendor_name { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. model_name { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. custom_name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GIMBAL_DEVICE_INFORMATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TERRAIN_DATA_DATA { <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>grid_spacing : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [i16 ; <span class="number">16</span>] , <span class="kw">pub </span>gridbit : u8 , } <span class="kw">impl </span>TERRAIN_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">43usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, grid_spacing : <span class="number">0_u16 </span>, data : [<span class="number">0_i16 </span>; <span class="number">16usize</span>] , gridbit : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . grid_spacing = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_i16_le () ; * v = val ; } _struct . gridbit = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_u16_le (<span class="self">self </span>. grid_spacing) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_i16_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. gridbit) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>TERRAIN_DATA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ACTUATOR_CONTROL_TARGET_DATA { <span class="kw">pub </span>time_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>controls : [f32 ; <span class="number">8</span>] , <span class="kw">pub </span>group_mlx : u8 , } <span class="kw">impl </span>ACTUATOR_CONTROL_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">41usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, controls : [<span class="number">0.0_f32 </span>; <span class="number">8usize</span>] , group_mlx : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . controls { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . group_mlx = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. controls { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. group_mlx) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ACTUATOR_CONTROL_TARGET_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LINK_NODE_STATUS_DATA { <span class="kw">pub </span>timestamp : u64 , <span class="kw">pub </span>tx_rate : u32 , <span class="kw">pub </span>rx_rate : u32 , <span class="kw">pub </span>messages_sent : u32 , <span class="kw">pub </span>messages_received : u32 , <span class="kw">pub </span>messages_lost : u32 , <span class="kw">pub </span>rx_parse_err : u16 , <span class="kw">pub </span>tx_overflows : u16 , <span class="kw">pub </span>rx_overflows : u16 , <span class="kw">pub </span>tx_buf : u8 , <span class="kw">pub </span>rx_buf : u8 , } <span class="kw">impl </span>LINK_NODE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">36usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ timestamp : <span class="number">0_u64 </span>, tx_rate : <span class="number">0_u32 </span>, rx_rate : <span class="number">0_u32 </span>, messages_sent : <span class="number">0_u32 </span>, messages_received : <span class="number">0_u32 </span>, messages_lost : <span class="number">0_u32 </span>, rx_parse_err : <span class="number">0_u16 </span>, tx_overflows : <span class="number">0_u16 </span>, rx_overflows : <span class="number">0_u16 </span>, tx_buf : <span class="number">0_u8 </span>, rx_buf : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . timestamp = buf . get_u64_le () ; _struct . tx_rate = buf . get_u32_le () ; _struct . rx_rate = buf . get_u32_le () ; _struct . messages_sent = buf . get_u32_le () ; _struct . messages_received = buf . get_u32_le () ; _struct . messages_lost = buf . get_u32_le () ; _struct . rx_parse_err = buf . get_u16_le () ; _struct . tx_overflows = buf . get_u16_le () ; _struct . rx_overflows = buf . get_u16_le () ; _struct . tx_buf = buf . get_u8 () ; _struct . rx_buf = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. timestamp) ; _tmp . put_u32_le (<span class="self">self </span>. tx_rate) ; _tmp . put_u32_le (<span class="self">self </span>. rx_rate) ; _tmp . put_u32_le (<span class="self">self </span>. messages_sent) ; _tmp . put_u32_le (<span class="self">self </span>. messages_received) ; _tmp . put_u32_le (<span class="self">self </span>. messages_lost) ; _tmp . put_u16_le (<span class="self">self </span>. rx_parse_err) ; _tmp . put_u16_le (<span class="self">self </span>. tx_overflows) ; _tmp . put_u16_le (<span class="self">self </span>. rx_overflows) ; _tmp . put_u8 (<span class="self">self </span>. tx_buf) ; _tmp . put_u8 (<span class="self">self </span>. rx_buf) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LINK_NODE_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ESC_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>rpm : [i32 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>voltage : [f32 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>current : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>index : u8 , } <span class="kw">impl </span>ESC_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">57usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, rpm : [<span class="number">0_i32 </span>; <span class="number">4usize</span>] , voltage : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , current : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , index : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . rpm { <span class="kw">let </span>val = buf . get_i32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . voltage { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . current { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . index = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. rpm { _tmp . put_i32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. voltage { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. current { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. index) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ESC_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>STATUSTEXT_DATA { <span class="kw">pub </span>severity : MavSeverity , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>text : [u8 ; <span class="number">50</span>] , } <span class="kw">impl </span>STATUSTEXT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">51usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ severity : MavSeverity :: DEFAULT , text : [<span class="number">0_u8 </span>; <span class="number">50usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . severity = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavSeverity&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . text { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. severity <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. text { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>STATUSTEXT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_ATTITUDE_TARGET_DATA { <span class="kw">pub </span>time_boot_ms : u32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>body_roll_rate : f32 , <span class="kw">pub </span>body_pitch_rate : f32 , <span class="kw">pub </span>body_yaw_rate : f32 , <span class="kw">pub </span>thrust : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>type_mask : AttitudeTargetTypemask , } <span class="kw">impl </span>SET_ATTITUDE_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">39usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , body_roll_rate : <span class="number">0.0_f32 </span>, body_pitch_rate : <span class="number">0.0_f32 </span>, body_yaw_rate : <span class="number">0.0_f32 </span>, thrust : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, type_mask : AttitudeTargetTypemask :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . body_roll_rate = buf . get_f32_le () ; _struct . body_pitch_rate = buf . get_f32_le () ; _struct . body_yaw_rate = buf . get_f32_le () ; _struct . thrust = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . type_mask = AttitudeTargetTypemask :: from_bits (tmp &amp; AttitudeTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;AttitudeTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. body_roll_rate) ; _tmp . put_f32_le (<span class="self">self </span>. body_pitch_rate) ; _tmp . put_f32_le (<span class="self">self </span>. body_yaw_rate) ; _tmp . put_f32_le (<span class="self">self </span>. thrust) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. type_mask . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SET_ATTITUDE_TARGET_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ALTITUDE_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>altitude_monotonic : f32 , <span class="kw">pub </span>altitude_amsl : f32 , <span class="kw">pub </span>altitude_local : f32 , <span class="kw">pub </span>altitude_relative : f32 , <span class="kw">pub </span>altitude_terrain : f32 , <span class="kw">pub </span>bottom_clearance : f32 , } <span class="kw">impl </span>ALTITUDE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, altitude_monotonic : <span class="number">0.0_f32 </span>, altitude_amsl : <span class="number">0.0_f32 </span>, altitude_local : <span class="number">0.0_f32 </span>, altitude_relative : <span class="number">0.0_f32 </span>, altitude_terrain : <span class="number">0.0_f32 </span>, bottom_clearance : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . altitude_monotonic = buf . get_f32_le () ; _struct . altitude_amsl = buf . get_f32_le () ; _struct . altitude_local = buf . get_f32_le () ; _struct . altitude_relative = buf . get_f32_le () ; _struct . altitude_terrain = buf . get_f32_le () ; _struct . bottom_clearance = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_monotonic) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_amsl) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_local) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_relative) ; _tmp . put_f32_le (<span class="self">self </span>. altitude_terrain) ; _tmp . put_f32_le (<span class="self">self </span>. bottom_clearance) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ALTITUDE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_GLOBAL_ORIGIN_DATA { <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>altitude : i32 , } <span class="kw">impl </span>GPS_GLOBAL_ORIGIN_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">12usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ latitude : <span class="number">0_i32 </span>, longitude : <span class="number">0_i32 </span>, altitude : <span class="number">0_i32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . altitude = buf . get_i32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_i32_le (<span class="self">self </span>. altitude) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GPS_GLOBAL_ORIGIN_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VIDEO_STREAM_STATUS_DATA { <span class="kw">pub </span>framerate : f32 , <span class="kw">pub </span>bitrate : u32 , <span class="kw">pub </span>flags : VideoStreamStatusFlags , <span class="kw">pub </span>resolution_h : u16 , <span class="kw">pub </span>resolution_v : u16 , <span class="kw">pub </span>rotation : u16 , <span class="kw">pub </span>hfov : u16 , <span class="kw">pub </span>stream_id : u8 , } <span class="kw">impl </span>VIDEO_STREAM_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">19usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ framerate : <span class="number">0.0_f32 </span>, bitrate : <span class="number">0_u32 </span>, flags : VideoStreamStatusFlags :: DEFAULT , resolution_h : <span class="number">0_u16 </span>, resolution_v : <span class="number">0_u16 </span>, rotation : <span class="number">0_u16 </span>, hfov : <span class="number">0_u16 </span>, stream_id : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . framerate = buf . get_f32_le () ; _struct . bitrate = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;VideoStreamStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . resolution_h = buf . get_u16_le () ; _struct . resolution_v = buf . get_u16_le () ; _struct . rotation = buf . get_u16_le () ; _struct . hfov = buf . get_u16_le () ; _struct . stream_id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. framerate) ; _tmp . put_u32_le (<span class="self">self </span>. bitrate) ; _tmp . put_u16_le (<span class="self">self </span>. flags <span class="kw">as </span>u16) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_h) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_v) ; _tmp . put_u16_le (<span class="self">self </span>. rotation) ; _tmp . put_u16_le (<span class="self">self </span>. hfov) ; _tmp . put_u8 (<span class="self">self </span>. stream_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>VIDEO_STREAM_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CONTROL_SYSTEM_STATE_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>x_acc : f32 , <span class="kw">pub </span>y_acc : f32 , <span class="kw">pub </span>z_acc : f32 , <span class="kw">pub </span>x_vel : f32 , <span class="kw">pub </span>y_vel : f32 , <span class="kw">pub </span>z_vel : f32 , <span class="kw">pub </span>x_pos : f32 , <span class="kw">pub </span>y_pos : f32 , <span class="kw">pub </span>z_pos : f32 , <span class="kw">pub </span>airspeed : f32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>vel_variance : [f32 ; <span class="number">3</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>pos_variance : [f32 ; <span class="number">3</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>roll_rate : f32 , <span class="kw">pub </span>pitch_rate : f32 , <span class="kw">pub </span>yaw_rate : f32 , } <span class="kw">impl </span>CONTROL_SYSTEM_STATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">100usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, x_acc : <span class="number">0.0_f32 </span>, y_acc : <span class="number">0.0_f32 </span>, z_acc : <span class="number">0.0_f32 </span>, x_vel : <span class="number">0.0_f32 </span>, y_vel : <span class="number">0.0_f32 </span>, z_vel : <span class="number">0.0_f32 </span>, x_pos : <span class="number">0.0_f32 </span>, y_pos : <span class="number">0.0_f32 </span>, z_pos : <span class="number">0.0_f32 </span>, airspeed : <span class="number">0.0_f32 </span>, vel_variance : [<span class="number">0.0_f32 </span>; <span class="number">3usize</span>] , pos_variance : [<span class="number">0.0_f32 </span>; <span class="number">3usize</span>] , q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , roll_rate : <span class="number">0.0_f32 </span>, pitch_rate : <span class="number">0.0_f32 </span>, yaw_rate : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . x_acc = buf . get_f32_le () ; _struct . y_acc = buf . get_f32_le () ; _struct . z_acc = buf . get_f32_le () ; _struct . x_vel = buf . get_f32_le () ; _struct . y_vel = buf . get_f32_le () ; _struct . z_vel = buf . get_f32_le () ; _struct . x_pos = buf . get_f32_le () ; _struct . y_pos = buf . get_f32_le () ; _struct . z_pos = buf . get_f32_le () ; _struct . airspeed = buf . get_f32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . vel_variance { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . pos_variance { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . roll_rate = buf . get_f32_le () ; _struct . pitch_rate = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. x_acc) ; _tmp . put_f32_le (<span class="self">self </span>. y_acc) ; _tmp . put_f32_le (<span class="self">self </span>. z_acc) ; _tmp . put_f32_le (<span class="self">self </span>. x_vel) ; _tmp . put_f32_le (<span class="self">self </span>. y_vel) ; _tmp . put_f32_le (<span class="self">self </span>. z_vel) ; _tmp . put_f32_le (<span class="self">self </span>. x_pos) ; _tmp . put_f32_le (<span class="self">self </span>. y_pos) ; _tmp . put_f32_le (<span class="self">self </span>. z_pos) ; _tmp . put_f32_le (<span class="self">self </span>. airspeed) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel_variance { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_variance { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. roll_rate) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_rate) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CONTROL_SYSTEM_STATE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CUBEPILOT_FIRMWARE_UPDATE_START_DATA { <span class="kw">pub </span>size : u32 , <span class="kw">pub </span>crc : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>CUBEPILOT_FIRMWARE_UPDATE_START_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">10usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ size : <span class="number">0_u32 </span>, crc : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . size = buf . get_u32_le () ; _struct . crc = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. size) ; _tmp . put_u32_le (<span class="self">self </span>. crc) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CUBEPILOT_FIRMWARE_UPDATE_START_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_REQUEST_LIST_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_REQUEST_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_REQUEST_LIST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AHRS3_DATA { <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>altitude : f32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lng : i32 , <span class="kw">pub </span>v1 : f32 , <span class="kw">pub </span>v2 : f32 , <span class="kw">pub </span>v3 : f32 , <span class="kw">pub </span>v4 : f32 , } <span class="kw">impl </span>AHRS3_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">40usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, altitude : <span class="number">0.0_f32 </span>, lat : <span class="number">0_i32 </span>, lng : <span class="number">0_i32 </span>, v1 : <span class="number">0.0_f32 </span>, v2 : <span class="number">0.0_f32 </span>, v3 : <span class="number">0.0_f32 </span>, v4 : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . altitude = buf . get_f32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lng = buf . get_i32_le () ; _struct . v1 = buf . get_f32_le () ; _struct . v2 = buf . get_f32_le () ; _struct . v3 = buf . get_f32_le () ; _struct . v4 = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. altitude) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lng) ; _tmp . put_f32_le (<span class="self">self </span>. v1) ; _tmp . put_f32_le (<span class="self">self </span>. v2) ; _tmp . put_f32_le (<span class="self">self </span>. v3) ; _tmp . put_f32_le (<span class="self">self </span>. v4) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>AHRS3_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DEVICE_OP_WRITE_DATA { <span class="kw">pub </span>request_id : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>bustype : DeviceOpBustype , <span class="kw">pub </span>bus : u8 , <span class="kw">pub </span>address : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>busname : [u8 ; <span class="number">40</span>] , <span class="kw">pub </span>regstart : u8 , <span class="kw">pub </span>count : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">128</span>] , } <span class="kw">impl </span>DEVICE_OP_WRITE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">179usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ request_id : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, bustype : DeviceOpBustype :: DEFAULT , bus : <span class="number">0_u8 </span>, address : <span class="number">0_u8 </span>, busname : [<span class="number">0_u8 </span>; <span class="number">40usize</span>] , regstart : <span class="number">0_u8 </span>, count : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">128usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . request_id = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . bustype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;DeviceOpBustype&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . bus = buf . get_u8 () ; _struct . address = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . busname { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } _struct . regstart = buf . get_u8 () ; _struct . count = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. request_id) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. bustype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. bus) ; _tmp . put_u8 (<span class="self">self </span>. address) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. busname { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. regstart) ; _tmp . put_u8 (<span class="self">self </span>. count) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DEVICE_OP_WRITE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ESC_TELEMETRY_5_TO_8_DATA { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>voltage : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>current : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>totalcurrent : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>rpm : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>count : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>temperature : [u8 ; <span class="number">4</span>] , } <span class="kw">impl </span>ESC_TELEMETRY_5_TO_8_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ voltage : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , current : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , totalcurrent : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , rpm : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , count : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , temperature : [<span class="number">0_u8 </span>; <span class="number">4usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . voltage { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . current { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . totalcurrent { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . rpm { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . count { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . temperature { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. voltage { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. current { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. totalcurrent { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. rpm { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. count { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. temperature { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ESC_TELEMETRY_5_TO_8_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MANUAL_SETPOINT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>thrust : f32 , <span class="kw">pub </span>mode_switch : u8 , <span class="kw">pub </span>manual_override_switch : u8 , } <span class="kw">impl </span>MANUAL_SETPOINT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, thrust : <span class="number">0.0_f32 </span>, mode_switch : <span class="number">0_u8 </span>, manual_override_switch : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . thrust = buf . get_f32_le () ; _struct . mode_switch = buf . get_u8 () ; _struct . manual_override_switch = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. thrust) ; _tmp . put_u8 (<span class="self">self </span>. mode_switch) ; _tmp . put_u8 (<span class="self">self </span>. manual_override_switch) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MANUAL_SETPOINT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>UAVCAN_NODE_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>uptime_sec : u32 , <span class="kw">pub </span>vendor_specific_status_code : u16 , <span class="kw">pub </span>health : UavcanNodeHealth , <span class="kw">pub </span>mode : UavcanNodeMode , <span class="kw">pub </span>sub_mode : u8 , } <span class="kw">impl </span>UAVCAN_NODE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">17usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, uptime_sec : <span class="number">0_u32 </span>, vendor_specific_status_code : <span class="number">0_u16 </span>, health : UavcanNodeHealth :: DEFAULT , mode : UavcanNodeMode :: DEFAULT , sub_mode : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . uptime_sec = buf . get_u32_le () ; _struct . vendor_specific_status_code = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . health = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavcanNodeHealth&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mode = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;UavcanNodeMode&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . sub_mode = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. uptime_sec) ; _tmp . put_u16_le (<span class="self">self </span>. vendor_specific_status_code) ; _tmp . put_u8 (<span class="self">self </span>. health <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mode <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. sub_mode) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>UAVCAN_NODE_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_EXT_SET_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_value : [u8 ; <span class="number">128</span>] , <span class="kw">pub </span>param_type : MavParamExtType , } <span class="kw">impl </span>PARAM_EXT_SET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">147usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, param_id : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , param_value : [<span class="number">0_u8 </span>; <span class="number">128usize</span>] , param_type : MavParamExtType :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_value { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavParamExtType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_value { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. param_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PARAM_EXT_SET_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MOUNT_STATUS_DATA { <span class="kw">pub </span>pointing_a : i32 , <span class="kw">pub </span>pointing_b : i32 , <span class="kw">pub </span>pointing_c : i32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MOUNT_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ pointing_a : <span class="number">0_i32 </span>, pointing_b : <span class="number">0_i32 </span>, pointing_c : <span class="number">0_i32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . pointing_a = buf . get_i32_le () ; _struct . pointing_b = buf . get_i32_le () ; _struct . pointing_c = buf . get_i32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. pointing_a) ; _tmp . put_i32_le (<span class="self">self </span>. pointing_b) ; _tmp . put_i32_le (<span class="self">self </span>. pointing_c) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MOUNT_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AIRSPEED_AUTOCAL_DATA { <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>diff_pressure : f32 , <span class="kw">pub </span>EAS2TAS : f32 , <span class="kw">pub </span>ratio : f32 , <span class="kw">pub </span>state_x : f32 , <span class="kw">pub </span>state_y : f32 , <span class="kw">pub </span>state_z : f32 , <span class="kw">pub </span>Pax : f32 , <span class="kw">pub </span>Pby : f32 , <span class="kw">pub </span>Pcz : f32 , } <span class="kw">impl </span>AIRSPEED_AUTOCAL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">48usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ vx : <span class="number">0.0_f32 </span>, vy : <span class="number">0.0_f32 </span>, vz : <span class="number">0.0_f32 </span>, diff_pressure : <span class="number">0.0_f32 </span>, EAS2TAS : <span class="number">0.0_f32 </span>, ratio : <span class="number">0.0_f32 </span>, state_x : <span class="number">0.0_f32 </span>, state_y : <span class="number">0.0_f32 </span>, state_z : <span class="number">0.0_f32 </span>, Pax : <span class="number">0.0_f32 </span>, Pby : <span class="number">0.0_f32 </span>, Pcz : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . diff_pressure = buf . get_f32_le () ; _struct . EAS2TAS = buf . get_f32_le () ; _struct . ratio = buf . get_f32_le () ; _struct . state_x = buf . get_f32_le () ; _struct . state_y = buf . get_f32_le () ; _struct . state_z = buf . get_f32_le () ; _struct . Pax = buf . get_f32_le () ; _struct . Pby = buf . get_f32_le () ; _struct . Pcz = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. diff_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. EAS2TAS) ; _tmp . put_f32_le (<span class="self">self </span>. ratio) ; _tmp . put_f32_le (<span class="self">self </span>. state_x) ; _tmp . put_f32_le (<span class="self">self </span>. state_y) ; _tmp . put_f32_le (<span class="self">self </span>. state_z) ; _tmp . put_f32_le (<span class="self">self </span>. Pax) ; _tmp . put_f32_le (<span class="self">self </span>. Pby) ; _tmp . put_f32_le (<span class="self">self </span>. Pcz) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>AIRSPEED_AUTOCAL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SCALED_PRESSURE_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>press_abs : f32 , <span class="kw">pub </span>press_diff : f32 , <span class="kw">pub </span>temperature : i16 , } <span class="kw">impl </span>SCALED_PRESSURE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, press_abs : <span class="number">0.0_f32 </span>, press_diff : <span class="number">0.0_f32 </span>, temperature : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . press_abs = buf . get_f32_le () ; _struct . press_diff = buf . get_f32_le () ; _struct . temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. press_abs) ; _tmp . put_f32_le (<span class="self">self </span>. press_diff) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SCALED_PRESSURE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CELLULAR_STATUS_DATA { <span class="kw">pub </span>mcc : u16 , <span class="kw">pub </span>mnc : u16 , <span class="kw">pub </span>lac : u16 , <span class="kw">pub </span>status : CellularStatusFlag , <span class="kw">pub </span>failure_reason : CellularNetworkFailedReason , <span class="kw">pub </span>mavtype : CellularNetworkRadioType , <span class="kw">pub </span>quality : u8 , } <span class="kw">impl </span>CELLULAR_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">10usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ mcc : <span class="number">0_u16 </span>, mnc : <span class="number">0_u16 </span>, lac : <span class="number">0_u16 </span>, status : CellularStatusFlag :: DEFAULT , failure_reason : CellularNetworkFailedReason :: DEFAULT , mavtype : CellularNetworkRadioType :: DEFAULT , quality : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . mcc = buf . get_u16_le () ; _struct . mnc = buf . get_u16_le () ; _struct . lac = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CellularStatusFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . failure_reason = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CellularNetworkFailedReason&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CellularNetworkRadioType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . quality = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. mcc) ; _tmp . put_u16_le (<span class="self">self </span>. mnc) ; _tmp . put_u16_le (<span class="self">self </span>. lac) ; _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. failure_reason <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. quality) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CELLULAR_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SYS_STATUS_DATA { <span class="kw">pub </span>onboard_control_sensors_present : MavSysStatusSensor , <span class="kw">pub </span>onboard_control_sensors_enabled : MavSysStatusSensor , <span class="kw">pub </span>onboard_control_sensors_health : MavSysStatusSensor , <span class="kw">pub </span>load : u16 , <span class="kw">pub </span>voltage_battery : u16 , <span class="kw">pub </span>current_battery : i16 , <span class="kw">pub </span>drop_rate_comm : u16 , <span class="kw">pub </span>errors_comm : u16 , <span class="kw">pub </span>errors_count1 : u16 , <span class="kw">pub </span>errors_count2 : u16 , <span class="kw">pub </span>errors_count3 : u16 , <span class="kw">pub </span>errors_count4 : u16 , <span class="kw">pub </span>battery_remaining : i8 , } <span class="kw">impl </span>SYS_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">31usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ onboard_control_sensors_present : MavSysStatusSensor :: DEFAULT , onboard_control_sensors_enabled : MavSysStatusSensor :: DEFAULT , onboard_control_sensors_health : MavSysStatusSensor :: DEFAULT , load : <span class="number">0_u16 </span>, voltage_battery : <span class="number">0_u16 </span>, current_battery : <span class="number">0_i16 </span>, drop_rate_comm : <span class="number">0_u16 </span>, errors_comm : <span class="number">0_u16 </span>, errors_count1 : <span class="number">0_u16 </span>, errors_count2 : <span class="number">0_u16 </span>, errors_count3 : <span class="number">0_u16 </span>, errors_count4 : <span class="number">0_u16 </span>, battery_remaining : <span class="number">0_i8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . onboard_control_sensors_present = MavSysStatusSensor :: from_bits (tmp &amp; MavSysStatusSensor :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavSysStatusSensor&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . onboard_control_sensors_enabled = MavSysStatusSensor :: from_bits (tmp &amp; MavSysStatusSensor :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavSysStatusSensor&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . onboard_control_sensors_health = MavSysStatusSensor :: from_bits (tmp &amp; MavSysStatusSensor :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavSysStatusSensor&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . load = buf . get_u16_le () ; _struct . voltage_battery = buf . get_u16_le () ; _struct . current_battery = buf . get_i16_le () ; _struct . drop_rate_comm = buf . get_u16_le () ; _struct . errors_comm = buf . get_u16_le () ; _struct . errors_count1 = buf . get_u16_le () ; _struct . errors_count2 = buf . get_u16_le () ; _struct . errors_count3 = buf . get_u16_le () ; _struct . errors_count4 = buf . get_u16_le () ; _struct . battery_remaining = buf . get_i8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. onboard_control_sensors_present . bits ()) ; _tmp . put_u32_le (<span class="self">self </span>. onboard_control_sensors_enabled . bits ()) ; _tmp . put_u32_le (<span class="self">self </span>. onboard_control_sensors_health . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. load) ; _tmp . put_u16_le (<span class="self">self </span>. voltage_battery) ; _tmp . put_i16_le (<span class="self">self </span>. current_battery) ; _tmp . put_u16_le (<span class="self">self </span>. drop_rate_comm) ; _tmp . put_u16_le (<span class="self">self </span>. errors_comm) ; _tmp . put_u16_le (<span class="self">self </span>. errors_count1) ; _tmp . put_u16_le (<span class="self">self </span>. errors_count2) ; _tmp . put_u16_le (<span class="self">self </span>. errors_count3) ; _tmp . put_u16_le (<span class="self">self </span>. errors_count4) ; _tmp . put_i8 (<span class="self">self </span>. battery_remaining) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SYS_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TRAJECTORY_REPRESENTATION_BEZIER_DATA { <span class="kw">pub </span>time_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>pos_x : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>pos_y : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>pos_z : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>delta : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>pos_yaw : [f32 ; <span class="number">5</span>] , <span class="kw">pub </span>valid_points : u8 , } <span class="kw">impl </span>TRAJECTORY_REPRESENTATION_BEZIER_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">109usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, pos_x : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , pos_y : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , pos_z : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , delta : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , pos_yaw : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , valid_points : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . pos_x { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . pos_y { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . pos_z { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . delta { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . pos_yaw { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . valid_points = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_x { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_y { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_z { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. delta { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_yaw { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. valid_points) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>TRAJECTORY_REPRESENTATION_BEZIER_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TIMESYNC_DATA { <span class="kw">pub </span>tc1 : i64 , <span class="kw">pub </span>ts1 : i64 , } <span class="kw">impl </span>TIMESYNC_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">16usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ tc1 : <span class="number">0_i64 </span>, ts1 : <span class="number">0_i64 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . tc1 = buf . get_i64_le () ; _struct . ts1 = buf . get_i64_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i64_le (<span class="self">self </span>. tc1) ; _tmp . put_i64_le (<span class="self">self </span>. ts1) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>TIMESYNC_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MOUNT_CONTROL_DATA { <span class="kw">pub </span>input_a : i32 , <span class="kw">pub </span>input_b : i32 , <span class="kw">pub </span>input_c : i32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>save_position : u8 , } <span class="kw">impl </span>MOUNT_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">15usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ input_a : <span class="number">0_i32 </span>, input_b : <span class="number">0_i32 </span>, input_c : <span class="number">0_i32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, save_position : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . input_a = buf . get_i32_le () ; _struct . input_b = buf . get_i32_le () ; _struct . input_c = buf . get_i32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . save_position = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. input_a) ; _tmp . put_i32_le (<span class="self">self </span>. input_b) ; _tmp . put_i32_le (<span class="self">self </span>. input_c) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. save_position) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MOUNT_CONTROL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_FEEDBACK_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lng : i32 , <span class="kw">pub </span>alt_msl : f32 , <span class="kw">pub </span>alt_rel : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>foc_len : f32 , <span class="kw">pub </span>img_idx : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>cam_idx : u8 , <span class="kw">pub </span>flags : CameraFeedbackFlags , } <span class="kw">impl </span>CAMERA_FEEDBACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">45usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, lat : <span class="number">0_i32 </span>, lng : <span class="number">0_i32 </span>, alt_msl : <span class="number">0.0_f32 </span>, alt_rel : <span class="number">0.0_f32 </span>, roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, foc_len : <span class="number">0.0_f32 </span>, img_idx : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, cam_idx : <span class="number">0_u8 </span>, flags : CameraFeedbackFlags :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lng = buf . get_i32_le () ; _struct . alt_msl = buf . get_f32_le () ; _struct . alt_rel = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . foc_len = buf . get_f32_le () ; _struct . img_idx = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . cam_idx = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . flags = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraFeedbackFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lng) ; _tmp . put_f32_le (<span class="self">self </span>. alt_msl) ; _tmp . put_f32_le (<span class="self">self </span>. alt_rel) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. foc_len) ; _tmp . put_u16_le (<span class="self">self </span>. img_idx) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. cam_idx) ; _tmp . put_u8 (<span class="self">self </span>. flags <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAMERA_FEEDBACK_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>BUTTON_CHANGE_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>last_change_ms : u32 , <span class="kw">pub </span>state : u8 , } <span class="kw">impl </span>BUTTON_CHANGE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">9usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, last_change_ms : <span class="number">0_u32 </span>, state : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . last_change_ms = buf . get_u32_le () ; _struct . state = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. last_change_ms) ; _tmp . put_u8 (<span class="self">self </span>. state) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>BUTTON_CHANGE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>p1 : f32 , <span class="kw">pub </span>p2 : f32 , <span class="kw">pub </span>p3 : f32 , <span class="kw">pub </span>p4 : f32 , <span class="kw">pub </span>img_idx : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>cam_idx : u8 , <span class="kw">pub </span>event_id : CameraStatusTypes , } <span class="kw">impl </span>CAMERA_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">29usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, p1 : <span class="number">0.0_f32 </span>, p2 : <span class="number">0.0_f32 </span>, p3 : <span class="number">0.0_f32 </span>, p4 : <span class="number">0.0_f32 </span>, img_idx : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, cam_idx : <span class="number">0_u8 </span>, event_id : CameraStatusTypes :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . p1 = buf . get_f32_le () ; _struct . p2 = buf . get_f32_le () ; _struct . p3 = buf . get_f32_le () ; _struct . p4 = buf . get_f32_le () ; _struct . img_idx = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . cam_idx = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . event_id = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraStatusTypes&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. p1) ; _tmp . put_f32_le (<span class="self">self </span>. p2) ; _tmp . put_f32_le (<span class="self">self </span>. p3) ; _tmp . put_f32_le (<span class="self">self </span>. p4) ; _tmp . put_u16_le (<span class="self">self </span>. img_idx) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. cam_idx) ; _tmp . put_u8 (<span class="self">self </span>. event_id <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAMERA_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_POSITION_TARGET_LOCAL_NED_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>afx : f32 , <span class="kw">pub </span>afy : f32 , <span class="kw">pub </span>afz : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>type_mask : PositionTargetTypemask , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>coordinate_frame : MavFrame , } <span class="kw">impl </span>SET_POSITION_TARGET_LOCAL_NED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, vx : <span class="number">0.0_f32 </span>, vy : <span class="number">0.0_f32 </span>, vz : <span class="number">0.0_f32 </span>, afx : <span class="number">0.0_f32 </span>, afy : <span class="number">0.0_f32 </span>, afz : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, yaw_rate : <span class="number">0.0_f32 </span>, type_mask : PositionTargetTypemask :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, coordinate_frame : MavFrame :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . afx = buf . get_f32_le () ; _struct . afy = buf . get_f32_le () ; _struct . afz = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . type_mask = PositionTargetTypemask :: from_bits (tmp &amp; PositionTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;PositionTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . coordinate_frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. afx) ; _tmp . put_f32_le (<span class="self">self </span>. afy) ; _tmp . put_f32_le (<span class="self">self </span>. afz) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u16_le (<span class="self">self </span>. type_mask . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. coordinate_frame <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SET_POSITION_TARGET_LOCAL_NED_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ODOMETRY_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>pose_covariance : [f32 ; <span class="number">21</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>velocity_covariance : [f32 ; <span class="number">21</span>] , <span class="kw">pub </span>frame_id : MavFrame , <span class="kw">pub </span>child_frame_id : MavFrame , } <span class="kw">impl </span>ODOMETRY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">230usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , vx : <span class="number">0.0_f32 </span>, vy : <span class="number">0.0_f32 </span>, vz : <span class="number">0.0_f32 </span>, rollspeed : <span class="number">0.0_f32 </span>, pitchspeed : <span class="number">0.0_f32 </span>, yawspeed : <span class="number">0.0_f32 </span>, pose_covariance : [<span class="number">0.0_f32 </span>; <span class="number">21usize</span>] , velocity_covariance : [<span class="number">0.0_f32 </span>; <span class="number">21usize</span>] , frame_id : MavFrame :: DEFAULT , child_frame_id : MavFrame :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . pose_covariance { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . velocity_covariance { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame_id = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . child_frame_id = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pose_covariance { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. velocity_covariance { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. frame_id <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. child_frame_id <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ODOMETRY_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_RAW_INT_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>eph : u16 , <span class="kw">pub </span>epv : u16 , <span class="kw">pub </span>vel : u16 , <span class="kw">pub </span>cog : u16 , <span class="kw">pub </span>fix_type : GpsFixType , <span class="kw">pub </span>satellites_visible : u8 , } <span class="kw">impl </span>GPS_RAW_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">30usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0_i32 </span>, eph : <span class="number">0_u16 </span>, epv : <span class="number">0_u16 </span>, vel : <span class="number">0_u16 </span>, cog : <span class="number">0_u16 </span>, fix_type : GpsFixType :: DEFAULT , satellites_visible : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . eph = buf . get_u16_le () ; _struct . epv = buf . get_u16_le () ; _struct . vel = buf . get_u16_le () ; _struct . cog = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . fix_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GpsFixType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . satellites_visible = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_u16_le (<span class="self">self </span>. eph) ; _tmp . put_u16_le (<span class="self">self </span>. epv) ; _tmp . put_u16_le (<span class="self">self </span>. vel) ; _tmp . put_u16_le (<span class="self">self </span>. cog) ; _tmp . put_u8 (<span class="self">self </span>. fix_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. satellites_visible) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GPS_RAW_INT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_TORQUE_CMD_REPORT_DATA { <span class="kw">pub </span>rl_torque_cmd : i16 , <span class="kw">pub </span>el_torque_cmd : i16 , <span class="kw">pub </span>az_torque_cmd : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>GIMBAL_TORQUE_CMD_REPORT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">8usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ rl_torque_cmd : <span class="number">0_i16 </span>, el_torque_cmd : <span class="number">0_i16 </span>, az_torque_cmd : <span class="number">0_i16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . rl_torque_cmd = buf . get_i16_le () ; _struct . el_torque_cmd = buf . get_i16_le () ; _struct . az_torque_cmd = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. rl_torque_cmd) ; _tmp . put_i16_le (<span class="self">self </span>. el_torque_cmd) ; _tmp . put_i16_le (<span class="self">self </span>. az_torque_cmd) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GIMBAL_TORQUE_CMD_REPORT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OSD_PARAM_CONFIG_DATA { <span class="kw">pub </span>request_id : u32 , <span class="kw">pub </span>min_value : f32 , <span class="kw">pub </span>max_value : f32 , <span class="kw">pub </span>increment : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>osd_screen : u8 , <span class="kw">pub </span>osd_index : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>config_type : OsdParamConfigType , } <span class="kw">impl </span>OSD_PARAM_CONFIG_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ request_id : <span class="number">0_u32 </span>, min_value : <span class="number">0.0_f32 </span>, max_value : <span class="number">0.0_f32 </span>, increment : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, osd_screen : <span class="number">0_u8 </span>, osd_index : <span class="number">0_u8 </span>, param_id : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , config_type : OsdParamConfigType :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . request_id = buf . get_u32_le () ; _struct . min_value = buf . get_f32_le () ; _struct . max_value = buf . get_f32_le () ; _struct . increment = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . osd_screen = buf . get_u8 () ; _struct . osd_index = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . config_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;OsdParamConfigType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. request_id) ; _tmp . put_f32_le (<span class="self">self </span>. min_value) ; _tmp . put_f32_le (<span class="self">self </span>. max_value) ; _tmp . put_f32_le (<span class="self">self </span>. increment) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. osd_screen) ; _tmp . put_u8 (<span class="self">self </span>. osd_index) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. config_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OSD_PARAM_CONFIG_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DATA16_DATA { <span class="kw">pub </span>mavtype : u8 , <span class="kw">pub </span>len : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">16</span>] , } <span class="kw">impl </span>DATA16_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ mavtype : <span class="number">0_u8 </span>, len : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . mavtype = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. mavtype) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DATA16_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PID_TUNING_DATA { <span class="kw">pub </span>desired : f32 , <span class="kw">pub </span>achieved : f32 , <span class="kw">pub </span>FF : f32 , <span class="kw">pub </span>P : f32 , <span class="kw">pub </span>I : f32 , <span class="kw">pub </span>D : f32 , <span class="kw">pub </span>axis : PidTuningAxis , } <span class="kw">impl </span>PID_TUNING_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">25usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ desired : <span class="number">0.0_f32 </span>, achieved : <span class="number">0.0_f32 </span>, FF : <span class="number">0.0_f32 </span>, P : <span class="number">0.0_f32 </span>, I : <span class="number">0.0_f32 </span>, D : <span class="number">0.0_f32 </span>, axis : PidTuningAxis :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . desired = buf . get_f32_le () ; _struct . achieved = buf . get_f32_le () ; _struct . FF = buf . get_f32_le () ; _struct . P = buf . get_f32_le () ; _struct . I = buf . get_f32_le () ; _struct . D = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . axis = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;PidTuningAxis&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. desired) ; _tmp . put_f32_le (<span class="self">self </span>. achieved) ; _tmp . put_f32_le (<span class="self">self </span>. FF) ; _tmp . put_f32_le (<span class="self">self </span>. P) ; _tmp . put_f32_le (<span class="self">self </span>. I) ; _tmp . put_f32_le (<span class="self">self </span>. D) ; _tmp . put_u8 (<span class="self">self </span>. axis <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PID_TUNING_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OBSTACLE_DISTANCE_DATA { <span class="kw">pub </span>time_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>distances : [u16 ; <span class="number">72</span>] , <span class="kw">pub </span>min_distance : u16 , <span class="kw">pub </span>max_distance : u16 , <span class="kw">pub </span>sensor_type : MavDistanceSensor , <span class="kw">pub </span>increment : u8 , } <span class="kw">impl </span>OBSTACLE_DISTANCE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">158usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, distances : [<span class="number">0_u16 </span>; <span class="number">72usize</span>] , min_distance : <span class="number">0_u16 </span>, max_distance : <span class="number">0_u16 </span>, sensor_type : MavDistanceSensor :: DEFAULT , increment : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . distances { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } _struct . min_distance = buf . get_u16_le () ; _struct . max_distance = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . sensor_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavDistanceSensor&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . increment = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. distances { _tmp . put_u16_le (* val) ; } _tmp . put_u16_le (<span class="self">self </span>. min_distance) ; _tmp . put_u16_le (<span class="self">self </span>. max_distance) ; _tmp . put_u8 (<span class="self">self </span>. sensor_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. increment) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OBSTACLE_DISTANCE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMMAND_INT_DATA { <span class="kw">pub </span>param1 : f32 , <span class="kw">pub </span>param2 : f32 , <span class="kw">pub </span>param3 : f32 , <span class="kw">pub </span>param4 : f32 , <span class="kw">pub </span>x : i32 , <span class="kw">pub </span>y : i32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>frame : MavFrame , <span class="kw">pub </span>current : u8 , <span class="kw">pub </span>autocontinue : u8 , } <span class="kw">impl </span>COMMAND_INT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">35usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ param1 : <span class="number">0.0_f32 </span>, param2 : <span class="number">0.0_f32 </span>, param3 : <span class="number">0.0_f32 </span>, param4 : <span class="number">0.0_f32 </span>, x : <span class="number">0_i32 </span>, y : <span class="number">0_i32 </span>, z : <span class="number">0.0_f32 </span>, command : MavCmd :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, frame : MavFrame :: DEFAULT , current : <span class="number">0_u8 </span>, autocontinue : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param1 = buf . get_f32_le () ; _struct . param2 = buf . get_f32_le () ; _struct . param3 = buf . get_f32_le () ; _struct . param4 = buf . get_f32_le () ; _struct . x = buf . get_i32_le () ; _struct . y = buf . get_i32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . current = buf . get_u8 () ; _struct . autocontinue = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param1) ; _tmp . put_f32_le (<span class="self">self </span>. param2) ; _tmp . put_f32_le (<span class="self">self </span>. param3) ; _tmp . put_f32_le (<span class="self">self </span>. param4) ; _tmp . put_i32_le (<span class="self">self </span>. x) ; _tmp . put_i32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. current) ; _tmp . put_u8 (<span class="self">self </span>. autocontinue) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>COMMAND_INT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMMAND_ACK_DATA { <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>result : MavResult , } <span class="kw">impl </span>COMMAND_ACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ command : MavCmd :: DEFAULT , result : MavResult :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . result = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavResult&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. result <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>COMMAND_ACK_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ICAROUS_HEARTBEAT_DATA { <span class="kw">pub </span>status : IcarousFmsState , } <span class="kw">impl </span>ICAROUS_HEARTBEAT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">1usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ status : IcarousFmsState :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;IcarousFmsState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ICAROUS_HEARTBEAT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_SET_CURRENT_DATA { <span class="kw">pub </span>seq : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_SET_CURRENT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ seq : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seq = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_SET_CURRENT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>TRAJECTORY_REPRESENTATION_WAYPOINTS_DATA { <span class="kw">pub </span>time_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>pos_x : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>pos_y : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>pos_z : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>vel_x : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>vel_y : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>vel_z : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>acc_x : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>acc_y : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>acc_z : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>pos_yaw : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>vel_yaw : [f32 ; <span class="number">5</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>command : [u16 ; <span class="number">5</span>] , <span class="kw">pub </span>valid_points : u8 , } <span class="kw">impl </span>TRAJECTORY_REPRESENTATION_WAYPOINTS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">239usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, pos_x : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , pos_y : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , pos_z : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , vel_x : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , vel_y : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , vel_z : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , acc_x : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , acc_y : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , acc_z : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , pos_yaw : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , vel_yaw : [<span class="number">0.0_f32 </span>; <span class="number">5usize</span>] , command : [<span class="number">0_u16 </span>; <span class="number">5usize</span>] , valid_points : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . pos_x { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . pos_y { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . pos_z { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . vel_x { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . vel_y { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . vel_z { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . acc_x { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . acc_y { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . acc_z { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . pos_yaw { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . vel_yaw { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . command { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } _struct . valid_points = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_x { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_y { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_z { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel_x { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel_y { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel_z { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. acc_x { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. acc_y { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. acc_z { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pos_yaw { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. vel_yaw { _tmp . put_f32_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. command { _tmp . put_u16_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. valid_points) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>TRAJECTORY_REPRESENTATION_WAYPOINTS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>WINCH_STATUS_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>line_length : f32 , <span class="kw">pub </span>speed : f32 , <span class="kw">pub </span>tension : f32 , <span class="kw">pub </span>voltage : f32 , <span class="kw">pub </span>current : f32 , <span class="kw">pub </span>status : MavWinchStatusFlag , <span class="kw">pub </span>temperature : i16 , } <span class="kw">impl </span>WINCH_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">34usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, line_length : <span class="number">0.0_f32 </span>, speed : <span class="number">0.0_f32 </span>, tension : <span class="number">0.0_f32 </span>, voltage : <span class="number">0.0_f32 </span>, current : <span class="number">0.0_f32 </span>, status : MavWinchStatusFlag :: DEFAULT , temperature : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . line_length = buf . get_f32_le () ; _struct . speed = buf . get_f32_le () ; _struct . tension = buf . get_f32_le () ; _struct . voltage = buf . get_f32_le () ; _struct . current = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . status = MavWinchStatusFlag :: from_bits (tmp &amp; MavWinchStatusFlag :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavWinchStatusFlag&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . temperature = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. line_length) ; _tmp . put_f32_le (<span class="self">self </span>. speed) ; _tmp . put_f32_le (<span class="self">self </span>. tension) ; _tmp . put_f32_le (<span class="self">self </span>. voltage) ; _tmp . put_f32_le (<span class="self">self </span>. current) ; _tmp . put_u32_le (<span class="self">self </span>. status . bits ()) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>WINCH_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_EXT_REQUEST_LIST_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>PARAM_EXT_REQUEST_LIST_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PARAM_EXT_REQUEST_LIST_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ICAROUS_KINEMATIC_BANDS_DATA { <span class="kw">pub </span>min1 : f32 , <span class="kw">pub </span>max1 : f32 , <span class="kw">pub </span>min2 : f32 , <span class="kw">pub </span>max2 : f32 , <span class="kw">pub </span>min3 : f32 , <span class="kw">pub </span>max3 : f32 , <span class="kw">pub </span>min4 : f32 , <span class="kw">pub </span>max4 : f32 , <span class="kw">pub </span>min5 : f32 , <span class="kw">pub </span>max5 : f32 , <span class="kw">pub </span>numBands : i8 , <span class="kw">pub </span>type1 : IcarousTrackBandTypes , <span class="kw">pub </span>type2 : IcarousTrackBandTypes , <span class="kw">pub </span>type3 : IcarousTrackBandTypes , <span class="kw">pub </span>type4 : IcarousTrackBandTypes , <span class="kw">pub </span>type5 : IcarousTrackBandTypes , } <span class="kw">impl </span>ICAROUS_KINEMATIC_BANDS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">46usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ min1 : <span class="number">0.0_f32 </span>, max1 : <span class="number">0.0_f32 </span>, min2 : <span class="number">0.0_f32 </span>, max2 : <span class="number">0.0_f32 </span>, min3 : <span class="number">0.0_f32 </span>, max3 : <span class="number">0.0_f32 </span>, min4 : <span class="number">0.0_f32 </span>, max4 : <span class="number">0.0_f32 </span>, min5 : <span class="number">0.0_f32 </span>, max5 : <span class="number">0.0_f32 </span>, numBands : <span class="number">0_i8 </span>, type1 : IcarousTrackBandTypes :: DEFAULT , type2 : IcarousTrackBandTypes :: DEFAULT , type3 : IcarousTrackBandTypes :: DEFAULT , type4 : IcarousTrackBandTypes :: DEFAULT , type5 : IcarousTrackBandTypes :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . min1 = buf . get_f32_le () ; _struct . max1 = buf . get_f32_le () ; _struct . min2 = buf . get_f32_le () ; _struct . max2 = buf . get_f32_le () ; _struct . min3 = buf . get_f32_le () ; _struct . max3 = buf . get_f32_le () ; _struct . min4 = buf . get_f32_le () ; _struct . max4 = buf . get_f32_le () ; _struct . min5 = buf . get_f32_le () ; _struct . max5 = buf . get_f32_le () ; _struct . numBands = buf . get_i8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . type1 = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;IcarousTrackBandTypes&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . type2 = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;IcarousTrackBandTypes&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . type3 = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;IcarousTrackBandTypes&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . type4 = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;IcarousTrackBandTypes&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . type5 = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;IcarousTrackBandTypes&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. min1) ; _tmp . put_f32_le (<span class="self">self </span>. max1) ; _tmp . put_f32_le (<span class="self">self </span>. min2) ; _tmp . put_f32_le (<span class="self">self </span>. max2) ; _tmp . put_f32_le (<span class="self">self </span>. min3) ; _tmp . put_f32_le (<span class="self">self </span>. max3) ; _tmp . put_f32_le (<span class="self">self </span>. min4) ; _tmp . put_f32_le (<span class="self">self </span>. max4) ; _tmp . put_f32_le (<span class="self">self </span>. min5) ; _tmp . put_f32_le (<span class="self">self </span>. max5) ; _tmp . put_i8 (<span class="self">self </span>. numBands) ; _tmp . put_u8 (<span class="self">self </span>. type1 <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. type2 <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. type3 <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. type4 <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. type5 <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ICAROUS_KINEMATIC_BANDS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CUBEPILOT_FIRMWARE_UPDATE_RESP_DATA { <span class="kw">pub </span>offset : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>CUBEPILOT_FIRMWARE_UPDATE_RESP_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ offset : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . offset = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. offset) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CUBEPILOT_FIRMWARE_UPDATE_RESP_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AHRS_DATA { <span class="kw">pub </span>omegaIx : f32 , <span class="kw">pub </span>omegaIy : f32 , <span class="kw">pub </span>omegaIz : f32 , <span class="kw">pub </span>accel_weight : f32 , <span class="kw">pub </span>renorm_val : f32 , <span class="kw">pub </span>error_rp : f32 , <span class="kw">pub </span>error_yaw : f32 , } <span class="kw">impl </span>AHRS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ omegaIx : <span class="number">0.0_f32 </span>, omegaIy : <span class="number">0.0_f32 </span>, omegaIz : <span class="number">0.0_f32 </span>, accel_weight : <span class="number">0.0_f32 </span>, renorm_val : <span class="number">0.0_f32 </span>, error_rp : <span class="number">0.0_f32 </span>, error_yaw : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . omegaIx = buf . get_f32_le () ; _struct . omegaIy = buf . get_f32_le () ; _struct . omegaIz = buf . get_f32_le () ; _struct . accel_weight = buf . get_f32_le () ; _struct . renorm_val = buf . get_f32_le () ; _struct . error_rp = buf . get_f32_le () ; _struct . error_yaw = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. omegaIx) ; _tmp . put_f32_le (<span class="self">self </span>. omegaIy) ; _tmp . put_f32_le (<span class="self">self </span>. omegaIz) ; _tmp . put_f32_le (<span class="self">self </span>. accel_weight) ; _tmp . put_f32_le (<span class="self">self </span>. renorm_val) ; _tmp . put_f32_le (<span class="self">self </span>. error_rp) ; _tmp . put_f32_le (<span class="self">self </span>. error_yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>AHRS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAN_FILTER_MODIFY_DATA { # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>ids : [u16 ; <span class="number">16</span>] , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>bus : u8 , <span class="kw">pub </span>operation : CanFilterOp , <span class="kw">pub </span>num_ids : u8 , } <span class="kw">impl </span>CAN_FILTER_MODIFY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ ids : [<span class="number">0_u16 </span>; <span class="number">16usize</span>] , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, bus : <span class="number">0_u8 </span>, operation : CanFilterOp :: DEFAULT , num_ids : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . ids { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . bus = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . operation = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CanFilterOp&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . num_ids = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. ids { _tmp . put_u16_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. bus) ; _tmp . put_u8 (<span class="self">self </span>. operation <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. num_ids) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAN_FILTER_MODIFY_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_HOME_POSITION_DATA { <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>altitude : i32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>approach_x : f32 , <span class="kw">pub </span>approach_y : f32 , <span class="kw">pub </span>approach_z : f32 , <span class="kw">pub </span>target_system : u8 , } <span class="kw">impl </span>SET_HOME_POSITION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ latitude : <span class="number">0_i32 </span>, longitude : <span class="number">0_i32 </span>, altitude : <span class="number">0_i32 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , approach_x : <span class="number">0.0_f32 </span>, approach_y : <span class="number">0.0_f32 </span>, approach_z : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . altitude = buf . get_i32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . approach_x = buf . get_f32_le () ; _struct . approach_y = buf . get_f32_le () ; _struct . approach_z = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_i32_le (<span class="self">self </span>. altitude) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. approach_x) ; _tmp . put_f32_le (<span class="self">self </span>. approach_y) ; _tmp . put_f32_le (<span class="self">self </span>. approach_z) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SET_HOME_POSITION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_STATUS_DATA { <span class="kw">pub </span>satellites_visible : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>satellite_prn : [u8 ; <span class="number">20</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>satellite_used : [u8 ; <span class="number">20</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>satellite_elevation : [u8 ; <span class="number">20</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>satellite_azimuth : [u8 ; <span class="number">20</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>satellite_snr : [u8 ; <span class="number">20</span>] , } <span class="kw">impl </span>GPS_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">101usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ satellites_visible : <span class="number">0_u8 </span>, satellite_prn : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , satellite_used : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , satellite_elevation : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , satellite_azimuth : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , satellite_snr : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . satellites_visible = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . satellite_prn { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . satellite_used { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . satellite_elevation { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . satellite_azimuth { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . satellite_snr { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. satellites_visible) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. satellite_prn { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. satellite_used { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. satellite_elevation { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. satellite_azimuth { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. satellite_snr { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GPS_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RAW_IMU_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>xacc : i16 , <span class="kw">pub </span>yacc : i16 , <span class="kw">pub </span>zacc : i16 , <span class="kw">pub </span>xgyro : i16 , <span class="kw">pub </span>ygyro : i16 , <span class="kw">pub </span>zgyro : i16 , <span class="kw">pub </span>xmag : i16 , <span class="kw">pub </span>ymag : i16 , <span class="kw">pub </span>zmag : i16 , } <span class="kw">impl </span>RAW_IMU_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">26usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, xacc : <span class="number">0_i16 </span>, yacc : <span class="number">0_i16 </span>, zacc : <span class="number">0_i16 </span>, xgyro : <span class="number">0_i16 </span>, ygyro : <span class="number">0_i16 </span>, zgyro : <span class="number">0_i16 </span>, xmag : <span class="number">0_i16 </span>, ymag : <span class="number">0_i16 </span>, zmag : <span class="number">0_i16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . xacc = buf . get_i16_le () ; _struct . yacc = buf . get_i16_le () ; _struct . zacc = buf . get_i16_le () ; _struct . xgyro = buf . get_i16_le () ; _struct . ygyro = buf . get_i16_le () ; _struct . zgyro = buf . get_i16_le () ; _struct . xmag = buf . get_i16_le () ; _struct . ymag = buf . get_i16_le () ; _struct . zmag = buf . get_i16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i16_le (<span class="self">self </span>. xacc) ; _tmp . put_i16_le (<span class="self">self </span>. yacc) ; _tmp . put_i16_le (<span class="self">self </span>. zacc) ; _tmp . put_i16_le (<span class="self">self </span>. xgyro) ; _tmp . put_i16_le (<span class="self">self </span>. ygyro) ; _tmp . put_i16_le (<span class="self">self </span>. zgyro) ; _tmp . put_i16_le (<span class="self">self </span>. xmag) ; _tmp . put_i16_le (<span class="self">self </span>. ymag) ; _tmp . put_i16_le (<span class="self">self </span>. zmag) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RAW_IMU_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GOPRO_SET_RESPONSE_DATA { <span class="kw">pub </span>cmd_id : GoproCommand , <span class="kw">pub </span>status : GoproRequestStatus , } <span class="kw">impl </span>GOPRO_SET_RESPONSE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ cmd_id : GoproCommand :: DEFAULT , status : GoproRequestStatus :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . cmd_id = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GoproCommand&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GoproRequestStatus&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. cmd_id <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. status <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GOPRO_SET_RESPONSE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOGGING_DATA_DATA { <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>length : u8 , <span class="kw">pub </span>first_message_offset : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">249</span>] , } <span class="kw">impl </span>LOGGING_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">255usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ sequence : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, length : <span class="number">0_u8 </span>, first_message_offset : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">249usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . sequence = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . length = buf . get_u8 () ; _struct . first_message_offset = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. length) ; _tmp . put_u8 (<span class="self">self </span>. first_message_offset) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOGGING_DATA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SIMSTATE_DATA { <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>xacc : f32 , <span class="kw">pub </span>yacc : f32 , <span class="kw">pub </span>zacc : f32 , <span class="kw">pub </span>xgyro : f32 , <span class="kw">pub </span>ygyro : f32 , <span class="kw">pub </span>zgyro : f32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lng : i32 , } <span class="kw">impl </span>SIMSTATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, xacc : <span class="number">0.0_f32 </span>, yacc : <span class="number">0.0_f32 </span>, zacc : <span class="number">0.0_f32 </span>, xgyro : <span class="number">0.0_f32 </span>, ygyro : <span class="number">0.0_f32 </span>, zgyro : <span class="number">0.0_f32 </span>, lat : <span class="number">0_i32 </span>, lng : <span class="number">0_i32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . xacc = buf . get_f32_le () ; _struct . yacc = buf . get_f32_le () ; _struct . zacc = buf . get_f32_le () ; _struct . xgyro = buf . get_f32_le () ; _struct . ygyro = buf . get_f32_le () ; _struct . zgyro = buf . get_f32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lng = buf . get_i32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. xacc) ; _tmp . put_f32_le (<span class="self">self </span>. yacc) ; _tmp . put_f32_le (<span class="self">self </span>. zacc) ; _tmp . put_f32_le (<span class="self">self </span>. xgyro) ; _tmp . put_f32_le (<span class="self">self </span>. ygyro) ; _tmp . put_f32_le (<span class="self">self </span>. zgyro) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lng) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SIMSTATE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ATTITUDE_QUATERNION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>q1 : f32 , <span class="kw">pub </span>q2 : f32 , <span class="kw">pub </span>q3 : f32 , <span class="kw">pub </span>q4 : f32 , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , } <span class="kw">impl </span>ATTITUDE_QUATERNION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, q1 : <span class="number">0.0_f32 </span>, q2 : <span class="number">0.0_f32 </span>, q3 : <span class="number">0.0_f32 </span>, q4 : <span class="number">0.0_f32 </span>, rollspeed : <span class="number">0.0_f32 </span>, pitchspeed : <span class="number">0.0_f32 </span>, yawspeed : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . q1 = buf . get_f32_le () ; _struct . q2 = buf . get_f32_le () ; _struct . q3 = buf . get_f32_le () ; _struct . q4 = buf . get_f32_le () ; _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. q1) ; _tmp . put_f32_le (<span class="self">self </span>. q2) ; _tmp . put_f32_le (<span class="self">self </span>. q3) ; _tmp . put_f32_le (<span class="self">self </span>. q4) ; _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ATTITUDE_QUATERNION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_OPTICAL_FLOW_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>integration_time_us : u32 , <span class="kw">pub </span>integrated_x : f32 , <span class="kw">pub </span>integrated_y : f32 , <span class="kw">pub </span>integrated_xgyro : f32 , <span class="kw">pub </span>integrated_ygyro : f32 , <span class="kw">pub </span>integrated_zgyro : f32 , <span class="kw">pub </span>time_delta_distance_us : u32 , <span class="kw">pub </span>distance : f32 , <span class="kw">pub </span>temperature : i16 , <span class="kw">pub </span>sensor_id : u8 , <span class="kw">pub </span>quality : u8 , } <span class="kw">impl </span>HIL_OPTICAL_FLOW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">44usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, integration_time_us : <span class="number">0_u32 </span>, integrated_x : <span class="number">0.0_f32 </span>, integrated_y : <span class="number">0.0_f32 </span>, integrated_xgyro : <span class="number">0.0_f32 </span>, integrated_ygyro : <span class="number">0.0_f32 </span>, integrated_zgyro : <span class="number">0.0_f32 </span>, time_delta_distance_us : <span class="number">0_u32 </span>, distance : <span class="number">0.0_f32 </span>, temperature : <span class="number">0_i16 </span>, sensor_id : <span class="number">0_u8 </span>, quality : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . integration_time_us = buf . get_u32_le () ; _struct . integrated_x = buf . get_f32_le () ; _struct . integrated_y = buf . get_f32_le () ; _struct . integrated_xgyro = buf . get_f32_le () ; _struct . integrated_ygyro = buf . get_f32_le () ; _struct . integrated_zgyro = buf . get_f32_le () ; _struct . time_delta_distance_us = buf . get_u32_le () ; _struct . distance = buf . get_f32_le () ; _struct . temperature = buf . get_i16_le () ; _struct . sensor_id = buf . get_u8 () ; _struct . quality = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. integration_time_us) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_x) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_y) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_xgyro) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_ygyro) ; _tmp . put_f32_le (<span class="self">self </span>. integrated_zgyro) ; _tmp . put_u32_le (<span class="self">self </span>. time_delta_distance_us) ; _tmp . put_f32_le (<span class="self">self </span>. distance) ; _tmp . put_i16_le (<span class="self">self </span>. temperature) ; _tmp . put_u8 (<span class="self">self </span>. sensor_id) ; _tmp . put_u8 (<span class="self">self </span>. quality) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HIL_OPTICAL_FLOW_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RPM_DATA { <span class="kw">pub </span>rpm1 : f32 , <span class="kw">pub </span>rpm2 : f32 , } <span class="kw">impl </span>RPM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">8usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ rpm1 : <span class="number">0.0_f32 </span>, rpm2 : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . rpm1 = buf . get_f32_le () ; _struct . rpm2 = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. rpm1) ; _tmp . put_f32_le (<span class="self">self </span>. rpm2) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RPM_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OSD_PARAM_CONFIG_REPLY_DATA { <span class="kw">pub </span>request_id : u32 , <span class="kw">pub </span>result : OsdParamConfigError , } <span class="kw">impl </span>OSD_PARAM_CONFIG_REPLY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">5usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ request_id : <span class="number">0_u32 </span>, result : OsdParamConfigError :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . request_id = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . result = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;OsdParamConfigError&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. request_id) ; _tmp . put_u8 (<span class="self">self </span>. result <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OSD_PARAM_CONFIG_REPLY_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PROTOCOL_VERSION_DATA { <span class="kw">pub </span>version : u16 , <span class="kw">pub </span>min_version : u16 , <span class="kw">pub </span>max_version : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>spec_version_hash : [u8 ; <span class="number">8</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>library_version_hash : [u8 ; <span class="number">8</span>] , } <span class="kw">impl </span>PROTOCOL_VERSION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">22usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ version : <span class="number">0_u16 </span>, min_version : <span class="number">0_u16 </span>, max_version : <span class="number">0_u16 </span>, spec_version_hash : [<span class="number">0_u8 </span>; <span class="number">8usize</span>] , library_version_hash : [<span class="number">0_u8 </span>; <span class="number">8usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . version = buf . get_u16_le () ; _struct . min_version = buf . get_u16_le () ; _struct . max_version = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . spec_version_hash { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . library_version_hash { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. version) ; _tmp . put_u16_le (<span class="self">self </span>. min_version) ; _tmp . put_u16_le (<span class="self">self </span>. max_version) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. spec_version_hash { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. library_version_hash { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PROTOCOL_VERSION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ATTITUDE_TARGET_DATA { <span class="kw">pub </span>time_boot_ms : u32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>body_roll_rate : f32 , <span class="kw">pub </span>body_pitch_rate : f32 , <span class="kw">pub </span>body_yaw_rate : f32 , <span class="kw">pub </span>thrust : f32 , <span class="kw">pub </span>type_mask : AttitudeTargetTypemask , } <span class="kw">impl </span>ATTITUDE_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , body_roll_rate : <span class="number">0.0_f32 </span>, body_pitch_rate : <span class="number">0.0_f32 </span>, body_yaw_rate : <span class="number">0.0_f32 </span>, thrust : <span class="number">0.0_f32 </span>, type_mask : AttitudeTargetTypemask :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . body_roll_rate = buf . get_f32_le () ; _struct . body_pitch_rate = buf . get_f32_le () ; _struct . body_yaw_rate = buf . get_f32_le () ; _struct . thrust = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . type_mask = AttitudeTargetTypemask :: from_bits (tmp &amp; AttitudeTargetTypemask :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;AttitudeTargetTypemask&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_f32_le (<span class="self">self </span>. body_roll_rate) ; _tmp . put_f32_le (<span class="self">self </span>. body_pitch_rate) ; _tmp . put_f32_le (<span class="self">self </span>. body_yaw_rate) ; _tmp . put_f32_le (<span class="self">self </span>. thrust) ; _tmp . put_u8 (<span class="self">self </span>. type_mask . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ATTITUDE_TARGET_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_SET_DATA { <span class="kw">pub </span>param_value : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>param_type : MavParamType , } <span class="kw">impl </span>PARAM_SET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">23usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ param_value : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, param_id : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , param_type : MavParamType :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_value = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavParamType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param_value) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. param_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PARAM_SET_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AHRS2_DATA { <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>altitude : f32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lng : i32 , } <span class="kw">impl </span>AHRS2_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">24usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, altitude : <span class="number">0.0_f32 </span>, lat : <span class="number">0_i32 </span>, lng : <span class="number">0_i32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . altitude = buf . get_f32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lng = buf . get_i32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. altitude) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lng) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>AHRS2_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>WIND_DATA { <span class="kw">pub </span>direction : f32 , <span class="kw">pub </span>speed : f32 , <span class="kw">pub </span>speed_z : f32 , } <span class="kw">impl </span>WIND_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">12usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ direction : <span class="number">0.0_f32 </span>, speed : <span class="number">0.0_f32 </span>, speed_z : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . direction = buf . get_f32_le () ; _struct . speed = buf . get_f32_le () ; _struct . speed_z = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. direction) ; _tmp . put_f32_le (<span class="self">self </span>. speed) ; _tmp . put_f32_le (<span class="self">self </span>. speed_z) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>WIND_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VICON_POSITION_ESTIMATE_DATA { <span class="kw">pub </span>usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , } <span class="kw">impl </span>VICON_POSITION_ESTIMATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ usec : <span class="number">0_u64 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>VICON_POSITION_ESTIMATE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_COUNT_DATA { <span class="kw">pub </span>count : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>MISSION_COUNT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ count : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . count = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. count) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_COUNT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , } <span class="kw">impl </span>LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>NAMED_VALUE_FLOAT_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>value : f32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>name : [u8 ; <span class="number">10</span>] , } <span class="kw">impl </span>NAMED_VALUE_FLOAT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">18usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, value : <span class="number">0.0_f32 </span>, name : [<span class="number">0_u8 </span>; <span class="number">10usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . value = buf . get_f32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. value) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>NAMED_VALUE_FLOAT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PLAY_TUNE_V2_DATA { <span class="kw">pub </span>format : TuneFormat , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>tune : [u8 ; <span class="number">248</span>] , } <span class="kw">impl </span>PLAY_TUNE_V2_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">254usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ format : TuneFormat :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, tune : [<span class="number">0_u8 </span>; <span class="number">248usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . format = TuneFormat :: from_bits (tmp &amp; TuneFormat :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;TuneFormat&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . tune { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. format . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. tune { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PLAY_TUNE_V2_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MEMINFO_DATA { <span class="kw">pub </span>brkval : u16 , <span class="kw">pub </span>freemem : u16 , } <span class="kw">impl </span>MEMINFO_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">4usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ brkval : <span class="number">0_u16 </span>, freemem : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . brkval = buf . get_u16_le () ; _struct . freemem = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. brkval) ; _tmp . put_u16_le (<span class="self">self </span>. freemem) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MEMINFO_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DATA96_DATA { <span class="kw">pub </span>mavtype : u8 , <span class="kw">pub </span>len : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">96</span>] , } <span class="kw">impl </span>DATA96_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">98usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ mavtype : <span class="number">0_u8 </span>, len : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">96usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . mavtype = buf . get_u8 () ; _struct . len = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. mavtype) ; _tmp . put_u8 (<span class="self">self </span>. len) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DATA96_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_CONTROL_DATA { <span class="kw">pub </span>demanded_rate_x : f32 , <span class="kw">pub </span>demanded_rate_y : f32 , <span class="kw">pub </span>demanded_rate_z : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>GIMBAL_CONTROL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ demanded_rate_x : <span class="number">0.0_f32 </span>, demanded_rate_y : <span class="number">0.0_f32 </span>, demanded_rate_z : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . demanded_rate_x = buf . get_f32_le () ; _struct . demanded_rate_y = buf . get_f32_le () ; _struct . demanded_rate_z = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. demanded_rate_x) ; _tmp . put_f32_le (<span class="self">self </span>. demanded_rate_y) ; _tmp . put_f32_le (<span class="self">self </span>. demanded_rate_z) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GIMBAL_CONTROL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_DATA_DATA { <span class="kw">pub </span>ofs : u32 , <span class="kw">pub </span>id : u16 , <span class="kw">pub </span>count : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>data : [u8 ; <span class="number">90</span>] , } <span class="kw">impl </span>LOG_DATA_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">97usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ ofs : <span class="number">0_u32 </span>, id : <span class="number">0_u16 </span>, count : <span class="number">0_u8 </span>, data : [<span class="number">0_u8 </span>; <span class="number">90usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . ofs = buf . get_u32_le () ; _struct . id = buf . get_u16_le () ; _struct . count = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . data { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. ofs) ; _tmp . put_u16_le (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. count) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. data { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOG_DATA_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_GPS_GLOBAL_ORIGIN_DATA { <span class="kw">pub </span>latitude : i32 , <span class="kw">pub </span>longitude : i32 , <span class="kw">pub </span>altitude : i32 , <span class="kw">pub </span>target_system : u8 , } <span class="kw">impl </span>SET_GPS_GLOBAL_ORIGIN_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">13usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ latitude : <span class="number">0_i32 </span>, longitude : <span class="number">0_i32 </span>, altitude : <span class="number">0_i32 </span>, target_system : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . latitude = buf . get_i32_le () ; _struct . longitude = buf . get_i32_le () ; _struct . altitude = buf . get_i32_le () ; _struct . target_system = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. latitude) ; _tmp . put_i32_le (<span class="self">self </span>. longitude) ; _tmp . put_i32_le (<span class="self">self </span>. altitude) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SET_GPS_GLOBAL_ORIGIN_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MOUNT_ORIENTATION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , } <span class="kw">impl </span>MOUNT_ORIENTATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">16usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MOUNT_ORIENTATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS2_RAW_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>dgps_age : u32 , <span class="kw">pub </span>eph : u16 , <span class="kw">pub </span>epv : u16 , <span class="kw">pub </span>vel : u16 , <span class="kw">pub </span>cog : u16 , <span class="kw">pub </span>fix_type : GpsFixType , <span class="kw">pub </span>satellites_visible : u8 , <span class="kw">pub </span>dgps_numch : u8 , } <span class="kw">impl </span>GPS2_RAW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">35usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0_i32 </span>, dgps_age : <span class="number">0_u32 </span>, eph : <span class="number">0_u16 </span>, epv : <span class="number">0_u16 </span>, vel : <span class="number">0_u16 </span>, cog : <span class="number">0_u16 </span>, fix_type : GpsFixType :: DEFAULT , satellites_visible : <span class="number">0_u8 </span>, dgps_numch : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . dgps_age = buf . get_u32_le () ; _struct . eph = buf . get_u16_le () ; _struct . epv = buf . get_u16_le () ; _struct . vel = buf . get_u16_le () ; _struct . cog = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . fix_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GpsFixType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . satellites_visible = buf . get_u8 () ; _struct . dgps_numch = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_u32_le (<span class="self">self </span>. dgps_age) ; _tmp . put_u16_le (<span class="self">self </span>. eph) ; _tmp . put_u16_le (<span class="self">self </span>. epv) ; _tmp . put_u16_le (<span class="self">self </span>. vel) ; _tmp . put_u16_le (<span class="self">self </span>. cog) ; _tmp . put_u8 (<span class="self">self </span>. fix_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. satellites_visible) ; _tmp . put_u8 (<span class="self">self </span>. dgps_numch) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GPS2_RAW_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GLOBAL_VISION_POSITION_ESTIMATE_DATA { <span class="kw">pub </span>usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , } <span class="kw">impl </span>GLOBAL_VISION_POSITION_ESTIMATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">32usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ usec : <span class="number">0_u64 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GLOBAL_VISION_POSITION_ESTIMATE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HERELINK_TELEM_DATA { } <span class="kw">impl </span>HERELINK_TELEM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">0usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: default ()) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HERELINK_TELEM_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CAMERA_TRACKING_GEO_STATUS_DATA { <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>h_acc : f32 , <span class="kw">pub </span>v_acc : f32 , <span class="kw">pub </span>vel_n : f32 , <span class="kw">pub </span>vel_e : f32 , <span class="kw">pub </span>vel_d : f32 , <span class="kw">pub </span>vel_acc : f32 , <span class="kw">pub </span>dist : f32 , <span class="kw">pub </span>hdg : f32 , <span class="kw">pub </span>hdg_acc : f32 , <span class="kw">pub </span>tracking_status : CameraTrackingStatusFlags , } <span class="kw">impl </span>CAMERA_TRACKING_GEO_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">49usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0.0_f32 </span>, h_acc : <span class="number">0.0_f32 </span>, v_acc : <span class="number">0.0_f32 </span>, vel_n : <span class="number">0.0_f32 </span>, vel_e : <span class="number">0.0_f32 </span>, vel_d : <span class="number">0.0_f32 </span>, vel_acc : <span class="number">0.0_f32 </span>, dist : <span class="number">0.0_f32 </span>, hdg : <span class="number">0.0_f32 </span>, hdg_acc : <span class="number">0.0_f32 </span>, tracking_status : CameraTrackingStatusFlags :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_f32_le () ; _struct . h_acc = buf . get_f32_le () ; _struct . v_acc = buf . get_f32_le () ; _struct . vel_n = buf . get_f32_le () ; _struct . vel_e = buf . get_f32_le () ; _struct . vel_d = buf . get_f32_le () ; _struct . vel_acc = buf . get_f32_le () ; _struct . dist = buf . get_f32_le () ; _struct . hdg = buf . get_f32_le () ; _struct . hdg_acc = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . tracking_status = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CameraTrackingStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. h_acc) ; _tmp . put_f32_le (<span class="self">self </span>. v_acc) ; _tmp . put_f32_le (<span class="self">self </span>. vel_n) ; _tmp . put_f32_le (<span class="self">self </span>. vel_e) ; _tmp . put_f32_le (<span class="self">self </span>. vel_d) ; _tmp . put_f32_le (<span class="self">self </span>. vel_acc) ; _tmp . put_f32_le (<span class="self">self </span>. dist) ; _tmp . put_f32_le (<span class="self">self </span>. hdg) ; _tmp . put_f32_le (<span class="self">self </span>. hdg_acc) ; _tmp . put_u8 (<span class="self">self </span>. tracking_status <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CAMERA_TRACKING_GEO_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CURRENT_EVENT_SEQUENCE_DATA { <span class="kw">pub </span>sequence : u16 , <span class="kw">pub </span>flags : MavEventCurrentSequenceFlags , } <span class="kw">impl </span>CURRENT_EVENT_SEQUENCE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ sequence : <span class="number">0_u16 </span>, flags : MavEventCurrentSequenceFlags :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . sequence = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . flags = MavEventCurrentSequenceFlags :: from_bits (tmp &amp; MavEventCurrentSequenceFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavEventCurrentSequenceFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. sequence) ; _tmp . put_u8 (<span class="self">self </span>. flags . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CURRENT_EVENT_SEQUENCE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MESSAGE_INTERVAL_DATA { <span class="kw">pub </span>interval_us : i32 , <span class="kw">pub </span>message_id : u16 , } <span class="kw">impl </span>MESSAGE_INTERVAL_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">6usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ interval_us : <span class="number">0_i32 </span>, message_id : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . interval_us = buf . get_i32_le () ; _struct . message_id = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. interval_us) ; _tmp . put_u16_le (<span class="self">self </span>. message_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MESSAGE_INTERVAL_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_ITEM_DATA { <span class="kw">pub </span>param1 : f32 , <span class="kw">pub </span>param2 : f32 , <span class="kw">pub </span>param3 : f32 , <span class="kw">pub </span>param4 : f32 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , <span class="kw">pub </span>seq : u16 , <span class="kw">pub </span>command : MavCmd , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>frame : MavFrame , <span class="kw">pub </span>current : u8 , <span class="kw">pub </span>autocontinue : u8 , } <span class="kw">impl </span>MISSION_ITEM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">37usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ param1 : <span class="number">0.0_f32 </span>, param2 : <span class="number">0.0_f32 </span>, param3 : <span class="number">0.0_f32 </span>, param4 : <span class="number">0.0_f32 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, seq : <span class="number">0_u16 </span>, command : MavCmd :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, frame : MavFrame :: DEFAULT , current : <span class="number">0_u8 </span>, autocontinue : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param1 = buf . get_f32_le () ; _struct . param2 = buf . get_f32_le () ; _struct . param3 = buf . get_f32_le () ; _struct . param4 = buf . get_f32_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; _struct . seq = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . command = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavCmd&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . frame = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavFrame&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . current = buf . get_u8 () ; _struct . autocontinue = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. param1) ; _tmp . put_f32_le (<span class="self">self </span>. param2) ; _tmp . put_f32_le (<span class="self">self </span>. param3) ; _tmp . put_f32_le (<span class="self">self </span>. param4) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; _tmp . put_u16_le (<span class="self">self </span>. command <span class="kw">as </span>u16) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. frame <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. current) ; _tmp . put_u8 (<span class="self">self </span>. autocontinue) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_ITEM_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>RADIO_STATUS_DATA { <span class="kw">pub </span>rxerrors : u16 , <span class="kw">pub </span>fixed : u16 , <span class="kw">pub </span>rssi : u8 , <span class="kw">pub </span>remrssi : u8 , <span class="kw">pub </span>txbuf : u8 , <span class="kw">pub </span>noise : u8 , <span class="kw">pub </span>remnoise : u8 , } <span class="kw">impl </span>RADIO_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">9usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ rxerrors : <span class="number">0_u16 </span>, fixed : <span class="number">0_u16 </span>, rssi : <span class="number">0_u8 </span>, remrssi : <span class="number">0_u8 </span>, txbuf : <span class="number">0_u8 </span>, noise : <span class="number">0_u8 </span>, remnoise : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . rxerrors = buf . get_u16_le () ; _struct . fixed = buf . get_u16_le () ; _struct . rssi = buf . get_u8 () ; _struct . remrssi = buf . get_u8 () ; _struct . txbuf = buf . get_u8 () ; _struct . noise = buf . get_u8 () ; _struct . remnoise = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. rxerrors) ; _tmp . put_u16_le (<span class="self">self </span>. fixed) ; _tmp . put_u8 (<span class="self">self </span>. rssi) ; _tmp . put_u8 (<span class="self">self </span>. remrssi) ; _tmp . put_u8 (<span class="self">self </span>. txbuf) ; _tmp . put_u8 (<span class="self">self </span>. noise) ; _tmp . put_u8 (<span class="self">self </span>. remnoise) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>RADIO_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>FENCE_STATUS_DATA { <span class="kw">pub </span>breach_time : u32 , <span class="kw">pub </span>breach_count : u16 , <span class="kw">pub </span>breach_status : u8 , <span class="kw">pub </span>breach_type : FenceBreach , } <span class="kw">impl </span>FENCE_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">8usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ breach_time : <span class="number">0_u32 </span>, breach_count : <span class="number">0_u16 </span>, breach_status : <span class="number">0_u8 </span>, breach_type : FenceBreach :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . breach_time = buf . get_u32_le () ; _struct . breach_count = buf . get_u16_le () ; _struct . breach_status = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . breach_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;FenceBreach&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. breach_time) ; _tmp . put_u16_le (<span class="self">self </span>. breach_count) ; _tmp . put_u8 (<span class="self">self </span>. breach_status) ; _tmp . put_u8 (<span class="self">self </span>. breach_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>FENCE_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>HIL_SENSOR_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>xacc : f32 , <span class="kw">pub </span>yacc : f32 , <span class="kw">pub </span>zacc : f32 , <span class="kw">pub </span>xgyro : f32 , <span class="kw">pub </span>ygyro : f32 , <span class="kw">pub </span>zgyro : f32 , <span class="kw">pub </span>xmag : f32 , <span class="kw">pub </span>ymag : f32 , <span class="kw">pub </span>zmag : f32 , <span class="kw">pub </span>abs_pressure : f32 , <span class="kw">pub </span>diff_pressure : f32 , <span class="kw">pub </span>pressure_alt : f32 , <span class="kw">pub </span>temperature : f32 , <span class="kw">pub </span>fields_updated : HilSensorUpdatedFlags , } <span class="kw">impl </span>HIL_SENSOR_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">64usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, xacc : <span class="number">0.0_f32 </span>, yacc : <span class="number">0.0_f32 </span>, zacc : <span class="number">0.0_f32 </span>, xgyro : <span class="number">0.0_f32 </span>, ygyro : <span class="number">0.0_f32 </span>, zgyro : <span class="number">0.0_f32 </span>, xmag : <span class="number">0.0_f32 </span>, ymag : <span class="number">0.0_f32 </span>, zmag : <span class="number">0.0_f32 </span>, abs_pressure : <span class="number">0.0_f32 </span>, diff_pressure : <span class="number">0.0_f32 </span>, pressure_alt : <span class="number">0.0_f32 </span>, temperature : <span class="number">0.0_f32 </span>, fields_updated : HilSensorUpdatedFlags :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . xacc = buf . get_f32_le () ; _struct . yacc = buf . get_f32_le () ; _struct . zacc = buf . get_f32_le () ; _struct . xgyro = buf . get_f32_le () ; _struct . ygyro = buf . get_f32_le () ; _struct . zgyro = buf . get_f32_le () ; _struct . xmag = buf . get_f32_le () ; _struct . ymag = buf . get_f32_le () ; _struct . zmag = buf . get_f32_le () ; _struct . abs_pressure = buf . get_f32_le () ; _struct . diff_pressure = buf . get_f32_le () ; _struct . pressure_alt = buf . get_f32_le () ; _struct . temperature = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . fields_updated = HilSensorUpdatedFlags :: from_bits (tmp &amp; HilSensorUpdatedFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;HilSensorUpdatedFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. xacc) ; _tmp . put_f32_le (<span class="self">self </span>. yacc) ; _tmp . put_f32_le (<span class="self">self </span>. zacc) ; _tmp . put_f32_le (<span class="self">self </span>. xgyro) ; _tmp . put_f32_le (<span class="self">self </span>. ygyro) ; _tmp . put_f32_le (<span class="self">self </span>. zgyro) ; _tmp . put_f32_le (<span class="self">self </span>. xmag) ; _tmp . put_f32_le (<span class="self">self </span>. ymag) ; _tmp . put_f32_le (<span class="self">self </span>. zmag) ; _tmp . put_f32_le (<span class="self">self </span>. abs_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. diff_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. pressure_alt) ; _tmp . put_f32_le (<span class="self">self </span>. temperature) ; _tmp . put_u32_le (<span class="self">self </span>. fields_updated . bits ()) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>HIL_SENSOR_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_ACK_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>mavtype : MavMissionResult , } <span class="kw">impl </span>MISSION_ACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, mavtype : MavMissionResult :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavMissionResult&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_ACK_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GLOBAL_POSITION_INT_COV_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : i32 , <span class="kw">pub </span>relative_alt : i32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>covariance : [f32 ; <span class="number">36</span>] , <span class="kw">pub </span>estimator_type : MavEstimatorType , } <span class="kw">impl </span>GLOBAL_POSITION_INT_COV_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">181usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0_i32 </span>, relative_alt : <span class="number">0_i32 </span>, vx : <span class="number">0.0_f32 </span>, vy : <span class="number">0.0_f32 </span>, vz : <span class="number">0.0_f32 </span>, covariance : [<span class="number">0.0_f32 </span>; <span class="number">36usize</span>] , estimator_type : MavEstimatorType :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_i32_le () ; _struct . relative_alt = buf . get_i32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . covariance { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . estimator_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavEstimatorType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. alt) ; _tmp . put_i32_le (<span class="self">self </span>. relative_alt) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. covariance { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. estimator_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GLOBAL_POSITION_INT_COV_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CELLULAR_CONFIG_DATA { <span class="kw">pub </span>enable_lte : u8 , <span class="kw">pub </span>enable_pin : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>pin : [u8 ; <span class="number">16</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>new_pin : [u8 ; <span class="number">16</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>apn : [u8 ; <span class="number">32</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>puk : [u8 ; <span class="number">16</span>] , <span class="kw">pub </span>roaming : u8 , <span class="kw">pub </span>response : CellularConfigResponse , } <span class="kw">impl </span>CELLULAR_CONFIG_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">84usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ enable_lte : <span class="number">0_u8 </span>, enable_pin : <span class="number">0_u8 </span>, pin : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , new_pin : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , apn : [<span class="number">0_u8 </span>; <span class="number">32usize</span>] , puk : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , roaming : <span class="number">0_u8 </span>, response : CellularConfigResponse :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . enable_lte = buf . get_u8 () ; _struct . enable_pin = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . pin { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . new_pin { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . apn { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . puk { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } _struct . roaming = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . response = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;CellularConfigResponse&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. enable_lte) ; _tmp . put_u8 (<span class="self">self </span>. enable_pin) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. pin { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. new_pin { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. apn { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. puk { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. roaming) ; _tmp . put_u8 (<span class="self">self </span>. response <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CELLULAR_CONFIG_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>VIDEO_STREAM_INFORMATION_DATA { <span class="kw">pub </span>framerate : f32 , <span class="kw">pub </span>bitrate : u32 , <span class="kw">pub </span>flags : VideoStreamStatusFlags , <span class="kw">pub </span>resolution_h : u16 , <span class="kw">pub </span>resolution_v : u16 , <span class="kw">pub </span>rotation : u16 , <span class="kw">pub </span>hfov : u16 , <span class="kw">pub </span>stream_id : u8 , <span class="kw">pub </span>count : u8 , <span class="kw">pub </span>mavtype : VideoStreamType , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>name : [u8 ; <span class="number">32</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>uri : [u8 ; <span class="number">160</span>] , } <span class="kw">impl </span>VIDEO_STREAM_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">213usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ framerate : <span class="number">0.0_f32 </span>, bitrate : <span class="number">0_u32 </span>, flags : VideoStreamStatusFlags :: DEFAULT , resolution_h : <span class="number">0_u16 </span>, resolution_v : <span class="number">0_u16 </span>, rotation : <span class="number">0_u16 </span>, hfov : <span class="number">0_u16 </span>, stream_id : <span class="number">0_u8 </span>, count : <span class="number">0_u8 </span>, mavtype : VideoStreamType :: DEFAULT , name : [<span class="number">0_u8 </span>; <span class="number">32usize</span>] , uri : [<span class="number">0_u8 </span>; <span class="number">160usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . framerate = buf . get_f32_le () ; _struct . bitrate = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = FromPrimitive :: from_u16 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;VideoStreamStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . resolution_h = buf . get_u16_le () ; _struct . resolution_v = buf . get_u16_le () ; _struct . rotation = buf . get_u16_le () ; _struct . hfov = buf . get_u16_le () ; _struct . stream_id = buf . get_u8 () ; _struct . count = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;VideoStreamType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . uri { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. framerate) ; _tmp . put_u32_le (<span class="self">self </span>. bitrate) ; _tmp . put_u16_le (<span class="self">self </span>. flags <span class="kw">as </span>u16) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_h) ; _tmp . put_u16_le (<span class="self">self </span>. resolution_v) ; _tmp . put_u16_le (<span class="self">self </span>. rotation) ; _tmp . put_u16_le (<span class="self">self </span>. hfov) ; _tmp . put_u8 (<span class="self">self </span>. stream_id) ; _tmp . put_u8 (<span class="self">self </span>. count) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. uri { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>VIDEO_STREAM_INFORMATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ADSB_VEHICLE_DATA { <span class="kw">pub </span>ICAO_address : u32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>altitude : i32 , <span class="kw">pub </span>heading : u16 , <span class="kw">pub </span>hor_velocity : u16 , <span class="kw">pub </span>ver_velocity : i16 , <span class="kw">pub </span>flags : AdsbFlags , <span class="kw">pub </span>squawk : u16 , <span class="kw">pub </span>altitude_type : AdsbAltitudeType , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>callsign : [u8 ; <span class="number">9</span>] , <span class="kw">pub </span>emitter_type : AdsbEmitterType , <span class="kw">pub </span>tslc : u8 , } <span class="kw">impl </span>ADSB_VEHICLE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">38usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ ICAO_address : <span class="number">0_u32 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, altitude : <span class="number">0_i32 </span>, heading : <span class="number">0_u16 </span>, hor_velocity : <span class="number">0_u16 </span>, ver_velocity : <span class="number">0_i16 </span>, flags : AdsbFlags :: DEFAULT , squawk : <span class="number">0_u16 </span>, altitude_type : AdsbAltitudeType :: DEFAULT , callsign : [<span class="number">0_u8 </span>; <span class="number">9usize</span>] , emitter_type : AdsbEmitterType :: DEFAULT , tslc : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . ICAO_address = buf . get_u32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . altitude = buf . get_i32_le () ; _struct . heading = buf . get_u16_le () ; _struct . hor_velocity = buf . get_u16_le () ; _struct . ver_velocity = buf . get_i16_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . flags = AdsbFlags :: from_bits (tmp &amp; AdsbFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;AdsbFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . squawk = buf . get_u16_le () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . altitude_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;AdsbAltitudeType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . callsign { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . emitter_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;AdsbEmitterType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . tslc = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. ICAO_address) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_i32_le (<span class="self">self </span>. altitude) ; _tmp . put_u16_le (<span class="self">self </span>. heading) ; _tmp . put_u16_le (<span class="self">self </span>. hor_velocity) ; _tmp . put_i16_le (<span class="self">self </span>. ver_velocity) ; _tmp . put_u16_le (<span class="self">self </span>. flags . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. squawk) ; _tmp . put_u8 (<span class="self">self </span>. altitude_type <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. callsign { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. emitter_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. tslc) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ADSB_VEHICLE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_SYSTEM_DATA { <span class="kw">pub </span>operator_latitude : i32 , <span class="kw">pub </span>operator_longitude : i32 , <span class="kw">pub </span>area_ceiling : f32 , <span class="kw">pub </span>area_floor : f32 , <span class="kw">pub </span>operator_altitude_geo : f32 , <span class="kw">pub </span>timestamp : u32 , <span class="kw">pub </span>area_count : u16 , <span class="kw">pub </span>area_radius : u16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>operator_location_type : MavOdidOperatorLocationType , <span class="kw">pub </span>classification_type : MavOdidClassificationType , <span class="kw">pub </span>category_eu : MavOdidCategoryEu , <span class="kw">pub </span>class_eu : MavOdidClassEu , } <span class="kw">impl </span>OPEN_DRONE_ID_SYSTEM_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">54usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ operator_latitude : <span class="number">0_i32 </span>, operator_longitude : <span class="number">0_i32 </span>, area_ceiling : <span class="number">0.0_f32 </span>, area_floor : <span class="number">0.0_f32 </span>, operator_altitude_geo : <span class="number">0.0_f32 </span>, timestamp : <span class="number">0_u32 </span>, area_count : <span class="number">0_u16 </span>, area_radius : <span class="number">0_u16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, id_or_mac : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , operator_location_type : MavOdidOperatorLocationType :: DEFAULT , classification_type : MavOdidClassificationType :: DEFAULT , category_eu : MavOdidCategoryEu :: DEFAULT , class_eu : MavOdidClassEu :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . operator_latitude = buf . get_i32_le () ; _struct . operator_longitude = buf . get_i32_le () ; _struct . area_ceiling = buf . get_f32_le () ; _struct . area_floor = buf . get_f32_le () ; _struct . operator_altitude_geo = buf . get_f32_le () ; _struct . timestamp = buf . get_u32_le () ; _struct . area_count = buf . get_u16_le () ; _struct . area_radius = buf . get_u16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . id_or_mac { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . operator_location_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidOperatorLocationType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . classification_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidClassificationType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . category_eu = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidCategoryEu&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . class_eu = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidClassEu&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. operator_latitude) ; _tmp . put_i32_le (<span class="self">self </span>. operator_longitude) ; _tmp . put_f32_le (<span class="self">self </span>. area_ceiling) ; _tmp . put_f32_le (<span class="self">self </span>. area_floor) ; _tmp . put_f32_le (<span class="self">self </span>. operator_altitude_geo) ; _tmp . put_u32_le (<span class="self">self </span>. timestamp) ; _tmp . put_u16_le (<span class="self">self </span>. area_count) ; _tmp . put_u16_le (<span class="self">self </span>. area_radius) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. operator_location_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. classification_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. category_eu <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. class_eu <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OPEN_DRONE_ID_SYSTEM_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GPS_INPUT_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>time_week_ms : u32 , <span class="kw">pub </span>lat : i32 , <span class="kw">pub </span>lon : i32 , <span class="kw">pub </span>alt : f32 , <span class="kw">pub </span>hdop : f32 , <span class="kw">pub </span>vdop : f32 , <span class="kw">pub </span>vn : f32 , <span class="kw">pub </span>ve : f32 , <span class="kw">pub </span>vd : f32 , <span class="kw">pub </span>speed_accuracy : f32 , <span class="kw">pub </span>horiz_accuracy : f32 , <span class="kw">pub </span>vert_accuracy : f32 , <span class="kw">pub </span>ignore_flags : GpsInputIgnoreFlags , <span class="kw">pub </span>time_week : u16 , <span class="kw">pub </span>gps_id : u8 , <span class="kw">pub </span>fix_type : u8 , <span class="kw">pub </span>satellites_visible : u8 , } <span class="kw">impl </span>GPS_INPUT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">63usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, time_week_ms : <span class="number">0_u32 </span>, lat : <span class="number">0_i32 </span>, lon : <span class="number">0_i32 </span>, alt : <span class="number">0.0_f32 </span>, hdop : <span class="number">0.0_f32 </span>, vdop : <span class="number">0.0_f32 </span>, vn : <span class="number">0.0_f32 </span>, ve : <span class="number">0.0_f32 </span>, vd : <span class="number">0.0_f32 </span>, speed_accuracy : <span class="number">0.0_f32 </span>, horiz_accuracy : <span class="number">0.0_f32 </span>, vert_accuracy : <span class="number">0.0_f32 </span>, ignore_flags : GpsInputIgnoreFlags :: DEFAULT , time_week : <span class="number">0_u16 </span>, gps_id : <span class="number">0_u8 </span>, fix_type : <span class="number">0_u8 </span>, satellites_visible : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . time_week_ms = buf . get_u32_le () ; _struct . lat = buf . get_i32_le () ; _struct . lon = buf . get_i32_le () ; _struct . alt = buf . get_f32_le () ; _struct . hdop = buf . get_f32_le () ; _struct . vdop = buf . get_f32_le () ; _struct . vn = buf . get_f32_le () ; _struct . ve = buf . get_f32_le () ; _struct . vd = buf . get_f32_le () ; _struct . speed_accuracy = buf . get_f32_le () ; _struct . horiz_accuracy = buf . get_f32_le () ; _struct . vert_accuracy = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . ignore_flags = GpsInputIgnoreFlags :: from_bits (tmp &amp; GpsInputIgnoreFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;GpsInputIgnoreFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . time_week = buf . get_u16_le () ; _struct . gps_id = buf . get_u8 () ; _struct . fix_type = buf . get_u8 () ; _struct . satellites_visible = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. time_week_ms) ; _tmp . put_i32_le (<span class="self">self </span>. lat) ; _tmp . put_i32_le (<span class="self">self </span>. lon) ; _tmp . put_f32_le (<span class="self">self </span>. alt) ; _tmp . put_f32_le (<span class="self">self </span>. hdop) ; _tmp . put_f32_le (<span class="self">self </span>. vdop) ; _tmp . put_f32_le (<span class="self">self </span>. vn) ; _tmp . put_f32_le (<span class="self">self </span>. ve) ; _tmp . put_f32_le (<span class="self">self </span>. vd) ; _tmp . put_f32_le (<span class="self">self </span>. speed_accuracy) ; _tmp . put_f32_le (<span class="self">self </span>. horiz_accuracy) ; _tmp . put_f32_le (<span class="self">self </span>. vert_accuracy) ; _tmp . put_u16_le (<span class="self">self </span>. ignore_flags . bits ()) ; _tmp . put_u16_le (<span class="self">self </span>. time_week) ; _tmp . put_u8 (<span class="self">self </span>. gps_id) ; _tmp . put_u8 (<span class="self">self </span>. fix_type) ; _tmp . put_u8 (<span class="self">self </span>. satellites_visible) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GPS_INPUT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_MANAGER_STATUS_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>flags : GimbalManagerFlags , <span class="kw">pub </span>gimbal_device_id : u8 , <span class="kw">pub </span>primary_control_sysid : u8 , <span class="kw">pub </span>primary_control_compid : u8 , <span class="kw">pub </span>secondary_control_sysid : u8 , <span class="kw">pub </span>secondary_control_compid : u8 , } <span class="kw">impl </span>GIMBAL_MANAGER_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">13usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, flags : GimbalManagerFlags :: DEFAULT , gimbal_device_id : <span class="number">0_u8 </span>, primary_control_sysid : <span class="number">0_u8 </span>, primary_control_compid : <span class="number">0_u8 </span>, secondary_control_sysid : <span class="number">0_u8 </span>, secondary_control_compid : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . flags = FromPrimitive :: from_u32 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GimbalManagerFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . gimbal_device_id = buf . get_u8 () ; _struct . primary_control_sysid = buf . get_u8 () ; _struct . primary_control_compid = buf . get_u8 () ; _struct . secondary_control_sysid = buf . get_u8 () ; _struct . secondary_control_compid = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. flags <span class="kw">as </span>u32) ; _tmp . put_u8 (<span class="self">self </span>. gimbal_device_id) ; _tmp . put_u8 (<span class="self">self </span>. primary_control_sysid) ; _tmp . put_u8 (<span class="self">self </span>. primary_control_compid) ; _tmp . put_u8 (<span class="self">self </span>. secondary_control_sysid) ; _tmp . put_u8 (<span class="self">self </span>. secondary_control_compid) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GIMBAL_MANAGER_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EXTENDED_SYS_STATE_DATA { <span class="kw">pub </span>vtol_state : MavVtolState , <span class="kw">pub </span>landed_state : MavLandedState , } <span class="kw">impl </span>EXTENDED_SYS_STATE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ vtol_state : MavVtolState :: DEFAULT , landed_state : MavLandedState :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . vtol_state = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavVtolState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . landed_state = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavLandedState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. vtol_state <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. landed_state <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>EXTENDED_SYS_STATE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>OPEN_DRONE_ID_OPERATOR_ID_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>id_or_mac : [u8 ; <span class="number">20</span>] , <span class="kw">pub </span>operator_id_type : MavOdidOperatorIdType , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>operator_id : [u8 ; <span class="number">20</span>] , } <span class="kw">impl </span>OPEN_DRONE_ID_OPERATOR_ID_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">43usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, id_or_mac : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , operator_id_type : MavOdidOperatorIdType :: DEFAULT , operator_id : [<span class="number">0_u8 </span>; <span class="number">20usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . id_or_mac { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . operator_id_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavOdidOperatorIdType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . operator_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. id_or_mac { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. operator_id_type <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. operator_id { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>OPEN_DRONE_ID_OPERATOR_ID_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_ACTUATOR_CONTROL_TARGET_DATA { <span class="kw">pub </span>time_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>controls : [f32 ; <span class="number">8</span>] , <span class="kw">pub </span>group_mlx : u8 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>SET_ACTUATOR_CONTROL_TARGET_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">43usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, controls : [<span class="number">0.0_f32 </span>; <span class="number">8usize</span>] , group_mlx : <span class="number">0_u8 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . controls { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . group_mlx = buf . get_u8 () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. controls { _tmp . put_f32_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. group_mlx) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SET_ACTUATOR_CONTROL_TARGET_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DEBUG_FLOAT_ARRAY_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>array_id : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>name : [u8 ; <span class="number">10</span>] , } <span class="kw">impl </span>DEBUG_FLOAT_ARRAY_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">20usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, array_id : <span class="number">0_u16 </span>, name : [<span class="number">0_u8 </span>; <span class="number">10usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . array_id = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u16_le (<span class="self">self </span>. array_id) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DEBUG_FLOAT_ARRAY_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AP_ADC_DATA { <span class="kw">pub </span>adc1 : u16 , <span class="kw">pub </span>adc2 : u16 , <span class="kw">pub </span>adc3 : u16 , <span class="kw">pub </span>adc4 : u16 , <span class="kw">pub </span>adc5 : u16 , <span class="kw">pub </span>adc6 : u16 , } <span class="kw">impl </span>AP_ADC_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">12usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ adc1 : <span class="number">0_u16 </span>, adc2 : <span class="number">0_u16 </span>, adc3 : <span class="number">0_u16 </span>, adc4 : <span class="number">0_u16 </span>, adc5 : <span class="number">0_u16 </span>, adc6 : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . adc1 = buf . get_u16_le () ; _struct . adc2 = buf . get_u16_le () ; _struct . adc3 = buf . get_u16_le () ; _struct . adc4 = buf . get_u16_le () ; _struct . adc5 = buf . get_u16_le () ; _struct . adc6 = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. adc1) ; _tmp . put_u16_le (<span class="self">self </span>. adc2) ; _tmp . put_u16_le (<span class="self">self </span>. adc3) ; _tmp . put_u16_le (<span class="self">self </span>. adc4) ; _tmp . put_u16_le (<span class="self">self </span>. adc5) ; _tmp . put_u16_le (<span class="self">self </span>. adc6) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>AP_ADC_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SMART_BATTERY_INFO_DATA { <span class="kw">pub </span>capacity_full_specification : i32 , <span class="kw">pub </span>capacity_full : i32 , <span class="kw">pub </span>cycle_count : u16 , <span class="kw">pub </span>weight : u16 , <span class="kw">pub </span>discharge_minimum_voltage : u16 , <span class="kw">pub </span>charging_minimum_voltage : u16 , <span class="kw">pub </span>resting_minimum_voltage : u16 , <span class="kw">pub </span>id : u8 , <span class="kw">pub </span>battery_function : MavBatteryFunction , <span class="kw">pub </span>mavtype : MavBatteryType , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>serial_number : [u8 ; <span class="number">16</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>device_name : [u8 ; <span class="number">50</span>] , } <span class="kw">impl </span>SMART_BATTERY_INFO_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">87usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ capacity_full_specification : <span class="number">0_i32 </span>, capacity_full : <span class="number">0_i32 </span>, cycle_count : <span class="number">0_u16 </span>, weight : <span class="number">0_u16 </span>, discharge_minimum_voltage : <span class="number">0_u16 </span>, charging_minimum_voltage : <span class="number">0_u16 </span>, resting_minimum_voltage : <span class="number">0_u16 </span>, id : <span class="number">0_u8 </span>, battery_function : MavBatteryFunction :: DEFAULT , mavtype : MavBatteryType :: DEFAULT , serial_number : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , device_name : [<span class="number">0_u8 </span>; <span class="number">50usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . capacity_full_specification = buf . get_i32_le () ; _struct . capacity_full = buf . get_i32_le () ; _struct . cycle_count = buf . get_u16_le () ; _struct . weight = buf . get_u16_le () ; _struct . discharge_minimum_voltage = buf . get_u16_le () ; _struct . charging_minimum_voltage = buf . get_u16_le () ; _struct . resting_minimum_voltage = buf . get_u16_le () ; _struct . id = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . battery_function = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavBatteryFunction&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . mavtype = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavBatteryType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . serial_number { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . device_name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i32_le (<span class="self">self </span>. capacity_full_specification) ; _tmp . put_i32_le (<span class="self">self </span>. capacity_full) ; _tmp . put_u16_le (<span class="self">self </span>. cycle_count) ; _tmp . put_u16_le (<span class="self">self </span>. weight) ; _tmp . put_u16_le (<span class="self">self </span>. discharge_minimum_voltage) ; _tmp . put_u16_le (<span class="self">self </span>. charging_minimum_voltage) ; _tmp . put_u16_le (<span class="self">self </span>. resting_minimum_voltage) ; _tmp . put_u8 (<span class="self">self </span>. id) ; _tmp . put_u8 (<span class="self">self </span>. battery_function <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. mavtype <span class="kw">as </span>u8) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. serial_number { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. device_name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SMART_BATTERY_INFO_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>LOG_REQUEST_END_DATA { <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>LOG_REQUEST_END_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>LOG_REQUEST_END_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>GIMBAL_MANAGER_SET_PITCHYAW_DATA { <span class="kw">pub </span>flags : GimbalManagerFlags , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>pitch_rate : f32 , <span class="kw">pub </span>yaw_rate : f32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>gimbal_device_id : u8 , } <span class="kw">impl </span>GIMBAL_MANAGER_SET_PITCHYAW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">23usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ flags : GimbalManagerFlags :: DEFAULT , pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, pitch_rate : <span class="number">0.0_f32 </span>, yaw_rate : <span class="number">0.0_f32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, gimbal_device_id : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u32_le () ; _struct . flags = FromPrimitive :: from_u32 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;GimbalManagerFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . pitch_rate = buf . get_f32_le () ; _struct . yaw_rate = buf . get_f32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; _struct . gimbal_device_id = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. flags <span class="kw">as </span>u32) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. pitch_rate) ; _tmp . put_f32_le (<span class="self">self </span>. yaw_rate) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. gimbal_device_id) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>GIMBAL_MANAGER_SET_PITCHYAW_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>COMPONENT_INFORMATION_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>general_metadata_file_crc : u32 , <span class="kw">pub </span>peripherals_metadata_file_crc : u32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>general_metadata_uri : [u8 ; <span class="number">100</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>peripherals_metadata_uri : [u8 ; <span class="number">100</span>] , } <span class="kw">impl </span>COMPONENT_INFORMATION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">212usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, general_metadata_file_crc : <span class="number">0_u32 </span>, peripherals_metadata_file_crc : <span class="number">0_u32 </span>, general_metadata_uri : [<span class="number">0_u8 </span>; <span class="number">100usize</span>] , peripherals_metadata_uri : [<span class="number">0_u8 </span>; <span class="number">100usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . general_metadata_file_crc = buf . get_u32_le () ; _struct . peripherals_metadata_file_crc = buf . get_u32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . general_metadata_uri { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . peripherals_metadata_uri { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_u32_le (<span class="self">self </span>. general_metadata_file_crc) ; _tmp . put_u32_le (<span class="self">self </span>. peripherals_metadata_file_crc) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. general_metadata_uri { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. peripherals_metadata_uri { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>COMPONENT_INFORMATION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SERVO_OUTPUT_RAW_DATA { <span class="kw">pub </span>time_usec : u32 , <span class="kw">pub </span>servo1_raw : u16 , <span class="kw">pub </span>servo2_raw : u16 , <span class="kw">pub </span>servo3_raw : u16 , <span class="kw">pub </span>servo4_raw : u16 , <span class="kw">pub </span>servo5_raw : u16 , <span class="kw">pub </span>servo6_raw : u16 , <span class="kw">pub </span>servo7_raw : u16 , <span class="kw">pub </span>servo8_raw : u16 , <span class="kw">pub </span>port : u8 , } <span class="kw">impl </span>SERVO_OUTPUT_RAW_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">21usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u32 </span>, servo1_raw : <span class="number">0_u16 </span>, servo2_raw : <span class="number">0_u16 </span>, servo3_raw : <span class="number">0_u16 </span>, servo4_raw : <span class="number">0_u16 </span>, servo5_raw : <span class="number">0_u16 </span>, servo6_raw : <span class="number">0_u16 </span>, servo7_raw : <span class="number">0_u16 </span>, servo8_raw : <span class="number">0_u16 </span>, port : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u32_le () ; _struct . servo1_raw = buf . get_u16_le () ; _struct . servo2_raw = buf . get_u16_le () ; _struct . servo3_raw = buf . get_u16_le () ; _struct . servo4_raw = buf . get_u16_le () ; _struct . servo5_raw = buf . get_u16_le () ; _struct . servo6_raw = buf . get_u16_le () ; _struct . servo7_raw = buf . get_u16_le () ; _struct . servo8_raw = buf . get_u16_le () ; _struct . port = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_usec) ; _tmp . put_u16_le (<span class="self">self </span>. servo1_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo2_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo3_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo4_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo5_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo6_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo7_raw) ; _tmp . put_u16_le (<span class="self">self </span>. servo8_raw) ; _tmp . put_u8 (<span class="self">self </span>. port) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SERVO_OUTPUT_RAW_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ATTITUDE_DATA { <span class="kw">pub </span>time_boot_ms : u32 , <span class="kw">pub </span>roll : f32 , <span class="kw">pub </span>pitch : f32 , <span class="kw">pub </span>yaw : f32 , <span class="kw">pub </span>rollspeed : f32 , <span class="kw">pub </span>pitchspeed : f32 , <span class="kw">pub </span>yawspeed : f32 , } <span class="kw">impl </span>ATTITUDE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">28usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_ms : <span class="number">0_u32 </span>, roll : <span class="number">0.0_f32 </span>, pitch : <span class="number">0.0_f32 </span>, yaw : <span class="number">0.0_f32 </span>, rollspeed : <span class="number">0.0_f32 </span>, pitchspeed : <span class="number">0.0_f32 </span>, yawspeed : <span class="number">0.0_f32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_ms = buf . get_u32_le () ; _struct . roll = buf . get_f32_le () ; _struct . pitch = buf . get_f32_le () ; _struct . yaw = buf . get_f32_le () ; _struct . rollspeed = buf . get_f32_le () ; _struct . pitchspeed = buf . get_f32_le () ; _struct . yawspeed = buf . get_f32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; _tmp . put_f32_le (<span class="self">self </span>. roll) ; _tmp . put_f32_le (<span class="self">self </span>. pitch) ; _tmp . put_f32_le (<span class="self">self </span>. yaw) ; _tmp . put_f32_le (<span class="self">self </span>. rollspeed) ; _tmp . put_f32_le (<span class="self">self </span>. pitchspeed) ; _tmp . put_f32_le (<span class="self">self </span>. yawspeed) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ATTITUDE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>ESC_INFO_DATA { <span class="kw">pub </span>time_usec : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>error_count : [u32 ; <span class="number">4</span>] , <span class="kw">pub </span>counter : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>failure_flags : [u16 ; <span class="number">4</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>temperature : [i16 ; <span class="number">4</span>] , <span class="kw">pub </span>index : u8 , <span class="kw">pub </span>count : u8 , <span class="kw">pub </span>connection_type : EscConnectionType , <span class="kw">pub </span>info : u8 , } <span class="kw">impl </span>ESC_INFO_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">46usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, error_count : [<span class="number">0_u32 </span>; <span class="number">4usize</span>] , counter : <span class="number">0_u16 </span>, failure_flags : [<span class="number">0_u16 </span>; <span class="number">4usize</span>] , temperature : [<span class="number">0_i16 </span>; <span class="number">4usize</span>] , index : <span class="number">0_u8 </span>, count : <span class="number">0_u8 </span>, connection_type : EscConnectionType :: DEFAULT , info : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . error_count { <span class="kw">let </span>val = buf . get_u32_le () ; * v = val ; } _struct . counter = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . failure_flags { <span class="kw">let </span>val = buf . get_u16_le () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . temperature { <span class="kw">let </span>val = buf . get_i16_le () ; * v = val ; } _struct . index = buf . get_u8 () ; _struct . count = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . connection_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;EscConnectionType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . info = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. error_count { _tmp . put_u32_le (* val) ; } _tmp . put_u16_le (<span class="self">self </span>. counter) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. failure_flags { _tmp . put_u16_le (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. temperature { _tmp . put_i16_le (* val) ; } _tmp . put_u8 (<span class="self">self </span>. index) ; _tmp . put_u8 (<span class="self">self </span>. count) ; _tmp . put_u8 (<span class="self">self </span>. connection_type <span class="kw">as </span>u8) ; _tmp . put_u8 (<span class="self">self </span>. info) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>ESC_INFO_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PING_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>seq : u32 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>PING_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">14usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, seq : <span class="number">0_u32 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . seq = buf . get_u32_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_u32_le (<span class="self">self </span>. seq) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PING_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>PARAM_EXT_VALUE_DATA { <span class="kw">pub </span>param_count : u16 , <span class="kw">pub </span>param_index : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_id : [u8 ; <span class="number">16</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>param_value : [u8 ; <span class="number">128</span>] , <span class="kw">pub </span>param_type : MavParamExtType , } <span class="kw">impl </span>PARAM_EXT_VALUE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">149usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ param_count : <span class="number">0_u16 </span>, param_index : <span class="number">0_u16 </span>, param_id : [<span class="number">0_u8 </span>; <span class="number">16usize</span>] , param_value : [<span class="number">0_u8 </span>; <span class="number">128usize</span>] , param_type : MavParamExtType :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . param_count = buf . get_u16_le () ; _struct . param_index = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_id { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . param_value { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . param_type = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavParamExtType&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. param_count) ; _tmp . put_u16_le (<span class="self">self </span>. param_index) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_id { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. param_value { _tmp . put_u8 (* val) ; } _tmp . put_u8 (<span class="self">self </span>. param_type <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>PARAM_EXT_VALUE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AUTOPILOT_STATE_FOR_GIMBAL_DEVICE_DATA { <span class="kw">pub </span>time_boot_us : u64 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>q : [f32 ; <span class="number">4</span>] , <span class="kw">pub </span>q_estimated_delay_us : u32 , <span class="kw">pub </span>vx : f32 , <span class="kw">pub </span>vy : f32 , <span class="kw">pub </span>vz : f32 , <span class="kw">pub </span>v_estimated_delay_us : u32 , <span class="kw">pub </span>feed_forward_angular_velocity_z : f32 , <span class="kw">pub </span>estimator_status : EstimatorStatusFlags , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , <span class="kw">pub </span>landed_state : MavLandedState , } <span class="kw">impl </span>AUTOPILOT_STATE_FOR_GIMBAL_DEVICE_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">53usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_boot_us : <span class="number">0_u64 </span>, q : [<span class="number">0.0_f32 </span>; <span class="number">4usize</span>] , q_estimated_delay_us : <span class="number">0_u32 </span>, vx : <span class="number">0.0_f32 </span>, vy : <span class="number">0.0_f32 </span>, vz : <span class="number">0.0_f32 </span>, v_estimated_delay_us : <span class="number">0_u32 </span>, feed_forward_angular_velocity_z : <span class="number">0.0_f32 </span>, estimator_status : EstimatorStatusFlags :: DEFAULT , target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, landed_state : MavLandedState :: DEFAULT , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_boot_us = buf . get_u64_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . q { <span class="kw">let </span>val = buf . get_f32_le () ; * v = val ; } _struct . q_estimated_delay_us = buf . get_u32_le () ; _struct . vx = buf . get_f32_le () ; _struct . vy = buf . get_f32_le () ; _struct . vz = buf . get_f32_le () ; _struct . v_estimated_delay_us = buf . get_u32_le () ; _struct . feed_forward_angular_velocity_z = buf . get_f32_le () ; <span class="kw">let </span>tmp = buf . get_u16_le () ; _struct . estimator_status = EstimatorStatusFlags :: from_bits (tmp &amp; EstimatorStatusFlags :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;EstimatorStatusFlags&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="kw">let </span>tmp = buf . get_u8 () ; _struct . landed_state = FromPrimitive :: from_u8 (tmp) . ok_or (ParserError :: InvalidEnum { enum_type : <span class="string">&quot;MavLandedState&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_boot_us) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. q { _tmp . put_f32_le (* val) ; } _tmp . put_u32_le (<span class="self">self </span>. q_estimated_delay_us) ; _tmp . put_f32_le (<span class="self">self </span>. vx) ; _tmp . put_f32_le (<span class="self">self </span>. vy) ; _tmp . put_f32_le (<span class="self">self </span>. vz) ; _tmp . put_u32_le (<span class="self">self </span>. v_estimated_delay_us) ; _tmp . put_f32_le (<span class="self">self </span>. feed_forward_angular_velocity_z) ; _tmp . put_u16_le (<span class="self">self </span>. estimator_status . bits ()) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; _tmp . put_u8 (<span class="self">self </span>. landed_state <span class="kw">as </span>u8) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>AUTOPILOT_STATE_FOR_GIMBAL_DEVICE_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>AUTOPILOT_VERSION_DATA { <span class="kw">pub </span>capabilities : MavProtocolCapability , <span class="kw">pub </span>uid : u64 , <span class="kw">pub </span>flight_sw_version : u32 , <span class="kw">pub </span>middleware_sw_version : u32 , <span class="kw">pub </span>os_sw_version : u32 , <span class="kw">pub </span>board_version : u32 , <span class="kw">pub </span>vendor_id : u16 , <span class="kw">pub </span>product_id : u16 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>flight_custom_version : [u8 ; <span class="number">8</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>middleware_custom_version : [u8 ; <span class="number">8</span>] , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>os_custom_version : [u8 ; <span class="number">8</span>] , } <span class="kw">impl </span>AUTOPILOT_VERSION_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">60usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ capabilities : MavProtocolCapability :: DEFAULT , uid : <span class="number">0_u64 </span>, flight_sw_version : <span class="number">0_u32 </span>, middleware_sw_version : <span class="number">0_u32 </span>, os_sw_version : <span class="number">0_u32 </span>, board_version : <span class="number">0_u32 </span>, vendor_id : <span class="number">0_u16 </span>, product_id : <span class="number">0_u16 </span>, flight_custom_version : [<span class="number">0_u8 </span>; <span class="number">8usize</span>] , middleware_custom_version : [<span class="number">0_u8 </span>; <span class="number">8usize</span>] , os_custom_version : [<span class="number">0_u8 </span>; <span class="number">8usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; <span class="kw">let </span>tmp = buf . get_u64_le () ; _struct . capabilities = MavProtocolCapability :: from_bits (tmp &amp; MavProtocolCapability :: all () . bits ()) . ok_or (ParserError :: InvalidFlag { flag_type : <span class="string">&quot;MavProtocolCapability&quot; </span>, value : tmp <span class="kw">as </span>u32 }) <span class="question-mark">? </span>; _struct . uid = buf . get_u64_le () ; _struct . flight_sw_version = buf . get_u32_le () ; _struct . middleware_sw_version = buf . get_u32_le () ; _struct . os_sw_version = buf . get_u32_le () ; _struct . board_version = buf . get_u32_le () ; _struct . vendor_id = buf . get_u16_le () ; _struct . product_id = buf . get_u16_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . flight_custom_version { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . middleware_custom_version { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . os_custom_version { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. capabilities . bits ()) ; _tmp . put_u64_le (<span class="self">self </span>. uid) ; _tmp . put_u32_le (<span class="self">self </span>. flight_sw_version) ; _tmp . put_u32_le (<span class="self">self </span>. middleware_sw_version) ; _tmp . put_u32_le (<span class="self">self </span>. os_sw_version) ; _tmp . put_u32_le (<span class="self">self </span>. board_version) ; _tmp . put_u16_le (<span class="self">self </span>. vendor_id) ; _tmp . put_u16_le (<span class="self">self </span>. product_id) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. flight_custom_version { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. middleware_custom_version { _tmp . put_u8 (* val) ; } <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. os_custom_version { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>AUTOPILOT_VERSION_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>NAV_CONTROLLER_OUTPUT_DATA { <span class="kw">pub </span>nav_roll : f32 , <span class="kw">pub </span>nav_pitch : f32 , <span class="kw">pub </span>alt_error : f32 , <span class="kw">pub </span>aspd_error : f32 , <span class="kw">pub </span>xtrack_error : f32 , <span class="kw">pub </span>nav_bearing : i16 , <span class="kw">pub </span>target_bearing : i16 , <span class="kw">pub </span>wp_dist : u16 , } <span class="kw">impl </span>NAV_CONTROLLER_OUTPUT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">26usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ nav_roll : <span class="number">0.0_f32 </span>, nav_pitch : <span class="number">0.0_f32 </span>, alt_error : <span class="number">0.0_f32 </span>, aspd_error : <span class="number">0.0_f32 </span>, xtrack_error : <span class="number">0.0_f32 </span>, nav_bearing : <span class="number">0_i16 </span>, target_bearing : <span class="number">0_i16 </span>, wp_dist : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . nav_roll = buf . get_f32_le () ; _struct . nav_pitch = buf . get_f32_le () ; _struct . alt_error = buf . get_f32_le () ; _struct . aspd_error = buf . get_f32_le () ; _struct . xtrack_error = buf . get_f32_le () ; _struct . nav_bearing = buf . get_i16_le () ; _struct . target_bearing = buf . get_i16_le () ; _struct . wp_dist = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. nav_roll) ; _tmp . put_f32_le (<span class="self">self </span>. nav_pitch) ; _tmp . put_f32_le (<span class="self">self </span>. alt_error) ; _tmp . put_f32_le (<span class="self">self </span>. aspd_error) ; _tmp . put_f32_le (<span class="self">self </span>. xtrack_error) ; _tmp . put_i16_le (<span class="self">self </span>. nav_bearing) ; _tmp . put_i16_le (<span class="self">self </span>. target_bearing) ; _tmp . put_u16_le (<span class="self">self </span>. wp_dist) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>NAV_CONTROLLER_OUTPUT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>MISSION_ITEM_REACHED_DATA { <span class="kw">pub </span>seq : u16 , } <span class="kw">impl </span>MISSION_ITEM_REACHED_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">2usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ seq : <span class="number">0_u16 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . seq = buf . get_u16_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u16_le (<span class="self">self </span>. seq) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>MISSION_ITEM_REACHED_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>EFI_STATUS_DATA { <span class="kw">pub </span>ecu_index : f32 , <span class="kw">pub </span>rpm : f32 , <span class="kw">pub </span>fuel_consumed : f32 , <span class="kw">pub </span>fuel_flow : f32 , <span class="kw">pub </span>engine_load : f32 , <span class="kw">pub </span>throttle_position : f32 , <span class="kw">pub </span>spark_dwell_time : f32 , <span class="kw">pub </span>barometric_pressure : f32 , <span class="kw">pub </span>intake_manifold_pressure : f32 , <span class="kw">pub </span>intake_manifold_temperature : f32 , <span class="kw">pub </span>cylinder_head_temperature : f32 , <span class="kw">pub </span>ignition_timing : f32 , <span class="kw">pub </span>injection_time : f32 , <span class="kw">pub </span>exhaust_gas_temperature : f32 , <span class="kw">pub </span>throttle_out : f32 , <span class="kw">pub </span>pt_compensation : f32 , <span class="kw">pub </span>health : u8 , } <span class="kw">impl </span>EFI_STATUS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">65usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ ecu_index : <span class="number">0.0_f32 </span>, rpm : <span class="number">0.0_f32 </span>, fuel_consumed : <span class="number">0.0_f32 </span>, fuel_flow : <span class="number">0.0_f32 </span>, engine_load : <span class="number">0.0_f32 </span>, throttle_position : <span class="number">0.0_f32 </span>, spark_dwell_time : <span class="number">0.0_f32 </span>, barometric_pressure : <span class="number">0.0_f32 </span>, intake_manifold_pressure : <span class="number">0.0_f32 </span>, intake_manifold_temperature : <span class="number">0.0_f32 </span>, cylinder_head_temperature : <span class="number">0.0_f32 </span>, ignition_timing : <span class="number">0.0_f32 </span>, injection_time : <span class="number">0.0_f32 </span>, exhaust_gas_temperature : <span class="number">0.0_f32 </span>, throttle_out : <span class="number">0.0_f32 </span>, pt_compensation : <span class="number">0.0_f32 </span>, health : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . ecu_index = buf . get_f32_le () ; _struct . rpm = buf . get_f32_le () ; _struct . fuel_consumed = buf . get_f32_le () ; _struct . fuel_flow = buf . get_f32_le () ; _struct . engine_load = buf . get_f32_le () ; _struct . throttle_position = buf . get_f32_le () ; _struct . spark_dwell_time = buf . get_f32_le () ; _struct . barometric_pressure = buf . get_f32_le () ; _struct . intake_manifold_pressure = buf . get_f32_le () ; _struct . intake_manifold_temperature = buf . get_f32_le () ; _struct . cylinder_head_temperature = buf . get_f32_le () ; _struct . ignition_timing = buf . get_f32_le () ; _struct . injection_time = buf . get_f32_le () ; _struct . exhaust_gas_temperature = buf . get_f32_le () ; _struct . throttle_out = buf . get_f32_le () ; _struct . pt_compensation = buf . get_f32_le () ; _struct . health = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_f32_le (<span class="self">self </span>. ecu_index) ; _tmp . put_f32_le (<span class="self">self </span>. rpm) ; _tmp . put_f32_le (<span class="self">self </span>. fuel_consumed) ; _tmp . put_f32_le (<span class="self">self </span>. fuel_flow) ; _tmp . put_f32_le (<span class="self">self </span>. engine_load) ; _tmp . put_f32_le (<span class="self">self </span>. throttle_position) ; _tmp . put_f32_le (<span class="self">self </span>. spark_dwell_time) ; _tmp . put_f32_le (<span class="self">self </span>. barometric_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. intake_manifold_pressure) ; _tmp . put_f32_le (<span class="self">self </span>. intake_manifold_temperature) ; _tmp . put_f32_le (<span class="self">self </span>. cylinder_head_temperature) ; _tmp . put_f32_le (<span class="self">self </span>. ignition_timing) ; _tmp . put_f32_le (<span class="self">self </span>. injection_time) ; _tmp . put_f32_le (<span class="self">self </span>. exhaust_gas_temperature) ; _tmp . put_f32_le (<span class="self">self </span>. throttle_out) ; _tmp . put_f32_le (<span class="self">self </span>. pt_compensation) ; _tmp . put_u8 (<span class="self">self </span>. health) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>EFI_STATUS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SET_MAG_OFFSETS_DATA { <span class="kw">pub </span>mag_ofs_x : i16 , <span class="kw">pub </span>mag_ofs_y : i16 , <span class="kw">pub </span>mag_ofs_z : i16 , <span class="kw">pub </span>target_system : u8 , <span class="kw">pub </span>target_component : u8 , } <span class="kw">impl </span>SET_MAG_OFFSETS_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">8usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ mag_ofs_x : <span class="number">0_i16 </span>, mag_ofs_y : <span class="number">0_i16 </span>, mag_ofs_z : <span class="number">0_i16 </span>, target_system : <span class="number">0_u8 </span>, target_component : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . mag_ofs_x = buf . get_i16_le () ; _struct . mag_ofs_y = buf . get_i16_le () ; _struct . mag_ofs_z = buf . get_i16_le () ; _struct . target_system = buf . get_u8 () ; _struct . target_component = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_i16_le (<span class="self">self </span>. mag_ofs_x) ; _tmp . put_i16_le (<span class="self">self </span>. mag_ofs_y) ; _tmp . put_i16_le (<span class="self">self </span>. mag_ofs_z) ; _tmp . put_u8 (<span class="self">self </span>. target_system) ; _tmp . put_u8 (<span class="self">self </span>. target_component) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SET_MAG_OFFSETS_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>DEBUG_VECT_DATA { <span class="kw">pub </span>time_usec : u64 , <span class="kw">pub </span>x : f32 , <span class="kw">pub </span>y : f32 , <span class="kw">pub </span>z : f32 , # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (with = <span class="string">&quot;serde_arrays&quot;</span>))] <span class="kw">pub </span>name : [u8 ; <span class="number">10</span>] , } <span class="kw">impl </span>DEBUG_VECT_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">30usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_usec : <span class="number">0_u64 </span>, x : <span class="number">0.0_f32 </span>, y : <span class="number">0.0_f32 </span>, z : <span class="number">0.0_f32 </span>, name : [<span class="number">0_u8 </span>; <span class="number">10usize</span>] , } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_usec = buf . get_u64_le () ; _struct . x = buf . get_f32_le () ; _struct . y = buf . get_f32_le () ; _struct . z = buf . get_f32_le () ; <span class="kw">for </span>v <span class="kw">in </span>&amp; <span class="kw-2">mut </span>_struct . name { <span class="kw">let </span>val = buf . get_u8 () ; * v = val ; } <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_usec) ; _tmp . put_f32_le (<span class="self">self </span>. x) ; _tmp . put_f32_le (<span class="self">self </span>. y) ; _tmp . put_f32_le (<span class="self">self </span>. z) ; <span class="kw">for </span>val <span class="kw">in </span>&amp; <span class="self">self </span>. name { _tmp . put_u8 (* val) ; } <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>DEBUG_VECT_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>SYSTEM_TIME_DATA { <span class="kw">pub </span>time_unix_usec : u64 , <span class="kw">pub </span>time_boot_ms : u32 , } <span class="kw">impl </span>SYSTEM_TIME_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">12usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ time_unix_usec : <span class="number">0_u64 </span>, time_boot_ms : <span class="number">0_u32 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . time_unix_usec = buf . get_u64_le () ; _struct . time_boot_ms = buf . get_u32_le () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u64_le (<span class="self">self </span>. time_unix_usec) ; _tmp . put_u32_le (<span class="self">self </span>. time_boot_ms) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>SYSTEM_TIME_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Debug , Clone , PartialEq)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] <span class="kw">pub struct </span>CHANGE_OPERATOR_CONTROL_ACK_DATA { <span class="kw">pub </span>gcs_system_id : u8 , <span class="kw">pub </span>control_request : u8 , <span class="kw">pub </span>ack : u8 , } <span class="kw">impl </span>CHANGE_OPERATOR_CONTROL_ACK_DATA { <span class="kw">pub const </span>ENCODED_LEN : usize = <span class="number">3usize </span>; <span class="kw">pub const </span>DEFAULT : <span class="self">Self </span>= <span class="self">Self </span>{ gcs_system_id : <span class="number">0_u8 </span>, control_request : <span class="number">0_u8 </span>, ack : <span class="number">0_u8 </span>, } ; <span class="kw">pub fn </span>deser (_version : MavlinkVersion , _input : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">let </span>avail_len = _input . len () ; <span class="kw">let </span><span class="kw-2">mut </span>payload_buf = [<span class="number">0 </span>; <span class="self">Self </span>:: ENCODED_LEN] ; <span class="kw">let </span><span class="kw-2">mut </span>buf = <span class="kw">if </span>avail_len &lt; <span class="self">Self </span>:: ENCODED_LEN { payload_buf [<span class="number">0 </span>.. avail_len] . copy_from_slice (_input) ; Bytes :: new (&amp; payload_buf) } <span class="kw">else </span>{ Bytes :: new (_input) } ; <span class="kw">let </span><span class="kw-2">mut </span>_struct = <span class="self">Self </span>:: default () ; _struct . gcs_system_id = buf . get_u8 () ; _struct . control_request = buf . get_u8 () ; _struct . ack = buf . get_u8 () ; <span class="prelude-val">Ok </span>(_struct) } <span class="kw">pub fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">let </span><span class="kw-2">mut </span>_tmp = BytesMut :: new (bytes) ; _tmp . put_u8 (<span class="self">self </span>. gcs_system_id) ; _tmp . put_u8 (<span class="self">self </span>. control_request) ; _tmp . put_u8 (<span class="self">self </span>. ack) ; <span class="kw">if </span>matches ! (version , MavlinkVersion :: V2) { <span class="kw">let </span>len = _tmp . len () ; <span class="kw">crate </span>:: remove_trailing_zeroes (&amp; <span class="kw-2">mut </span>bytes [.. len]) } <span class="kw">else </span>{ _tmp . len () } } } <span class="kw">impl </span>Default <span class="kw">for </span>CHANGE_OPERATOR_CONTROL_ACK_DATA { <span class="kw">fn </span>default () -&gt; <span class="self">Self </span>{ <span class="self">Self </span>:: DEFAULT . clone () } } # [derive (Clone , PartialEq , Debug)] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, derive (Serialize , Deserialize))] # [cfg_attr (feature = <span class="string">&quot;serde&quot; </span>, serde (tag = <span class="string">&quot;type&quot;</span>))] <span class="kw">pub enum </span>MavMessage { GOPRO_GET_REQUEST (GOPRO_GET_REQUEST_DATA) , COLLISION (COLLISION_DATA) , RC_CHANNELS_OVERRIDE (RC_CHANNELS_OVERRIDE_DATA) , SAFETY_ALLOWED_AREA (SAFETY_ALLOWED_AREA_DATA) , RC_CHANNELS (RC_CHANNELS_DATA) , RANGEFINDER (RANGEFINDER_DATA) , GIMBAL_DEVICE_ATTITUDE_STATUS (GIMBAL_DEVICE_ATTITUDE_STATUS_DATA) , GLOBAL_POSITION_INT (GLOBAL_POSITION_INT_DATA) , PARAM_VALUE (PARAM_VALUE_DATA) , EVENT (EVENT_DATA) , SCALED_IMU (SCALED_IMU_DATA) , BATTERY_STATUS (BATTERY_STATUS_DATA) , V2_EXTENSION (V2_EXTENSION_DATA) , HIL_STATE (HIL_STATE_DATA) , AOA_SSA (AOA_SSA_DATA) , REQUEST_EVENT (REQUEST_EVENT_DATA) , AIS_VESSEL (AIS_VESSEL_DATA) , DEBUG (DEBUG_DATA) , SUPPORTED_TUNES (SUPPORTED_TUNES_DATA) , DIGICAM_CONFIGURE (DIGICAM_CONFIGURE_DATA) , LED_CONTROL (LED_CONTROL_DATA) , PARAM_EXT_REQUEST_READ (PARAM_EXT_REQUEST_READ_DATA) , AUTH_KEY (AUTH_KEY_DATA) , ONBOARD_COMPUTER_STATUS (ONBOARD_COMPUTER_STATUS_DATA) , WIFI_CONFIG_AP (WIFI_CONFIG_AP_DATA) , WHEEL_DISTANCE (WHEEL_DISTANCE_DATA) , NAMED_VALUE_INT (NAMED_VALUE_INT_DATA) , PLAY_TUNE (PLAY_TUNE_DATA) , PARAM_MAP_RC (PARAM_MAP_RC_DATA) , GPS_INJECT_DATA (GPS_INJECT_DATA_DATA) , CANFD_FRAME (CANFD_FRAME_DATA) , ADAP_TUNING (ADAP_TUNING_DATA) , LOG_REQUEST_DATA (LOG_REQUEST_DATA_DATA) , PARAM_EXT_ACK (PARAM_EXT_ACK_DATA) , VIBRATION (VIBRATION_DATA) , EKF_STATUS_REPORT (EKF_STATUS_REPORT_DATA) , STORAGE_INFORMATION (STORAGE_INFORMATION_DATA) , DEVICE_OP_READ (DEVICE_OP_READ_DATA) , OSD_PARAM_SHOW_CONFIG (OSD_PARAM_SHOW_CONFIG_DATA) , LOGGING_DATA_ACKED (LOGGING_DATA_ACKED_DATA) , HYGROMETER_SENSOR (HYGROMETER_SENSOR_DATA) , VFR_HUD (VFR_HUD_DATA) , UAVIONIX_ADSB_OUT_DYNAMIC (UAVIONIX_ADSB_OUT_DYNAMIC_DATA) , LOCAL_POSITION_NED (LOCAL_POSITION_NED_DATA) , TERRAIN_REQUEST (TERRAIN_REQUEST_DATA) , CAMERA_SETTINGS (CAMERA_SETTINGS_DATA) , FENCE_POINT (FENCE_POINT_DATA) , OPTICAL_FLOW_RAD (OPTICAL_FLOW_RAD_DATA) , HIL_STATE_QUATERNION (HIL_STATE_QUATERNION_DATA) , SCALED_PRESSURE2 (SCALED_PRESSURE2_DATA) , CHANGE_OPERATOR_CONTROL (CHANGE_OPERATOR_CONTROL_DATA) , COMPASSMOT_STATUS (COMPASSMOT_STATUS_DATA) , OPEN_DRONE_ID_ARM_STATUS (OPEN_DRONE_ID_ARM_STATUS_DATA) , LOGGING_ACK (LOGGING_ACK_DATA) , GIMBAL_MANAGER_SET_ATTITUDE (GIMBAL_MANAGER_SET_ATTITUDE_DATA) , TIME_ESTIMATE_TO_TARGET (TIME_ESTIMATE_TO_TARGET_DATA) , SET_MODE (SET_MODE_DATA) , RALLY_FETCH_POINT (RALLY_FETCH_POINT_DATA) , COMMAND_CANCEL (COMMAND_CANCEL_DATA) , REQUEST_DATA_STREAM (REQUEST_DATA_STREAM_DATA) , PARAM_REQUEST_LIST (PARAM_REQUEST_LIST_DATA) , VISION_POSITION_ESTIMATE (VISION_POSITION_ESTIMATE_DATA) , CAMERA_IMAGE_CAPTURED (CAMERA_IMAGE_CAPTURED_DATA) , FOLLOW_TARGET (FOLLOW_TARGET_DATA) , HEARTBEAT (HEARTBEAT_DATA) , DATA64 (DATA64_DATA) , HERELINK_VIDEO_STREAM_INFORMATION (HERELINK_VIDEO_STREAM_INFORMATION_DATA) , GOPRO_HEARTBEAT (GOPRO_HEARTBEAT_DATA) , RC_CHANNELS_SCALED (RC_CHANNELS_SCALED_DATA) , MISSION_REQUEST_INT (MISSION_REQUEST_INT_DATA) , CAN_FRAME (CAN_FRAME_DATA) , HIL_GPS (HIL_GPS_DATA) , GENERATOR_STATUS (GENERATOR_STATUS_DATA) , GIMBAL_MANAGER_INFORMATION (GIMBAL_MANAGER_INFORMATION_DATA) , TERRAIN_CHECK (TERRAIN_CHECK_DATA) , BATTERY2 (BATTERY2_DATA) , CAMERA_FOV_STATUS (CAMERA_FOV_STATUS_DATA) , PARAM_REQUEST_READ (PARAM_REQUEST_READ_DATA) , MISSION_WRITE_PARTIAL_LIST (MISSION_WRITE_PARTIAL_LIST_DATA) , UAVIONIX_ADSB_OUT_CFG (UAVIONIX_ADSB_OUT_CFG_DATA) , CAMERA_INFORMATION (CAMERA_INFORMATION_DATA) , WATER_DEPTH (WATER_DEPTH_DATA) , DATA_STREAM (DATA_STREAM_DATA) , COMMAND_LONG (COMMAND_LONG_DATA) , SETUP_SIGNING (SETUP_SIGNING_DATA) , HIL_CONTROLS (HIL_CONTROLS_DATA) , REMOTE_LOG_DATA_BLOCK (REMOTE_LOG_DATA_BLOCK_DATA) , HIGHRES_IMU (HIGHRES_IMU_DATA) , ORBIT_EXECUTION_STATUS (ORBIT_EXECUTION_STATUS_DATA) , SCALED_IMU2 (SCALED_IMU2_DATA) , MOUNT_CONFIGURE (MOUNT_CONFIGURE_DATA) , MANUAL_CONTROL (MANUAL_CONTROL_DATA) , SAFETY_SET_ALLOWED_AREA (SAFETY_SET_ALLOWED_AREA_DATA) , HWSTATUS (HWSTATUS_DATA) , AUTOPILOT_VERSION_REQUEST (AUTOPILOT_VERSION_REQUEST_DATA) , UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT (UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT_DATA) , LOG_REQUEST_LIST (LOG_REQUEST_LIST_DATA) , GPS2_RTK (GPS2_RTK_DATA) , WIND_COV (WIND_COV_DATA) , DEVICE_OP_READ_REPLY (DEVICE_OP_READ_REPLY_DATA) , DISTANCE_SENSOR (DISTANCE_SENSOR_DATA) , SERIAL_CONTROL (SERIAL_CONTROL_DATA) , LOG_ERASE (LOG_ERASE_DATA) , OPTICAL_FLOW (OPTICAL_FLOW_DATA) , ENCAPSULATED_DATA (ENCAPSULATED_DATA_DATA) , LOG_ENTRY (LOG_ENTRY_DATA) , HIGH_LATENCY2 (HIGH_LATENCY2_DATA) , ISBD_LINK_STATUS (ISBD_LINK_STATUS_DATA) , RESPONSE_EVENT_ERROR (RESPONSE_EVENT_ERROR_DATA) , ESTIMATOR_STATUS (ESTIMATOR_STATUS_DATA) , MCU_STATUS (MCU_STATUS_DATA) , RC_CHANNELS_RAW (RC_CHANNELS_RAW_DATA) , DATA_TRANSMISSION_HANDSHAKE (DATA_TRANSMISSION_HANDSHAKE_DATA) , CAMERA_CAPTURE_STATUS (CAMERA_CAPTURE_STATUS_DATA) , RAW_RPM (RAW_RPM_DATA) , GPS_RTCM_DATA (GPS_RTCM_DATA_DATA) , LOCAL_POSITION_NED_COV (LOCAL_POSITION_NED_COV_DATA) , GOPRO_GET_RESPONSE (GOPRO_GET_RESPONSE_DATA) , OPEN_DRONE_ID_SELF_ID (OPEN_DRONE_ID_SELF_ID_DATA) , ESC_TELEMETRY_9_TO_12 (ESC_TELEMETRY_9_TO_12_DATA) , POWER_STATUS (POWER_STATUS_DATA) , FILE_TRANSFER_PROTOCOL (FILE_TRANSFER_PROTOCOL_DATA) , GPS_RTK (GPS_RTK_DATA) , MISSION_CLEAR_ALL (MISSION_CLEAR_ALL_DATA) , MISSION_REQUEST (MISSION_REQUEST_DATA) , OPEN_DRONE_ID_AUTHENTICATION (OPEN_DRONE_ID_AUTHENTICATION_DATA) , FENCE_FETCH_POINT (FENCE_FETCH_POINT_DATA) , GOPRO_SET_REQUEST (GOPRO_SET_REQUEST_DATA) , HIL_ACTUATOR_CONTROLS (HIL_ACTUATOR_CONTROLS_DATA) , OBSTACLE_DISTANCE_3D (OBSTACLE_DISTANCE_3D_DATA) , ATT_POS_MOCAP (ATT_POS_MOCAP_DATA) , OPEN_DRONE_ID_SYSTEM_UPDATE (OPEN_DRONE_ID_SYSTEM_UPDATE_DATA) , SET_POSITION_TARGET_GLOBAL_INT (SET_POSITION_TARGET_GLOBAL_INT_DATA) , RESOURCE_REQUEST (RESOURCE_REQUEST_DATA) , MAG_CAL_REPORT (MAG_CAL_REPORT_DATA) , HIL_RC_INPUTS_RAW (HIL_RC_INPUTS_RAW_DATA) , MISSION_REQUEST_PARTIAL_LIST (MISSION_REQUEST_PARTIAL_LIST_DATA) , HOME_POSITION (HOME_POSITION_DATA) , RAW_PRESSURE (RAW_PRESSURE_DATA) , DIGICAM_CONTROL (DIGICAM_CONTROL_DATA) , MISSION_CURRENT (MISSION_CURRENT_DATA) , ESC_TELEMETRY_1_TO_4 (ESC_TELEMETRY_1_TO_4_DATA) , OPEN_DRONE_ID_LOCATION (OPEN_DRONE_ID_LOCATION_DATA) , MAG_CAL_PROGRESS (MAG_CAL_PROGRESS_DATA) , COMPONENT_METADATA (COMPONENT_METADATA_DATA) , UTM_GLOBAL_POSITION (UTM_GLOBAL_POSITION_DATA) , POSITION_TARGET_LOCAL_NED (POSITION_TARGET_LOCAL_NED_DATA) , GIMBAL_DEVICE_SET_ATTITUDE (GIMBAL_DEVICE_SET_ATTITUDE_DATA) , VISION_POSITION_DELTA (VISION_POSITION_DELTA_DATA) , HIGH_LATENCY (HIGH_LATENCY_DATA) , TERRAIN_REPORT (TERRAIN_REPORT_DATA) , MISSION_ITEM_INT (MISSION_ITEM_INT_DATA) , DEEPSTALL (DEEPSTALL_DATA) , CAMERA_TRIGGER (CAMERA_TRIGGER_DATA) , MEMORY_VECT (MEMORY_VECT_DATA) , LIMITS_STATUS (LIMITS_STATUS_DATA) , OSD_PARAM_SHOW_CONFIG_REPLY (OSD_PARAM_SHOW_CONFIG_REPLY_DATA) , REMOTE_LOG_BLOCK_STATUS (REMOTE_LOG_BLOCK_STATUS_DATA) , DEVICE_OP_WRITE_REPLY (DEVICE_OP_WRITE_REPLY_DATA) , LANDING_TARGET (LANDING_TARGET_DATA) , GIMBAL_REPORT (GIMBAL_REPORT_DATA) , CAMERA_TRACKING_IMAGE_STATUS (CAMERA_TRACKING_IMAGE_STATUS_DATA) , ATTITUDE_QUATERNION_COV (ATTITUDE_QUATERNION_COV_DATA) , RALLY_POINT (RALLY_POINT_DATA) , SCALED_PRESSURE3 (SCALED_PRESSURE3_DATA) , SIM_STATE (SIM_STATE_DATA) , ACTUATOR_OUTPUT_STATUS (ACTUATOR_OUTPUT_STATUS_DATA) , OPEN_DRONE_ID_MESSAGE_PACK (OPEN_DRONE_ID_MESSAGE_PACK_DATA) , VISION_SPEED_ESTIMATE (VISION_SPEED_ESTIMATE_DATA) , OPEN_DRONE_ID_BASIC_ID (OPEN_DRONE_ID_BASIC_ID_DATA) , TUNNEL (TUNNEL_DATA) , POSITION_TARGET_GLOBAL_INT (POSITION_TARGET_GLOBAL_INT_DATA) , SENSOR_OFFSETS (SENSOR_OFFSETS_DATA) , UAVCAN_NODE_INFO (UAVCAN_NODE_INFO_DATA) , FLIGHT_INFORMATION (FLIGHT_INFORMATION_DATA) , RADIO (RADIO_DATA) , DATA32 (DATA32_DATA) , CUBEPILOT_RAW_RC (CUBEPILOT_RAW_RC_DATA) , SCALED_IMU3 (SCALED_IMU3_DATA) , GIMBAL_MANAGER_SET_MANUAL_CONTROL (GIMBAL_MANAGER_SET_MANUAL_CONTROL_DATA) , GIMBAL_DEVICE_INFORMATION (GIMBAL_DEVICE_INFORMATION_DATA) , TERRAIN_DATA (TERRAIN_DATA_DATA) , ACTUATOR_CONTROL_TARGET (ACTUATOR_CONTROL_TARGET_DATA) , LINK_NODE_STATUS (LINK_NODE_STATUS_DATA) , ESC_STATUS (ESC_STATUS_DATA) , STATUSTEXT (STATUSTEXT_DATA) , SET_ATTITUDE_TARGET (SET_ATTITUDE_TARGET_DATA) , ALTITUDE (ALTITUDE_DATA) , GPS_GLOBAL_ORIGIN (GPS_GLOBAL_ORIGIN_DATA) , VIDEO_STREAM_STATUS (VIDEO_STREAM_STATUS_DATA) , CONTROL_SYSTEM_STATE (CONTROL_SYSTEM_STATE_DATA) , CUBEPILOT_FIRMWARE_UPDATE_START (CUBEPILOT_FIRMWARE_UPDATE_START_DATA) , MISSION_REQUEST_LIST (MISSION_REQUEST_LIST_DATA) , AHRS3 (AHRS3_DATA) , DEVICE_OP_WRITE (DEVICE_OP_WRITE_DATA) , ESC_TELEMETRY_5_TO_8 (ESC_TELEMETRY_5_TO_8_DATA) , MANUAL_SETPOINT (MANUAL_SETPOINT_DATA) , UAVCAN_NODE_STATUS (UAVCAN_NODE_STATUS_DATA) , PARAM_EXT_SET (PARAM_EXT_SET_DATA) , MOUNT_STATUS (MOUNT_STATUS_DATA) , AIRSPEED_AUTOCAL (AIRSPEED_AUTOCAL_DATA) , SCALED_PRESSURE (SCALED_PRESSURE_DATA) , CELLULAR_STATUS (CELLULAR_STATUS_DATA) , SYS_STATUS (SYS_STATUS_DATA) , TRAJECTORY_REPRESENTATION_BEZIER (TRAJECTORY_REPRESENTATION_BEZIER_DATA) , TIMESYNC (TIMESYNC_DATA) , MOUNT_CONTROL (MOUNT_CONTROL_DATA) , CAMERA_FEEDBACK (CAMERA_FEEDBACK_DATA) , BUTTON_CHANGE (BUTTON_CHANGE_DATA) , CAMERA_STATUS (CAMERA_STATUS_DATA) , SET_POSITION_TARGET_LOCAL_NED (SET_POSITION_TARGET_LOCAL_NED_DATA) , ODOMETRY (ODOMETRY_DATA) , GPS_RAW_INT (GPS_RAW_INT_DATA) , GIMBAL_TORQUE_CMD_REPORT (GIMBAL_TORQUE_CMD_REPORT_DATA) , OSD_PARAM_CONFIG (OSD_PARAM_CONFIG_DATA) , DATA16 (DATA16_DATA) , PID_TUNING (PID_TUNING_DATA) , OBSTACLE_DISTANCE (OBSTACLE_DISTANCE_DATA) , COMMAND_INT (COMMAND_INT_DATA) , COMMAND_ACK (COMMAND_ACK_DATA) , ICAROUS_HEARTBEAT (ICAROUS_HEARTBEAT_DATA) , MISSION_SET_CURRENT (MISSION_SET_CURRENT_DATA) , TRAJECTORY_REPRESENTATION_WAYPOINTS (TRAJECTORY_REPRESENTATION_WAYPOINTS_DATA) , WINCH_STATUS (WINCH_STATUS_DATA) , PARAM_EXT_REQUEST_LIST (PARAM_EXT_REQUEST_LIST_DATA) , ICAROUS_KINEMATIC_BANDS (ICAROUS_KINEMATIC_BANDS_DATA) , CUBEPILOT_FIRMWARE_UPDATE_RESP (CUBEPILOT_FIRMWARE_UPDATE_RESP_DATA) , AHRS (AHRS_DATA) , CAN_FILTER_MODIFY (CAN_FILTER_MODIFY_DATA) , SET_HOME_POSITION (SET_HOME_POSITION_DATA) , GPS_STATUS (GPS_STATUS_DATA) , RAW_IMU (RAW_IMU_DATA) , GOPRO_SET_RESPONSE (GOPRO_SET_RESPONSE_DATA) , LOGGING_DATA (LOGGING_DATA_DATA) , SIMSTATE (SIMSTATE_DATA) , ATTITUDE_QUATERNION (ATTITUDE_QUATERNION_DATA) , HIL_OPTICAL_FLOW (HIL_OPTICAL_FLOW_DATA) , RPM (RPM_DATA) , OSD_PARAM_CONFIG_REPLY (OSD_PARAM_CONFIG_REPLY_DATA) , PROTOCOL_VERSION (PROTOCOL_VERSION_DATA) , ATTITUDE_TARGET (ATTITUDE_TARGET_DATA) , PARAM_SET (PARAM_SET_DATA) , AHRS2 (AHRS2_DATA) , WIND (WIND_DATA) , VICON_POSITION_ESTIMATE (VICON_POSITION_ESTIMATE_DATA) , MISSION_COUNT (MISSION_COUNT_DATA) , LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET (LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_DATA) , NAMED_VALUE_FLOAT (NAMED_VALUE_FLOAT_DATA) , PLAY_TUNE_V2 (PLAY_TUNE_V2_DATA) , MEMINFO (MEMINFO_DATA) , DATA96 (DATA96_DATA) , GIMBAL_CONTROL (GIMBAL_CONTROL_DATA) , LOG_DATA (LOG_DATA_DATA) , SET_GPS_GLOBAL_ORIGIN (SET_GPS_GLOBAL_ORIGIN_DATA) , MOUNT_ORIENTATION (MOUNT_ORIENTATION_DATA) , GPS2_RAW (GPS2_RAW_DATA) , GLOBAL_VISION_POSITION_ESTIMATE (GLOBAL_VISION_POSITION_ESTIMATE_DATA) , HERELINK_TELEM (HERELINK_TELEM_DATA) , CAMERA_TRACKING_GEO_STATUS (CAMERA_TRACKING_GEO_STATUS_DATA) , CURRENT_EVENT_SEQUENCE (CURRENT_EVENT_SEQUENCE_DATA) , MESSAGE_INTERVAL (MESSAGE_INTERVAL_DATA) , MISSION_ITEM (MISSION_ITEM_DATA) , RADIO_STATUS (RADIO_STATUS_DATA) , FENCE_STATUS (FENCE_STATUS_DATA) , HIL_SENSOR (HIL_SENSOR_DATA) , MISSION_ACK (MISSION_ACK_DATA) , GLOBAL_POSITION_INT_COV (GLOBAL_POSITION_INT_COV_DATA) , CELLULAR_CONFIG (CELLULAR_CONFIG_DATA) , VIDEO_STREAM_INFORMATION (VIDEO_STREAM_INFORMATION_DATA) , ADSB_VEHICLE (ADSB_VEHICLE_DATA) , OPEN_DRONE_ID_SYSTEM (OPEN_DRONE_ID_SYSTEM_DATA) , GPS_INPUT (GPS_INPUT_DATA) , GIMBAL_MANAGER_STATUS (GIMBAL_MANAGER_STATUS_DATA) , EXTENDED_SYS_STATE (EXTENDED_SYS_STATE_DATA) , OPEN_DRONE_ID_OPERATOR_ID (OPEN_DRONE_ID_OPERATOR_ID_DATA) , SET_ACTUATOR_CONTROL_TARGET (SET_ACTUATOR_CONTROL_TARGET_DATA) , DEBUG_FLOAT_ARRAY (DEBUG_FLOAT_ARRAY_DATA) , AP_ADC (AP_ADC_DATA) , SMART_BATTERY_INFO (SMART_BATTERY_INFO_DATA) , LOG_REQUEST_END (LOG_REQUEST_END_DATA) , GIMBAL_MANAGER_SET_PITCHYAW (GIMBAL_MANAGER_SET_PITCHYAW_DATA) , COMPONENT_INFORMATION (COMPONENT_INFORMATION_DATA) , SERVO_OUTPUT_RAW (SERVO_OUTPUT_RAW_DATA) , ATTITUDE (ATTITUDE_DATA) , ESC_INFO (ESC_INFO_DATA) , PING (PING_DATA) , PARAM_EXT_VALUE (PARAM_EXT_VALUE_DATA) , AUTOPILOT_STATE_FOR_GIMBAL_DEVICE (AUTOPILOT_STATE_FOR_GIMBAL_DEVICE_DATA) , AUTOPILOT_VERSION (AUTOPILOT_VERSION_DATA) , NAV_CONTROLLER_OUTPUT (NAV_CONTROLLER_OUTPUT_DATA) , MISSION_ITEM_REACHED (MISSION_ITEM_REACHED_DATA) , EFI_STATUS (EFI_STATUS_DATA) , SET_MAG_OFFSETS (SET_MAG_OFFSETS_DATA) , DEBUG_VECT (DEBUG_VECT_DATA) , SYSTEM_TIME (SYSTEM_TIME_DATA) , CHANGE_OPERATOR_CONTROL_ACK (CHANGE_OPERATOR_CONTROL_ACK_DATA) , } <span class="kw">impl </span>Message <span class="kw">for </span>MavMessage { <span class="kw">fn </span>parse (version : MavlinkVersion , id : u32 , payload : &amp; [u8]) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, ParserError &gt; { <span class="kw">match </span>id { <span class="number">216u32 </span>=&gt; GOPRO_GET_REQUEST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GOPRO_GET_REQUEST) , <span class="number">247u32 </span>=&gt; COLLISION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COLLISION) , <span class="number">70u32 </span>=&gt; RC_CHANNELS_OVERRIDE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RC_CHANNELS_OVERRIDE) , <span class="number">55u32 </span>=&gt; SAFETY_ALLOWED_AREA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SAFETY_ALLOWED_AREA) , <span class="number">65u32 </span>=&gt; RC_CHANNELS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RC_CHANNELS) , <span class="number">173u32 </span>=&gt; RANGEFINDER_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RANGEFINDER) , <span class="number">285u32 </span>=&gt; GIMBAL_DEVICE_ATTITUDE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_DEVICE_ATTITUDE_STATUS) , <span class="number">33u32 </span>=&gt; GLOBAL_POSITION_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GLOBAL_POSITION_INT) , <span class="number">22u32 </span>=&gt; PARAM_VALUE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_VALUE) , <span class="number">410u32 </span>=&gt; EVENT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: EVENT) , <span class="number">26u32 </span>=&gt; SCALED_IMU_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_IMU) , <span class="number">147u32 </span>=&gt; BATTERY_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: BATTERY_STATUS) , <span class="number">248u32 </span>=&gt; V2_EXTENSION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: V2_EXTENSION) , <span class="number">90u32 </span>=&gt; HIL_STATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_STATE) , <span class="number">11020u32 </span>=&gt; AOA_SSA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AOA_SSA) , <span class="number">412u32 </span>=&gt; REQUEST_EVENT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: REQUEST_EVENT) , <span class="number">301u32 </span>=&gt; AIS_VESSEL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AIS_VESSEL) , <span class="number">254u32 </span>=&gt; DEBUG_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DEBUG) , <span class="number">401u32 </span>=&gt; SUPPORTED_TUNES_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SUPPORTED_TUNES) , <span class="number">154u32 </span>=&gt; DIGICAM_CONFIGURE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DIGICAM_CONFIGURE) , <span class="number">186u32 </span>=&gt; LED_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LED_CONTROL) , <span class="number">320u32 </span>=&gt; PARAM_EXT_REQUEST_READ_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_EXT_REQUEST_READ) , <span class="number">7u32 </span>=&gt; AUTH_KEY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AUTH_KEY) , <span class="number">390u32 </span>=&gt; ONBOARD_COMPUTER_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ONBOARD_COMPUTER_STATUS) , <span class="number">299u32 </span>=&gt; WIFI_CONFIG_AP_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: WIFI_CONFIG_AP) , <span class="number">9000u32 </span>=&gt; WHEEL_DISTANCE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: WHEEL_DISTANCE) , <span class="number">252u32 </span>=&gt; NAMED_VALUE_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: NAMED_VALUE_INT) , <span class="number">258u32 </span>=&gt; PLAY_TUNE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PLAY_TUNE) , <span class="number">50u32 </span>=&gt; PARAM_MAP_RC_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_MAP_RC) , <span class="number">123u32 </span>=&gt; GPS_INJECT_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_INJECT_DATA) , <span class="number">387u32 </span>=&gt; CANFD_FRAME_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CANFD_FRAME) , <span class="number">11010u32 </span>=&gt; ADAP_TUNING_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ADAP_TUNING) , <span class="number">119u32 </span>=&gt; LOG_REQUEST_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_REQUEST_DATA) , <span class="number">324u32 </span>=&gt; PARAM_EXT_ACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_EXT_ACK) , <span class="number">241u32 </span>=&gt; VIBRATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VIBRATION) , <span class="number">193u32 </span>=&gt; EKF_STATUS_REPORT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: EKF_STATUS_REPORT) , <span class="number">261u32 </span>=&gt; STORAGE_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: STORAGE_INFORMATION) , <span class="number">11000u32 </span>=&gt; DEVICE_OP_READ_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DEVICE_OP_READ) , <span class="number">11035u32 </span>=&gt; OSD_PARAM_SHOW_CONFIG_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OSD_PARAM_SHOW_CONFIG) , <span class="number">267u32 </span>=&gt; LOGGING_DATA_ACKED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOGGING_DATA_ACKED) , <span class="number">12920u32 </span>=&gt; HYGROMETER_SENSOR_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HYGROMETER_SENSOR) , <span class="number">74u32 </span>=&gt; VFR_HUD_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VFR_HUD) , <span class="number">10002u32 </span>=&gt; UAVIONIX_ADSB_OUT_DYNAMIC_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC) , <span class="number">32u32 </span>=&gt; LOCAL_POSITION_NED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOCAL_POSITION_NED) , <span class="number">133u32 </span>=&gt; TERRAIN_REQUEST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TERRAIN_REQUEST) , <span class="number">260u32 </span>=&gt; CAMERA_SETTINGS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_SETTINGS) , <span class="number">160u32 </span>=&gt; FENCE_POINT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: FENCE_POINT) , <span class="number">106u32 </span>=&gt; OPTICAL_FLOW_RAD_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPTICAL_FLOW_RAD) , <span class="number">115u32 </span>=&gt; HIL_STATE_QUATERNION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_STATE_QUATERNION) , <span class="number">137u32 </span>=&gt; SCALED_PRESSURE2_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_PRESSURE2) , <span class="number">5u32 </span>=&gt; CHANGE_OPERATOR_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL) , <span class="number">177u32 </span>=&gt; COMPASSMOT_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMPASSMOT_STATUS) , <span class="number">12918u32 </span>=&gt; OPEN_DRONE_ID_ARM_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_ARM_STATUS) , <span class="number">268u32 </span>=&gt; LOGGING_ACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOGGING_ACK) , <span class="number">282u32 </span>=&gt; GIMBAL_MANAGER_SET_ATTITUDE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_MANAGER_SET_ATTITUDE) , <span class="number">380u32 </span>=&gt; TIME_ESTIMATE_TO_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TIME_ESTIMATE_TO_TARGET) , <span class="number">11u32 </span>=&gt; SET_MODE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_MODE) , <span class="number">176u32 </span>=&gt; RALLY_FETCH_POINT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RALLY_FETCH_POINT) , <span class="number">80u32 </span>=&gt; COMMAND_CANCEL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMMAND_CANCEL) , <span class="number">66u32 </span>=&gt; REQUEST_DATA_STREAM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: REQUEST_DATA_STREAM) , <span class="number">21u32 </span>=&gt; PARAM_REQUEST_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_REQUEST_LIST) , <span class="number">102u32 </span>=&gt; VISION_POSITION_ESTIMATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VISION_POSITION_ESTIMATE) , <span class="number">263u32 </span>=&gt; CAMERA_IMAGE_CAPTURED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_IMAGE_CAPTURED) , <span class="number">144u32 </span>=&gt; FOLLOW_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: FOLLOW_TARGET) , <span class="number">0u32 </span>=&gt; HEARTBEAT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HEARTBEAT) , <span class="number">171u32 </span>=&gt; DATA64_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DATA64) , <span class="number">50002u32 </span>=&gt; HERELINK_VIDEO_STREAM_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HERELINK_VIDEO_STREAM_INFORMATION) , <span class="number">215u32 </span>=&gt; GOPRO_HEARTBEAT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GOPRO_HEARTBEAT) , <span class="number">34u32 </span>=&gt; RC_CHANNELS_SCALED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RC_CHANNELS_SCALED) , <span class="number">51u32 </span>=&gt; MISSION_REQUEST_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_REQUEST_INT) , <span class="number">386u32 </span>=&gt; CAN_FRAME_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAN_FRAME) , <span class="number">113u32 </span>=&gt; HIL_GPS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_GPS) , <span class="number">373u32 </span>=&gt; GENERATOR_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GENERATOR_STATUS) , <span class="number">280u32 </span>=&gt; GIMBAL_MANAGER_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_MANAGER_INFORMATION) , <span class="number">135u32 </span>=&gt; TERRAIN_CHECK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TERRAIN_CHECK) , <span class="number">181u32 </span>=&gt; BATTERY2_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: BATTERY2) , <span class="number">271u32 </span>=&gt; CAMERA_FOV_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_FOV_STATUS) , <span class="number">20u32 </span>=&gt; PARAM_REQUEST_READ_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_REQUEST_READ) , <span class="number">38u32 </span>=&gt; MISSION_WRITE_PARTIAL_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_WRITE_PARTIAL_LIST) , <span class="number">10001u32 </span>=&gt; UAVIONIX_ADSB_OUT_CFG_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG) , <span class="number">259u32 </span>=&gt; CAMERA_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_INFORMATION) , <span class="number">11038u32 </span>=&gt; WATER_DEPTH_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: WATER_DEPTH) , <span class="number">67u32 </span>=&gt; DATA_STREAM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DATA_STREAM) , <span class="number">76u32 </span>=&gt; COMMAND_LONG_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMMAND_LONG) , <span class="number">256u32 </span>=&gt; SETUP_SIGNING_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SETUP_SIGNING) , <span class="number">91u32 </span>=&gt; HIL_CONTROLS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_CONTROLS) , <span class="number">184u32 </span>=&gt; REMOTE_LOG_DATA_BLOCK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: REMOTE_LOG_DATA_BLOCK) , <span class="number">105u32 </span>=&gt; HIGHRES_IMU_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIGHRES_IMU) , <span class="number">360u32 </span>=&gt; ORBIT_EXECUTION_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ORBIT_EXECUTION_STATUS) , <span class="number">116u32 </span>=&gt; SCALED_IMU2_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_IMU2) , <span class="number">156u32 </span>=&gt; MOUNT_CONFIGURE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MOUNT_CONFIGURE) , <span class="number">69u32 </span>=&gt; MANUAL_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MANUAL_CONTROL) , <span class="number">54u32 </span>=&gt; SAFETY_SET_ALLOWED_AREA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SAFETY_SET_ALLOWED_AREA) , <span class="number">165u32 </span>=&gt; HWSTATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HWSTATUS) , <span class="number">183u32 </span>=&gt; AUTOPILOT_VERSION_REQUEST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AUTOPILOT_VERSION_REQUEST) , <span class="number">10003u32 </span>=&gt; UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT) , <span class="number">117u32 </span>=&gt; LOG_REQUEST_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_REQUEST_LIST) , <span class="number">128u32 </span>=&gt; GPS2_RTK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS2_RTK) , <span class="number">231u32 </span>=&gt; WIND_COV_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: WIND_COV) , <span class="number">11001u32 </span>=&gt; DEVICE_OP_READ_REPLY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DEVICE_OP_READ_REPLY) , <span class="number">132u32 </span>=&gt; DISTANCE_SENSOR_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DISTANCE_SENSOR) , <span class="number">126u32 </span>=&gt; SERIAL_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SERIAL_CONTROL) , <span class="number">121u32 </span>=&gt; LOG_ERASE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_ERASE) , <span class="number">100u32 </span>=&gt; OPTICAL_FLOW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPTICAL_FLOW) , <span class="number">131u32 </span>=&gt; ENCAPSULATED_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ENCAPSULATED_DATA) , <span class="number">118u32 </span>=&gt; LOG_ENTRY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_ENTRY) , <span class="number">235u32 </span>=&gt; HIGH_LATENCY2_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIGH_LATENCY2) , <span class="number">335u32 </span>=&gt; ISBD_LINK_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ISBD_LINK_STATUS) , <span class="number">413u32 </span>=&gt; RESPONSE_EVENT_ERROR_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RESPONSE_EVENT_ERROR) , <span class="number">230u32 </span>=&gt; ESTIMATOR_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ESTIMATOR_STATUS) , <span class="number">11039u32 </span>=&gt; MCU_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MCU_STATUS) , <span class="number">35u32 </span>=&gt; RC_CHANNELS_RAW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RC_CHANNELS_RAW) , <span class="number">130u32 </span>=&gt; DATA_TRANSMISSION_HANDSHAKE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DATA_TRANSMISSION_HANDSHAKE) , <span class="number">262u32 </span>=&gt; CAMERA_CAPTURE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_CAPTURE_STATUS) , <span class="number">339u32 </span>=&gt; RAW_RPM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RAW_RPM) , <span class="number">233u32 </span>=&gt; GPS_RTCM_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_RTCM_DATA) , <span class="number">64u32 </span>=&gt; LOCAL_POSITION_NED_COV_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOCAL_POSITION_NED_COV) , <span class="number">217u32 </span>=&gt; GOPRO_GET_RESPONSE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GOPRO_GET_RESPONSE) , <span class="number">12903u32 </span>=&gt; OPEN_DRONE_ID_SELF_ID_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_SELF_ID) , <span class="number">11032u32 </span>=&gt; ESC_TELEMETRY_9_TO_12_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ESC_TELEMETRY_9_TO_12) , <span class="number">125u32 </span>=&gt; POWER_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: POWER_STATUS) , <span class="number">110u32 </span>=&gt; FILE_TRANSFER_PROTOCOL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: FILE_TRANSFER_PROTOCOL) , <span class="number">127u32 </span>=&gt; GPS_RTK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_RTK) , <span class="number">45u32 </span>=&gt; MISSION_CLEAR_ALL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_CLEAR_ALL) , <span class="number">40u32 </span>=&gt; MISSION_REQUEST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_REQUEST) , <span class="number">12902u32 </span>=&gt; OPEN_DRONE_ID_AUTHENTICATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_AUTHENTICATION) , <span class="number">161u32 </span>=&gt; FENCE_FETCH_POINT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: FENCE_FETCH_POINT) , <span class="number">218u32 </span>=&gt; GOPRO_SET_REQUEST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GOPRO_SET_REQUEST) , <span class="number">93u32 </span>=&gt; HIL_ACTUATOR_CONTROLS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_ACTUATOR_CONTROLS) , <span class="number">11037u32 </span>=&gt; OBSTACLE_DISTANCE_3D_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OBSTACLE_DISTANCE_3D) , <span class="number">138u32 </span>=&gt; ATT_POS_MOCAP_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ATT_POS_MOCAP) , <span class="number">12919u32 </span>=&gt; OPEN_DRONE_ID_SYSTEM_UPDATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM_UPDATE) , <span class="number">86u32 </span>=&gt; SET_POSITION_TARGET_GLOBAL_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_POSITION_TARGET_GLOBAL_INT) , <span class="number">142u32 </span>=&gt; RESOURCE_REQUEST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RESOURCE_REQUEST) , <span class="number">192u32 </span>=&gt; MAG_CAL_REPORT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MAG_CAL_REPORT) , <span class="number">92u32 </span>=&gt; HIL_RC_INPUTS_RAW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_RC_INPUTS_RAW) , <span class="number">37u32 </span>=&gt; MISSION_REQUEST_PARTIAL_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_REQUEST_PARTIAL_LIST) , <span class="number">242u32 </span>=&gt; HOME_POSITION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HOME_POSITION) , <span class="number">28u32 </span>=&gt; RAW_PRESSURE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RAW_PRESSURE) , <span class="number">155u32 </span>=&gt; DIGICAM_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DIGICAM_CONTROL) , <span class="number">42u32 </span>=&gt; MISSION_CURRENT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_CURRENT) , <span class="number">11030u32 </span>=&gt; ESC_TELEMETRY_1_TO_4_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ESC_TELEMETRY_1_TO_4) , <span class="number">12901u32 </span>=&gt; OPEN_DRONE_ID_LOCATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_LOCATION) , <span class="number">191u32 </span>=&gt; MAG_CAL_PROGRESS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MAG_CAL_PROGRESS) , <span class="number">397u32 </span>=&gt; COMPONENT_METADATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMPONENT_METADATA) , <span class="number">340u32 </span>=&gt; UTM_GLOBAL_POSITION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UTM_GLOBAL_POSITION) , <span class="number">85u32 </span>=&gt; POSITION_TARGET_LOCAL_NED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: POSITION_TARGET_LOCAL_NED) , <span class="number">284u32 </span>=&gt; GIMBAL_DEVICE_SET_ATTITUDE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_DEVICE_SET_ATTITUDE) , <span class="number">11011u32 </span>=&gt; VISION_POSITION_DELTA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VISION_POSITION_DELTA) , <span class="number">234u32 </span>=&gt; HIGH_LATENCY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIGH_LATENCY) , <span class="number">136u32 </span>=&gt; TERRAIN_REPORT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TERRAIN_REPORT) , <span class="number">73u32 </span>=&gt; MISSION_ITEM_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_ITEM_INT) , <span class="number">195u32 </span>=&gt; DEEPSTALL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DEEPSTALL) , <span class="number">112u32 </span>=&gt; CAMERA_TRIGGER_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_TRIGGER) , <span class="number">249u32 </span>=&gt; MEMORY_VECT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MEMORY_VECT) , <span class="number">167u32 </span>=&gt; LIMITS_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LIMITS_STATUS) , <span class="number">11036u32 </span>=&gt; OSD_PARAM_SHOW_CONFIG_REPLY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OSD_PARAM_SHOW_CONFIG_REPLY) , <span class="number">185u32 </span>=&gt; REMOTE_LOG_BLOCK_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: REMOTE_LOG_BLOCK_STATUS) , <span class="number">11003u32 </span>=&gt; DEVICE_OP_WRITE_REPLY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DEVICE_OP_WRITE_REPLY) , <span class="number">149u32 </span>=&gt; LANDING_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LANDING_TARGET) , <span class="number">200u32 </span>=&gt; GIMBAL_REPORT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_REPORT) , <span class="number">275u32 </span>=&gt; CAMERA_TRACKING_IMAGE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_TRACKING_IMAGE_STATUS) , <span class="number">61u32 </span>=&gt; ATTITUDE_QUATERNION_COV_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ATTITUDE_QUATERNION_COV) , <span class="number">175u32 </span>=&gt; RALLY_POINT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RALLY_POINT) , <span class="number">143u32 </span>=&gt; SCALED_PRESSURE3_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_PRESSURE3) , <span class="number">108u32 </span>=&gt; SIM_STATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SIM_STATE) , <span class="number">375u32 </span>=&gt; ACTUATOR_OUTPUT_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ACTUATOR_OUTPUT_STATUS) , <span class="number">12915u32 </span>=&gt; OPEN_DRONE_ID_MESSAGE_PACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_MESSAGE_PACK) , <span class="number">103u32 </span>=&gt; VISION_SPEED_ESTIMATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VISION_SPEED_ESTIMATE) , <span class="number">12900u32 </span>=&gt; OPEN_DRONE_ID_BASIC_ID_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_BASIC_ID) , <span class="number">385u32 </span>=&gt; TUNNEL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TUNNEL) , <span class="number">87u32 </span>=&gt; POSITION_TARGET_GLOBAL_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: POSITION_TARGET_GLOBAL_INT) , <span class="number">150u32 </span>=&gt; SENSOR_OFFSETS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SENSOR_OFFSETS) , <span class="number">311u32 </span>=&gt; UAVCAN_NODE_INFO_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UAVCAN_NODE_INFO) , <span class="number">264u32 </span>=&gt; FLIGHT_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: FLIGHT_INFORMATION) , <span class="number">166u32 </span>=&gt; RADIO_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RADIO) , <span class="number">170u32 </span>=&gt; DATA32_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DATA32) , <span class="number">50001u32 </span>=&gt; CUBEPILOT_RAW_RC_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CUBEPILOT_RAW_RC) , <span class="number">129u32 </span>=&gt; SCALED_IMU3_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_IMU3) , <span class="number">288u32 </span>=&gt; GIMBAL_MANAGER_SET_MANUAL_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_MANAGER_SET_MANUAL_CONTROL) , <span class="number">283u32 </span>=&gt; GIMBAL_DEVICE_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_DEVICE_INFORMATION) , <span class="number">134u32 </span>=&gt; TERRAIN_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TERRAIN_DATA) , <span class="number">140u32 </span>=&gt; ACTUATOR_CONTROL_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ACTUATOR_CONTROL_TARGET) , <span class="number">8u32 </span>=&gt; LINK_NODE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LINK_NODE_STATUS) , <span class="number">291u32 </span>=&gt; ESC_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ESC_STATUS) , <span class="number">253u32 </span>=&gt; STATUSTEXT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: STATUSTEXT) , <span class="number">82u32 </span>=&gt; SET_ATTITUDE_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_ATTITUDE_TARGET) , <span class="number">141u32 </span>=&gt; ALTITUDE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ALTITUDE) , <span class="number">49u32 </span>=&gt; GPS_GLOBAL_ORIGIN_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_GLOBAL_ORIGIN) , <span class="number">270u32 </span>=&gt; VIDEO_STREAM_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VIDEO_STREAM_STATUS) , <span class="number">146u32 </span>=&gt; CONTROL_SYSTEM_STATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CONTROL_SYSTEM_STATE) , <span class="number">50004u32 </span>=&gt; CUBEPILOT_FIRMWARE_UPDATE_START_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CUBEPILOT_FIRMWARE_UPDATE_START) , <span class="number">43u32 </span>=&gt; MISSION_REQUEST_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_REQUEST_LIST) , <span class="number">182u32 </span>=&gt; AHRS3_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AHRS3) , <span class="number">11002u32 </span>=&gt; DEVICE_OP_WRITE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DEVICE_OP_WRITE) , <span class="number">11031u32 </span>=&gt; ESC_TELEMETRY_5_TO_8_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ESC_TELEMETRY_5_TO_8) , <span class="number">81u32 </span>=&gt; MANUAL_SETPOINT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MANUAL_SETPOINT) , <span class="number">310u32 </span>=&gt; UAVCAN_NODE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: UAVCAN_NODE_STATUS) , <span class="number">323u32 </span>=&gt; PARAM_EXT_SET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_EXT_SET) , <span class="number">158u32 </span>=&gt; MOUNT_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MOUNT_STATUS) , <span class="number">174u32 </span>=&gt; AIRSPEED_AUTOCAL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AIRSPEED_AUTOCAL) , <span class="number">29u32 </span>=&gt; SCALED_PRESSURE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SCALED_PRESSURE) , <span class="number">334u32 </span>=&gt; CELLULAR_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CELLULAR_STATUS) , <span class="number">1u32 </span>=&gt; SYS_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SYS_STATUS) , <span class="number">333u32 </span>=&gt; TRAJECTORY_REPRESENTATION_BEZIER_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_BEZIER) , <span class="number">111u32 </span>=&gt; TIMESYNC_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TIMESYNC) , <span class="number">157u32 </span>=&gt; MOUNT_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MOUNT_CONTROL) , <span class="number">180u32 </span>=&gt; CAMERA_FEEDBACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_FEEDBACK) , <span class="number">257u32 </span>=&gt; BUTTON_CHANGE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: BUTTON_CHANGE) , <span class="number">179u32 </span>=&gt; CAMERA_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_STATUS) , <span class="number">84u32 </span>=&gt; SET_POSITION_TARGET_LOCAL_NED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_POSITION_TARGET_LOCAL_NED) , <span class="number">331u32 </span>=&gt; ODOMETRY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ODOMETRY) , <span class="number">24u32 </span>=&gt; GPS_RAW_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_RAW_INT) , <span class="number">214u32 </span>=&gt; GIMBAL_TORQUE_CMD_REPORT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_TORQUE_CMD_REPORT) , <span class="number">11033u32 </span>=&gt; OSD_PARAM_CONFIG_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OSD_PARAM_CONFIG) , <span class="number">169u32 </span>=&gt; DATA16_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DATA16) , <span class="number">194u32 </span>=&gt; PID_TUNING_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PID_TUNING) , <span class="number">330u32 </span>=&gt; OBSTACLE_DISTANCE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OBSTACLE_DISTANCE) , <span class="number">75u32 </span>=&gt; COMMAND_INT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMMAND_INT) , <span class="number">77u32 </span>=&gt; COMMAND_ACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMMAND_ACK) , <span class="number">42000u32 </span>=&gt; ICAROUS_HEARTBEAT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ICAROUS_HEARTBEAT) , <span class="number">41u32 </span>=&gt; MISSION_SET_CURRENT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_SET_CURRENT) , <span class="number">332u32 </span>=&gt; TRAJECTORY_REPRESENTATION_WAYPOINTS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_WAYPOINTS) , <span class="number">9005u32 </span>=&gt; WINCH_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: WINCH_STATUS) , <span class="number">321u32 </span>=&gt; PARAM_EXT_REQUEST_LIST_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_EXT_REQUEST_LIST) , <span class="number">42001u32 </span>=&gt; ICAROUS_KINEMATIC_BANDS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ICAROUS_KINEMATIC_BANDS) , <span class="number">50005u32 </span>=&gt; CUBEPILOT_FIRMWARE_UPDATE_RESP_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CUBEPILOT_FIRMWARE_UPDATE_RESP) , <span class="number">163u32 </span>=&gt; AHRS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AHRS) , <span class="number">388u32 </span>=&gt; CAN_FILTER_MODIFY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAN_FILTER_MODIFY) , <span class="number">243u32 </span>=&gt; SET_HOME_POSITION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_HOME_POSITION) , <span class="number">25u32 </span>=&gt; GPS_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_STATUS) , <span class="number">27u32 </span>=&gt; RAW_IMU_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RAW_IMU) , <span class="number">219u32 </span>=&gt; GOPRO_SET_RESPONSE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GOPRO_SET_RESPONSE) , <span class="number">266u32 </span>=&gt; LOGGING_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOGGING_DATA) , <span class="number">164u32 </span>=&gt; SIMSTATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SIMSTATE) , <span class="number">31u32 </span>=&gt; ATTITUDE_QUATERNION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ATTITUDE_QUATERNION) , <span class="number">114u32 </span>=&gt; HIL_OPTICAL_FLOW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_OPTICAL_FLOW) , <span class="number">226u32 </span>=&gt; RPM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RPM) , <span class="number">11034u32 </span>=&gt; OSD_PARAM_CONFIG_REPLY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OSD_PARAM_CONFIG_REPLY) , <span class="number">300u32 </span>=&gt; PROTOCOL_VERSION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PROTOCOL_VERSION) , <span class="number">83u32 </span>=&gt; ATTITUDE_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ATTITUDE_TARGET) , <span class="number">23u32 </span>=&gt; PARAM_SET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_SET) , <span class="number">178u32 </span>=&gt; AHRS2_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AHRS2) , <span class="number">168u32 </span>=&gt; WIND_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: WIND) , <span class="number">104u32 </span>=&gt; VICON_POSITION_ESTIMATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VICON_POSITION_ESTIMATE) , <span class="number">44u32 </span>=&gt; MISSION_COUNT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_COUNT) , <span class="number">89u32 </span>=&gt; LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET) , <span class="number">251u32 </span>=&gt; NAMED_VALUE_FLOAT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: NAMED_VALUE_FLOAT) , <span class="number">400u32 </span>=&gt; PLAY_TUNE_V2_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PLAY_TUNE_V2) , <span class="number">152u32 </span>=&gt; MEMINFO_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MEMINFO) , <span class="number">172u32 </span>=&gt; DATA96_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DATA96) , <span class="number">201u32 </span>=&gt; GIMBAL_CONTROL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_CONTROL) , <span class="number">120u32 </span>=&gt; LOG_DATA_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_DATA) , <span class="number">48u32 </span>=&gt; SET_GPS_GLOBAL_ORIGIN_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_GPS_GLOBAL_ORIGIN) , <span class="number">265u32 </span>=&gt; MOUNT_ORIENTATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MOUNT_ORIENTATION) , <span class="number">124u32 </span>=&gt; GPS2_RAW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS2_RAW) , <span class="number">101u32 </span>=&gt; GLOBAL_VISION_POSITION_ESTIMATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GLOBAL_VISION_POSITION_ESTIMATE) , <span class="number">50003u32 </span>=&gt; HERELINK_TELEM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HERELINK_TELEM) , <span class="number">276u32 </span>=&gt; CAMERA_TRACKING_GEO_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CAMERA_TRACKING_GEO_STATUS) , <span class="number">411u32 </span>=&gt; CURRENT_EVENT_SEQUENCE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CURRENT_EVENT_SEQUENCE) , <span class="number">244u32 </span>=&gt; MESSAGE_INTERVAL_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MESSAGE_INTERVAL) , <span class="number">39u32 </span>=&gt; MISSION_ITEM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_ITEM) , <span class="number">109u32 </span>=&gt; RADIO_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: RADIO_STATUS) , <span class="number">162u32 </span>=&gt; FENCE_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: FENCE_STATUS) , <span class="number">107u32 </span>=&gt; HIL_SENSOR_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: HIL_SENSOR) , <span class="number">47u32 </span>=&gt; MISSION_ACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_ACK) , <span class="number">63u32 </span>=&gt; GLOBAL_POSITION_INT_COV_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GLOBAL_POSITION_INT_COV) , <span class="number">336u32 </span>=&gt; CELLULAR_CONFIG_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CELLULAR_CONFIG) , <span class="number">269u32 </span>=&gt; VIDEO_STREAM_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: VIDEO_STREAM_INFORMATION) , <span class="number">246u32 </span>=&gt; ADSB_VEHICLE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ADSB_VEHICLE) , <span class="number">12904u32 </span>=&gt; OPEN_DRONE_ID_SYSTEM_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM) , <span class="number">232u32 </span>=&gt; GPS_INPUT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GPS_INPUT) , <span class="number">281u32 </span>=&gt; GIMBAL_MANAGER_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_MANAGER_STATUS) , <span class="number">245u32 </span>=&gt; EXTENDED_SYS_STATE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: EXTENDED_SYS_STATE) , <span class="number">12905u32 </span>=&gt; OPEN_DRONE_ID_OPERATOR_ID_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: OPEN_DRONE_ID_OPERATOR_ID) , <span class="number">139u32 </span>=&gt; SET_ACTUATOR_CONTROL_TARGET_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_ACTUATOR_CONTROL_TARGET) , <span class="number">350u32 </span>=&gt; DEBUG_FLOAT_ARRAY_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DEBUG_FLOAT_ARRAY) , <span class="number">153u32 </span>=&gt; AP_ADC_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AP_ADC) , <span class="number">370u32 </span>=&gt; SMART_BATTERY_INFO_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SMART_BATTERY_INFO) , <span class="number">122u32 </span>=&gt; LOG_REQUEST_END_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: LOG_REQUEST_END) , <span class="number">287u32 </span>=&gt; GIMBAL_MANAGER_SET_PITCHYAW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: GIMBAL_MANAGER_SET_PITCHYAW) , <span class="number">395u32 </span>=&gt; COMPONENT_INFORMATION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: COMPONENT_INFORMATION) , <span class="number">36u32 </span>=&gt; SERVO_OUTPUT_RAW_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SERVO_OUTPUT_RAW) , <span class="number">30u32 </span>=&gt; ATTITUDE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ATTITUDE) , <span class="number">290u32 </span>=&gt; ESC_INFO_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: ESC_INFO) , <span class="number">4u32 </span>=&gt; PING_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PING) , <span class="number">322u32 </span>=&gt; PARAM_EXT_VALUE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: PARAM_EXT_VALUE) , <span class="number">286u32 </span>=&gt; AUTOPILOT_STATE_FOR_GIMBAL_DEVICE_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AUTOPILOT_STATE_FOR_GIMBAL_DEVICE) , <span class="number">148u32 </span>=&gt; AUTOPILOT_VERSION_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: AUTOPILOT_VERSION) , <span class="number">62u32 </span>=&gt; NAV_CONTROLLER_OUTPUT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: NAV_CONTROLLER_OUTPUT) , <span class="number">46u32 </span>=&gt; MISSION_ITEM_REACHED_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: MISSION_ITEM_REACHED) , <span class="number">225u32 </span>=&gt; EFI_STATUS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: EFI_STATUS) , <span class="number">151u32 </span>=&gt; SET_MAG_OFFSETS_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SET_MAG_OFFSETS) , <span class="number">250u32 </span>=&gt; DEBUG_VECT_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: DEBUG_VECT) , <span class="number">2u32 </span>=&gt; SYSTEM_TIME_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: SYSTEM_TIME) , <span class="number">6u32 </span>=&gt; CHANGE_OPERATOR_CONTROL_ACK_DATA :: deser (version , payload) . map (<span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL_ACK) , <span class="kw">_ </span>=&gt; { <span class="prelude-val">Err </span>(ParserError :: UnknownMessage { id }) } , } } <span class="kw">fn </span>message_name (&amp; <span class="self">self</span>) -&gt; &amp; <span class="lifetime">&#39;static </span>str { <span class="kw">match </span><span class="self">self </span>{ <span class="self">Self </span>:: GOPRO_GET_REQUEST (..) =&gt; <span class="string">&quot;GOPRO_GET_REQUEST&quot; </span>, <span class="self">Self </span>:: COLLISION (..) =&gt; <span class="string">&quot;COLLISION&quot; </span>, <span class="self">Self </span>:: RC_CHANNELS_OVERRIDE (..) =&gt; <span class="string">&quot;RC_CHANNELS_OVERRIDE&quot; </span>, <span class="self">Self </span>:: SAFETY_ALLOWED_AREA (..) =&gt; <span class="string">&quot;SAFETY_ALLOWED_AREA&quot; </span>, <span class="self">Self </span>:: RC_CHANNELS (..) =&gt; <span class="string">&quot;RC_CHANNELS&quot; </span>, <span class="self">Self </span>:: RANGEFINDER (..) =&gt; <span class="string">&quot;RANGEFINDER&quot; </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_ATTITUDE_STATUS (..) =&gt; <span class="string">&quot;GIMBAL_DEVICE_ATTITUDE_STATUS&quot; </span>, <span class="self">Self </span>:: GLOBAL_POSITION_INT (..) =&gt; <span class="string">&quot;GLOBAL_POSITION_INT&quot; </span>, <span class="self">Self </span>:: PARAM_VALUE (..) =&gt; <span class="string">&quot;PARAM_VALUE&quot; </span>, <span class="self">Self </span>:: EVENT (..) =&gt; <span class="string">&quot;EVENT&quot; </span>, <span class="self">Self </span>:: SCALED_IMU (..) =&gt; <span class="string">&quot;SCALED_IMU&quot; </span>, <span class="self">Self </span>:: BATTERY_STATUS (..) =&gt; <span class="string">&quot;BATTERY_STATUS&quot; </span>, <span class="self">Self </span>:: V2_EXTENSION (..) =&gt; <span class="string">&quot;V2_EXTENSION&quot; </span>, <span class="self">Self </span>:: HIL_STATE (..) =&gt; <span class="string">&quot;HIL_STATE&quot; </span>, <span class="self">Self </span>:: AOA_SSA (..) =&gt; <span class="string">&quot;AOA_SSA&quot; </span>, <span class="self">Self </span>:: REQUEST_EVENT (..) =&gt; <span class="string">&quot;REQUEST_EVENT&quot; </span>, <span class="self">Self </span>:: AIS_VESSEL (..) =&gt; <span class="string">&quot;AIS_VESSEL&quot; </span>, <span class="self">Self </span>:: DEBUG (..) =&gt; <span class="string">&quot;DEBUG&quot; </span>, <span class="self">Self </span>:: SUPPORTED_TUNES (..) =&gt; <span class="string">&quot;SUPPORTED_TUNES&quot; </span>, <span class="self">Self </span>:: DIGICAM_CONFIGURE (..) =&gt; <span class="string">&quot;DIGICAM_CONFIGURE&quot; </span>, <span class="self">Self </span>:: LED_CONTROL (..) =&gt; <span class="string">&quot;LED_CONTROL&quot; </span>, <span class="self">Self </span>:: PARAM_EXT_REQUEST_READ (..) =&gt; <span class="string">&quot;PARAM_EXT_REQUEST_READ&quot; </span>, <span class="self">Self </span>:: AUTH_KEY (..) =&gt; <span class="string">&quot;AUTH_KEY&quot; </span>, <span class="self">Self </span>:: ONBOARD_COMPUTER_STATUS (..) =&gt; <span class="string">&quot;ONBOARD_COMPUTER_STATUS&quot; </span>, <span class="self">Self </span>:: WIFI_CONFIG_AP (..) =&gt; <span class="string">&quot;WIFI_CONFIG_AP&quot; </span>, <span class="self">Self </span>:: WHEEL_DISTANCE (..) =&gt; <span class="string">&quot;WHEEL_DISTANCE&quot; </span>, <span class="self">Self </span>:: NAMED_VALUE_INT (..) =&gt; <span class="string">&quot;NAMED_VALUE_INT&quot; </span>, <span class="self">Self </span>:: PLAY_TUNE (..) =&gt; <span class="string">&quot;PLAY_TUNE&quot; </span>, <span class="self">Self </span>:: PARAM_MAP_RC (..) =&gt; <span class="string">&quot;PARAM_MAP_RC&quot; </span>, <span class="self">Self </span>:: GPS_INJECT_DATA (..) =&gt; <span class="string">&quot;GPS_INJECT_DATA&quot; </span>, <span class="self">Self </span>:: CANFD_FRAME (..) =&gt; <span class="string">&quot;CANFD_FRAME&quot; </span>, <span class="self">Self </span>:: ADAP_TUNING (..) =&gt; <span class="string">&quot;ADAP_TUNING&quot; </span>, <span class="self">Self </span>:: LOG_REQUEST_DATA (..) =&gt; <span class="string">&quot;LOG_REQUEST_DATA&quot; </span>, <span class="self">Self </span>:: PARAM_EXT_ACK (..) =&gt; <span class="string">&quot;PARAM_EXT_ACK&quot; </span>, <span class="self">Self </span>:: VIBRATION (..) =&gt; <span class="string">&quot;VIBRATION&quot; </span>, <span class="self">Self </span>:: EKF_STATUS_REPORT (..) =&gt; <span class="string">&quot;EKF_STATUS_REPORT&quot; </span>, <span class="self">Self </span>:: STORAGE_INFORMATION (..) =&gt; <span class="string">&quot;STORAGE_INFORMATION&quot; </span>, <span class="self">Self </span>:: DEVICE_OP_READ (..) =&gt; <span class="string">&quot;DEVICE_OP_READ&quot; </span>, <span class="self">Self </span>:: OSD_PARAM_SHOW_CONFIG (..) =&gt; <span class="string">&quot;OSD_PARAM_SHOW_CONFIG&quot; </span>, <span class="self">Self </span>:: LOGGING_DATA_ACKED (..) =&gt; <span class="string">&quot;LOGGING_DATA_ACKED&quot; </span>, <span class="self">Self </span>:: HYGROMETER_SENSOR (..) =&gt; <span class="string">&quot;HYGROMETER_SENSOR&quot; </span>, <span class="self">Self </span>:: VFR_HUD (..) =&gt; <span class="string">&quot;VFR_HUD&quot; </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC (..) =&gt; <span class="string">&quot;UAVIONIX_ADSB_OUT_DYNAMIC&quot; </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED (..) =&gt; <span class="string">&quot;LOCAL_POSITION_NED&quot; </span>, <span class="self">Self </span>:: TERRAIN_REQUEST (..) =&gt; <span class="string">&quot;TERRAIN_REQUEST&quot; </span>, <span class="self">Self </span>:: CAMERA_SETTINGS (..) =&gt; <span class="string">&quot;CAMERA_SETTINGS&quot; </span>, <span class="self">Self </span>:: FENCE_POINT (..) =&gt; <span class="string">&quot;FENCE_POINT&quot; </span>, <span class="self">Self </span>:: OPTICAL_FLOW_RAD (..) =&gt; <span class="string">&quot;OPTICAL_FLOW_RAD&quot; </span>, <span class="self">Self </span>:: HIL_STATE_QUATERNION (..) =&gt; <span class="string">&quot;HIL_STATE_QUATERNION&quot; </span>, <span class="self">Self </span>:: SCALED_PRESSURE2 (..) =&gt; <span class="string">&quot;SCALED_PRESSURE2&quot; </span>, <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL (..) =&gt; <span class="string">&quot;CHANGE_OPERATOR_CONTROL&quot; </span>, <span class="self">Self </span>:: COMPASSMOT_STATUS (..) =&gt; <span class="string">&quot;COMPASSMOT_STATUS&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_ARM_STATUS (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_ARM_STATUS&quot; </span>, <span class="self">Self </span>:: LOGGING_ACK (..) =&gt; <span class="string">&quot;LOGGING_ACK&quot; </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_ATTITUDE (..) =&gt; <span class="string">&quot;GIMBAL_MANAGER_SET_ATTITUDE&quot; </span>, <span class="self">Self </span>:: TIME_ESTIMATE_TO_TARGET (..) =&gt; <span class="string">&quot;TIME_ESTIMATE_TO_TARGET&quot; </span>, <span class="self">Self </span>:: SET_MODE (..) =&gt; <span class="string">&quot;SET_MODE&quot; </span>, <span class="self">Self </span>:: RALLY_FETCH_POINT (..) =&gt; <span class="string">&quot;RALLY_FETCH_POINT&quot; </span>, <span class="self">Self </span>:: COMMAND_CANCEL (..) =&gt; <span class="string">&quot;COMMAND_CANCEL&quot; </span>, <span class="self">Self </span>:: REQUEST_DATA_STREAM (..) =&gt; <span class="string">&quot;REQUEST_DATA_STREAM&quot; </span>, <span class="self">Self </span>:: PARAM_REQUEST_LIST (..) =&gt; <span class="string">&quot;PARAM_REQUEST_LIST&quot; </span>, <span class="self">Self </span>:: VISION_POSITION_ESTIMATE (..) =&gt; <span class="string">&quot;VISION_POSITION_ESTIMATE&quot; </span>, <span class="self">Self </span>:: CAMERA_IMAGE_CAPTURED (..) =&gt; <span class="string">&quot;CAMERA_IMAGE_CAPTURED&quot; </span>, <span class="self">Self </span>:: FOLLOW_TARGET (..) =&gt; <span class="string">&quot;FOLLOW_TARGET&quot; </span>, <span class="self">Self </span>:: HEARTBEAT (..) =&gt; <span class="string">&quot;HEARTBEAT&quot; </span>, <span class="self">Self </span>:: DATA64 (..) =&gt; <span class="string">&quot;DATA64&quot; </span>, <span class="self">Self </span>:: HERELINK_VIDEO_STREAM_INFORMATION (..) =&gt; <span class="string">&quot;HERELINK_VIDEO_STREAM_INFORMATION&quot; </span>, <span class="self">Self </span>:: GOPRO_HEARTBEAT (..) =&gt; <span class="string">&quot;GOPRO_HEARTBEAT&quot; </span>, <span class="self">Self </span>:: RC_CHANNELS_SCALED (..) =&gt; <span class="string">&quot;RC_CHANNELS_SCALED&quot; </span>, <span class="self">Self </span>:: MISSION_REQUEST_INT (..) =&gt; <span class="string">&quot;MISSION_REQUEST_INT&quot; </span>, <span class="self">Self </span>:: CAN_FRAME (..) =&gt; <span class="string">&quot;CAN_FRAME&quot; </span>, <span class="self">Self </span>:: HIL_GPS (..) =&gt; <span class="string">&quot;HIL_GPS&quot; </span>, <span class="self">Self </span>:: GENERATOR_STATUS (..) =&gt; <span class="string">&quot;GENERATOR_STATUS&quot; </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_INFORMATION (..) =&gt; <span class="string">&quot;GIMBAL_MANAGER_INFORMATION&quot; </span>, <span class="self">Self </span>:: TERRAIN_CHECK (..) =&gt; <span class="string">&quot;TERRAIN_CHECK&quot; </span>, <span class="self">Self </span>:: BATTERY2 (..) =&gt; <span class="string">&quot;BATTERY2&quot; </span>, <span class="self">Self </span>:: CAMERA_FOV_STATUS (..) =&gt; <span class="string">&quot;CAMERA_FOV_STATUS&quot; </span>, <span class="self">Self </span>:: PARAM_REQUEST_READ (..) =&gt; <span class="string">&quot;PARAM_REQUEST_READ&quot; </span>, <span class="self">Self </span>:: MISSION_WRITE_PARTIAL_LIST (..) =&gt; <span class="string">&quot;MISSION_WRITE_PARTIAL_LIST&quot; </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG (..) =&gt; <span class="string">&quot;UAVIONIX_ADSB_OUT_CFG&quot; </span>, <span class="self">Self </span>:: CAMERA_INFORMATION (..) =&gt; <span class="string">&quot;CAMERA_INFORMATION&quot; </span>, <span class="self">Self </span>:: WATER_DEPTH (..) =&gt; <span class="string">&quot;WATER_DEPTH&quot; </span>, <span class="self">Self </span>:: DATA_STREAM (..) =&gt; <span class="string">&quot;DATA_STREAM&quot; </span>, <span class="self">Self </span>:: COMMAND_LONG (..) =&gt; <span class="string">&quot;COMMAND_LONG&quot; </span>, <span class="self">Self </span>:: SETUP_SIGNING (..) =&gt; <span class="string">&quot;SETUP_SIGNING&quot; </span>, <span class="self">Self </span>:: HIL_CONTROLS (..) =&gt; <span class="string">&quot;HIL_CONTROLS&quot; </span>, <span class="self">Self </span>:: REMOTE_LOG_DATA_BLOCK (..) =&gt; <span class="string">&quot;REMOTE_LOG_DATA_BLOCK&quot; </span>, <span class="self">Self </span>:: HIGHRES_IMU (..) =&gt; <span class="string">&quot;HIGHRES_IMU&quot; </span>, <span class="self">Self </span>:: ORBIT_EXECUTION_STATUS (..) =&gt; <span class="string">&quot;ORBIT_EXECUTION_STATUS&quot; </span>, <span class="self">Self </span>:: SCALED_IMU2 (..) =&gt; <span class="string">&quot;SCALED_IMU2&quot; </span>, <span class="self">Self </span>:: MOUNT_CONFIGURE (..) =&gt; <span class="string">&quot;MOUNT_CONFIGURE&quot; </span>, <span class="self">Self </span>:: MANUAL_CONTROL (..) =&gt; <span class="string">&quot;MANUAL_CONTROL&quot; </span>, <span class="self">Self </span>:: SAFETY_SET_ALLOWED_AREA (..) =&gt; <span class="string">&quot;SAFETY_SET_ALLOWED_AREA&quot; </span>, <span class="self">Self </span>:: HWSTATUS (..) =&gt; <span class="string">&quot;HWSTATUS&quot; </span>, <span class="self">Self </span>:: AUTOPILOT_VERSION_REQUEST (..) =&gt; <span class="string">&quot;AUTOPILOT_VERSION_REQUEST&quot; </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT (..) =&gt; <span class="string">&quot;UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT&quot; </span>, <span class="self">Self </span>:: LOG_REQUEST_LIST (..) =&gt; <span class="string">&quot;LOG_REQUEST_LIST&quot; </span>, <span class="self">Self </span>:: GPS2_RTK (..) =&gt; <span class="string">&quot;GPS2_RTK&quot; </span>, <span class="self">Self </span>:: WIND_COV (..) =&gt; <span class="string">&quot;WIND_COV&quot; </span>, <span class="self">Self </span>:: DEVICE_OP_READ_REPLY (..) =&gt; <span class="string">&quot;DEVICE_OP_READ_REPLY&quot; </span>, <span class="self">Self </span>:: DISTANCE_SENSOR (..) =&gt; <span class="string">&quot;DISTANCE_SENSOR&quot; </span>, <span class="self">Self </span>:: SERIAL_CONTROL (..) =&gt; <span class="string">&quot;SERIAL_CONTROL&quot; </span>, <span class="self">Self </span>:: LOG_ERASE (..) =&gt; <span class="string">&quot;LOG_ERASE&quot; </span>, <span class="self">Self </span>:: OPTICAL_FLOW (..) =&gt; <span class="string">&quot;OPTICAL_FLOW&quot; </span>, <span class="self">Self </span>:: ENCAPSULATED_DATA (..) =&gt; <span class="string">&quot;ENCAPSULATED_DATA&quot; </span>, <span class="self">Self </span>:: LOG_ENTRY (..) =&gt; <span class="string">&quot;LOG_ENTRY&quot; </span>, <span class="self">Self </span>:: HIGH_LATENCY2 (..) =&gt; <span class="string">&quot;HIGH_LATENCY2&quot; </span>, <span class="self">Self </span>:: ISBD_LINK_STATUS (..) =&gt; <span class="string">&quot;ISBD_LINK_STATUS&quot; </span>, <span class="self">Self </span>:: RESPONSE_EVENT_ERROR (..) =&gt; <span class="string">&quot;RESPONSE_EVENT_ERROR&quot; </span>, <span class="self">Self </span>:: ESTIMATOR_STATUS (..) =&gt; <span class="string">&quot;ESTIMATOR_STATUS&quot; </span>, <span class="self">Self </span>:: MCU_STATUS (..) =&gt; <span class="string">&quot;MCU_STATUS&quot; </span>, <span class="self">Self </span>:: RC_CHANNELS_RAW (..) =&gt; <span class="string">&quot;RC_CHANNELS_RAW&quot; </span>, <span class="self">Self </span>:: DATA_TRANSMISSION_HANDSHAKE (..) =&gt; <span class="string">&quot;DATA_TRANSMISSION_HANDSHAKE&quot; </span>, <span class="self">Self </span>:: CAMERA_CAPTURE_STATUS (..) =&gt; <span class="string">&quot;CAMERA_CAPTURE_STATUS&quot; </span>, <span class="self">Self </span>:: RAW_RPM (..) =&gt; <span class="string">&quot;RAW_RPM&quot; </span>, <span class="self">Self </span>:: GPS_RTCM_DATA (..) =&gt; <span class="string">&quot;GPS_RTCM_DATA&quot; </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED_COV (..) =&gt; <span class="string">&quot;LOCAL_POSITION_NED_COV&quot; </span>, <span class="self">Self </span>:: GOPRO_GET_RESPONSE (..) =&gt; <span class="string">&quot;GOPRO_GET_RESPONSE&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SELF_ID (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_SELF_ID&quot; </span>, <span class="self">Self </span>:: ESC_TELEMETRY_9_TO_12 (..) =&gt; <span class="string">&quot;ESC_TELEMETRY_9_TO_12&quot; </span>, <span class="self">Self </span>:: POWER_STATUS (..) =&gt; <span class="string">&quot;POWER_STATUS&quot; </span>, <span class="self">Self </span>:: FILE_TRANSFER_PROTOCOL (..) =&gt; <span class="string">&quot;FILE_TRANSFER_PROTOCOL&quot; </span>, <span class="self">Self </span>:: GPS_RTK (..) =&gt; <span class="string">&quot;GPS_RTK&quot; </span>, <span class="self">Self </span>:: MISSION_CLEAR_ALL (..) =&gt; <span class="string">&quot;MISSION_CLEAR_ALL&quot; </span>, <span class="self">Self </span>:: MISSION_REQUEST (..) =&gt; <span class="string">&quot;MISSION_REQUEST&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_AUTHENTICATION (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_AUTHENTICATION&quot; </span>, <span class="self">Self </span>:: FENCE_FETCH_POINT (..) =&gt; <span class="string">&quot;FENCE_FETCH_POINT&quot; </span>, <span class="self">Self </span>:: GOPRO_SET_REQUEST (..) =&gt; <span class="string">&quot;GOPRO_SET_REQUEST&quot; </span>, <span class="self">Self </span>:: HIL_ACTUATOR_CONTROLS (..) =&gt; <span class="string">&quot;HIL_ACTUATOR_CONTROLS&quot; </span>, <span class="self">Self </span>:: OBSTACLE_DISTANCE_3D (..) =&gt; <span class="string">&quot;OBSTACLE_DISTANCE_3D&quot; </span>, <span class="self">Self </span>:: ATT_POS_MOCAP (..) =&gt; <span class="string">&quot;ATT_POS_MOCAP&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM_UPDATE (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_SYSTEM_UPDATE&quot; </span>, <span class="self">Self </span>:: SET_POSITION_TARGET_GLOBAL_INT (..) =&gt; <span class="string">&quot;SET_POSITION_TARGET_GLOBAL_INT&quot; </span>, <span class="self">Self </span>:: RESOURCE_REQUEST (..) =&gt; <span class="string">&quot;RESOURCE_REQUEST&quot; </span>, <span class="self">Self </span>:: MAG_CAL_REPORT (..) =&gt; <span class="string">&quot;MAG_CAL_REPORT&quot; </span>, <span class="self">Self </span>:: HIL_RC_INPUTS_RAW (..) =&gt; <span class="string">&quot;HIL_RC_INPUTS_RAW&quot; </span>, <span class="self">Self </span>:: MISSION_REQUEST_PARTIAL_LIST (..) =&gt; <span class="string">&quot;MISSION_REQUEST_PARTIAL_LIST&quot; </span>, <span class="self">Self </span>:: HOME_POSITION (..) =&gt; <span class="string">&quot;HOME_POSITION&quot; </span>, <span class="self">Self </span>:: RAW_PRESSURE (..) =&gt; <span class="string">&quot;RAW_PRESSURE&quot; </span>, <span class="self">Self </span>:: DIGICAM_CONTROL (..) =&gt; <span class="string">&quot;DIGICAM_CONTROL&quot; </span>, <span class="self">Self </span>:: MISSION_CURRENT (..) =&gt; <span class="string">&quot;MISSION_CURRENT&quot; </span>, <span class="self">Self </span>:: ESC_TELEMETRY_1_TO_4 (..) =&gt; <span class="string">&quot;ESC_TELEMETRY_1_TO_4&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_LOCATION (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_LOCATION&quot; </span>, <span class="self">Self </span>:: MAG_CAL_PROGRESS (..) =&gt; <span class="string">&quot;MAG_CAL_PROGRESS&quot; </span>, <span class="self">Self </span>:: COMPONENT_METADATA (..) =&gt; <span class="string">&quot;COMPONENT_METADATA&quot; </span>, <span class="self">Self </span>:: UTM_GLOBAL_POSITION (..) =&gt; <span class="string">&quot;UTM_GLOBAL_POSITION&quot; </span>, <span class="self">Self </span>:: POSITION_TARGET_LOCAL_NED (..) =&gt; <span class="string">&quot;POSITION_TARGET_LOCAL_NED&quot; </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_SET_ATTITUDE (..) =&gt; <span class="string">&quot;GIMBAL_DEVICE_SET_ATTITUDE&quot; </span>, <span class="self">Self </span>:: VISION_POSITION_DELTA (..) =&gt; <span class="string">&quot;VISION_POSITION_DELTA&quot; </span>, <span class="self">Self </span>:: HIGH_LATENCY (..) =&gt; <span class="string">&quot;HIGH_LATENCY&quot; </span>, <span class="self">Self </span>:: TERRAIN_REPORT (..) =&gt; <span class="string">&quot;TERRAIN_REPORT&quot; </span>, <span class="self">Self </span>:: MISSION_ITEM_INT (..) =&gt; <span class="string">&quot;MISSION_ITEM_INT&quot; </span>, <span class="self">Self </span>:: DEEPSTALL (..) =&gt; <span class="string">&quot;DEEPSTALL&quot; </span>, <span class="self">Self </span>:: CAMERA_TRIGGER (..) =&gt; <span class="string">&quot;CAMERA_TRIGGER&quot; </span>, <span class="self">Self </span>:: MEMORY_VECT (..) =&gt; <span class="string">&quot;MEMORY_VECT&quot; </span>, <span class="self">Self </span>:: LIMITS_STATUS (..) =&gt; <span class="string">&quot;LIMITS_STATUS&quot; </span>, <span class="self">Self </span>:: OSD_PARAM_SHOW_CONFIG_REPLY (..) =&gt; <span class="string">&quot;OSD_PARAM_SHOW_CONFIG_REPLY&quot; </span>, <span class="self">Self </span>:: REMOTE_LOG_BLOCK_STATUS (..) =&gt; <span class="string">&quot;REMOTE_LOG_BLOCK_STATUS&quot; </span>, <span class="self">Self </span>:: DEVICE_OP_WRITE_REPLY (..) =&gt; <span class="string">&quot;DEVICE_OP_WRITE_REPLY&quot; </span>, <span class="self">Self </span>:: LANDING_TARGET (..) =&gt; <span class="string">&quot;LANDING_TARGET&quot; </span>, <span class="self">Self </span>:: GIMBAL_REPORT (..) =&gt; <span class="string">&quot;GIMBAL_REPORT&quot; </span>, <span class="self">Self </span>:: CAMERA_TRACKING_IMAGE_STATUS (..) =&gt; <span class="string">&quot;CAMERA_TRACKING_IMAGE_STATUS&quot; </span>, <span class="self">Self </span>:: ATTITUDE_QUATERNION_COV (..) =&gt; <span class="string">&quot;ATTITUDE_QUATERNION_COV&quot; </span>, <span class="self">Self </span>:: RALLY_POINT (..) =&gt; <span class="string">&quot;RALLY_POINT&quot; </span>, <span class="self">Self </span>:: SCALED_PRESSURE3 (..) =&gt; <span class="string">&quot;SCALED_PRESSURE3&quot; </span>, <span class="self">Self </span>:: SIM_STATE (..) =&gt; <span class="string">&quot;SIM_STATE&quot; </span>, <span class="self">Self </span>:: ACTUATOR_OUTPUT_STATUS (..) =&gt; <span class="string">&quot;ACTUATOR_OUTPUT_STATUS&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_MESSAGE_PACK (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_MESSAGE_PACK&quot; </span>, <span class="self">Self </span>:: VISION_SPEED_ESTIMATE (..) =&gt; <span class="string">&quot;VISION_SPEED_ESTIMATE&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_BASIC_ID (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_BASIC_ID&quot; </span>, <span class="self">Self </span>:: TUNNEL (..) =&gt; <span class="string">&quot;TUNNEL&quot; </span>, <span class="self">Self </span>:: POSITION_TARGET_GLOBAL_INT (..) =&gt; <span class="string">&quot;POSITION_TARGET_GLOBAL_INT&quot; </span>, <span class="self">Self </span>:: SENSOR_OFFSETS (..) =&gt; <span class="string">&quot;SENSOR_OFFSETS&quot; </span>, <span class="self">Self </span>:: UAVCAN_NODE_INFO (..) =&gt; <span class="string">&quot;UAVCAN_NODE_INFO&quot; </span>, <span class="self">Self </span>:: FLIGHT_INFORMATION (..) =&gt; <span class="string">&quot;FLIGHT_INFORMATION&quot; </span>, <span class="self">Self </span>:: RADIO (..) =&gt; <span class="string">&quot;RADIO&quot; </span>, <span class="self">Self </span>:: DATA32 (..) =&gt; <span class="string">&quot;DATA32&quot; </span>, <span class="self">Self </span>:: CUBEPILOT_RAW_RC (..) =&gt; <span class="string">&quot;CUBEPILOT_RAW_RC&quot; </span>, <span class="self">Self </span>:: SCALED_IMU3 (..) =&gt; <span class="string">&quot;SCALED_IMU3&quot; </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_MANUAL_CONTROL (..) =&gt; <span class="string">&quot;GIMBAL_MANAGER_SET_MANUAL_CONTROL&quot; </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_INFORMATION (..) =&gt; <span class="string">&quot;GIMBAL_DEVICE_INFORMATION&quot; </span>, <span class="self">Self </span>:: TERRAIN_DATA (..) =&gt; <span class="string">&quot;TERRAIN_DATA&quot; </span>, <span class="self">Self </span>:: ACTUATOR_CONTROL_TARGET (..) =&gt; <span class="string">&quot;ACTUATOR_CONTROL_TARGET&quot; </span>, <span class="self">Self </span>:: LINK_NODE_STATUS (..) =&gt; <span class="string">&quot;LINK_NODE_STATUS&quot; </span>, <span class="self">Self </span>:: ESC_STATUS (..) =&gt; <span class="string">&quot;ESC_STATUS&quot; </span>, <span class="self">Self </span>:: STATUSTEXT (..) =&gt; <span class="string">&quot;STATUSTEXT&quot; </span>, <span class="self">Self </span>:: SET_ATTITUDE_TARGET (..) =&gt; <span class="string">&quot;SET_ATTITUDE_TARGET&quot; </span>, <span class="self">Self </span>:: ALTITUDE (..) =&gt; <span class="string">&quot;ALTITUDE&quot; </span>, <span class="self">Self </span>:: GPS_GLOBAL_ORIGIN (..) =&gt; <span class="string">&quot;GPS_GLOBAL_ORIGIN&quot; </span>, <span class="self">Self </span>:: VIDEO_STREAM_STATUS (..) =&gt; <span class="string">&quot;VIDEO_STREAM_STATUS&quot; </span>, <span class="self">Self </span>:: CONTROL_SYSTEM_STATE (..) =&gt; <span class="string">&quot;CONTROL_SYSTEM_STATE&quot; </span>, <span class="self">Self </span>:: CUBEPILOT_FIRMWARE_UPDATE_START (..) =&gt; <span class="string">&quot;CUBEPILOT_FIRMWARE_UPDATE_START&quot; </span>, <span class="self">Self </span>:: MISSION_REQUEST_LIST (..) =&gt; <span class="string">&quot;MISSION_REQUEST_LIST&quot; </span>, <span class="self">Self </span>:: AHRS3 (..) =&gt; <span class="string">&quot;AHRS3&quot; </span>, <span class="self">Self </span>:: DEVICE_OP_WRITE (..) =&gt; <span class="string">&quot;DEVICE_OP_WRITE&quot; </span>, <span class="self">Self </span>:: ESC_TELEMETRY_5_TO_8 (..) =&gt; <span class="string">&quot;ESC_TELEMETRY_5_TO_8&quot; </span>, <span class="self">Self </span>:: MANUAL_SETPOINT (..) =&gt; <span class="string">&quot;MANUAL_SETPOINT&quot; </span>, <span class="self">Self </span>:: UAVCAN_NODE_STATUS (..) =&gt; <span class="string">&quot;UAVCAN_NODE_STATUS&quot; </span>, <span class="self">Self </span>:: PARAM_EXT_SET (..) =&gt; <span class="string">&quot;PARAM_EXT_SET&quot; </span>, <span class="self">Self </span>:: MOUNT_STATUS (..) =&gt; <span class="string">&quot;MOUNT_STATUS&quot; </span>, <span class="self">Self </span>:: AIRSPEED_AUTOCAL (..) =&gt; <span class="string">&quot;AIRSPEED_AUTOCAL&quot; </span>, <span class="self">Self </span>:: SCALED_PRESSURE (..) =&gt; <span class="string">&quot;SCALED_PRESSURE&quot; </span>, <span class="self">Self </span>:: CELLULAR_STATUS (..) =&gt; <span class="string">&quot;CELLULAR_STATUS&quot; </span>, <span class="self">Self </span>:: SYS_STATUS (..) =&gt; <span class="string">&quot;SYS_STATUS&quot; </span>, <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_BEZIER (..) =&gt; <span class="string">&quot;TRAJECTORY_REPRESENTATION_BEZIER&quot; </span>, <span class="self">Self </span>:: TIMESYNC (..) =&gt; <span class="string">&quot;TIMESYNC&quot; </span>, <span class="self">Self </span>:: MOUNT_CONTROL (..) =&gt; <span class="string">&quot;MOUNT_CONTROL&quot; </span>, <span class="self">Self </span>:: CAMERA_FEEDBACK (..) =&gt; <span class="string">&quot;CAMERA_FEEDBACK&quot; </span>, <span class="self">Self </span>:: BUTTON_CHANGE (..) =&gt; <span class="string">&quot;BUTTON_CHANGE&quot; </span>, <span class="self">Self </span>:: CAMERA_STATUS (..) =&gt; <span class="string">&quot;CAMERA_STATUS&quot; </span>, <span class="self">Self </span>:: SET_POSITION_TARGET_LOCAL_NED (..) =&gt; <span class="string">&quot;SET_POSITION_TARGET_LOCAL_NED&quot; </span>, <span class="self">Self </span>:: ODOMETRY (..) =&gt; <span class="string">&quot;ODOMETRY&quot; </span>, <span class="self">Self </span>:: GPS_RAW_INT (..) =&gt; <span class="string">&quot;GPS_RAW_INT&quot; </span>, <span class="self">Self </span>:: GIMBAL_TORQUE_CMD_REPORT (..) =&gt; <span class="string">&quot;GIMBAL_TORQUE_CMD_REPORT&quot; </span>, <span class="self">Self </span>:: OSD_PARAM_CONFIG (..) =&gt; <span class="string">&quot;OSD_PARAM_CONFIG&quot; </span>, <span class="self">Self </span>:: DATA16 (..) =&gt; <span class="string">&quot;DATA16&quot; </span>, <span class="self">Self </span>:: PID_TUNING (..) =&gt; <span class="string">&quot;PID_TUNING&quot; </span>, <span class="self">Self </span>:: OBSTACLE_DISTANCE (..) =&gt; <span class="string">&quot;OBSTACLE_DISTANCE&quot; </span>, <span class="self">Self </span>:: COMMAND_INT (..) =&gt; <span class="string">&quot;COMMAND_INT&quot; </span>, <span class="self">Self </span>:: COMMAND_ACK (..) =&gt; <span class="string">&quot;COMMAND_ACK&quot; </span>, <span class="self">Self </span>:: ICAROUS_HEARTBEAT (..) =&gt; <span class="string">&quot;ICAROUS_HEARTBEAT&quot; </span>, <span class="self">Self </span>:: MISSION_SET_CURRENT (..) =&gt; <span class="string">&quot;MISSION_SET_CURRENT&quot; </span>, <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_WAYPOINTS (..) =&gt; <span class="string">&quot;TRAJECTORY_REPRESENTATION_WAYPOINTS&quot; </span>, <span class="self">Self </span>:: WINCH_STATUS (..) =&gt; <span class="string">&quot;WINCH_STATUS&quot; </span>, <span class="self">Self </span>:: PARAM_EXT_REQUEST_LIST (..) =&gt; <span class="string">&quot;PARAM_EXT_REQUEST_LIST&quot; </span>, <span class="self">Self </span>:: ICAROUS_KINEMATIC_BANDS (..) =&gt; <span class="string">&quot;ICAROUS_KINEMATIC_BANDS&quot; </span>, <span class="self">Self </span>:: CUBEPILOT_FIRMWARE_UPDATE_RESP (..) =&gt; <span class="string">&quot;CUBEPILOT_FIRMWARE_UPDATE_RESP&quot; </span>, <span class="self">Self </span>:: AHRS (..) =&gt; <span class="string">&quot;AHRS&quot; </span>, <span class="self">Self </span>:: CAN_FILTER_MODIFY (..) =&gt; <span class="string">&quot;CAN_FILTER_MODIFY&quot; </span>, <span class="self">Self </span>:: SET_HOME_POSITION (..) =&gt; <span class="string">&quot;SET_HOME_POSITION&quot; </span>, <span class="self">Self </span>:: GPS_STATUS (..) =&gt; <span class="string">&quot;GPS_STATUS&quot; </span>, <span class="self">Self </span>:: RAW_IMU (..) =&gt; <span class="string">&quot;RAW_IMU&quot; </span>, <span class="self">Self </span>:: GOPRO_SET_RESPONSE (..) =&gt; <span class="string">&quot;GOPRO_SET_RESPONSE&quot; </span>, <span class="self">Self </span>:: LOGGING_DATA (..) =&gt; <span class="string">&quot;LOGGING_DATA&quot; </span>, <span class="self">Self </span>:: SIMSTATE (..) =&gt; <span class="string">&quot;SIMSTATE&quot; </span>, <span class="self">Self </span>:: ATTITUDE_QUATERNION (..) =&gt; <span class="string">&quot;ATTITUDE_QUATERNION&quot; </span>, <span class="self">Self </span>:: HIL_OPTICAL_FLOW (..) =&gt; <span class="string">&quot;HIL_OPTICAL_FLOW&quot; </span>, <span class="self">Self </span>:: RPM (..) =&gt; <span class="string">&quot;RPM&quot; </span>, <span class="self">Self </span>:: OSD_PARAM_CONFIG_REPLY (..) =&gt; <span class="string">&quot;OSD_PARAM_CONFIG_REPLY&quot; </span>, <span class="self">Self </span>:: PROTOCOL_VERSION (..) =&gt; <span class="string">&quot;PROTOCOL_VERSION&quot; </span>, <span class="self">Self </span>:: ATTITUDE_TARGET (..) =&gt; <span class="string">&quot;ATTITUDE_TARGET&quot; </span>, <span class="self">Self </span>:: PARAM_SET (..) =&gt; <span class="string">&quot;PARAM_SET&quot; </span>, <span class="self">Self </span>:: AHRS2 (..) =&gt; <span class="string">&quot;AHRS2&quot; </span>, <span class="self">Self </span>:: WIND (..) =&gt; <span class="string">&quot;WIND&quot; </span>, <span class="self">Self </span>:: VICON_POSITION_ESTIMATE (..) =&gt; <span class="string">&quot;VICON_POSITION_ESTIMATE&quot; </span>, <span class="self">Self </span>:: MISSION_COUNT (..) =&gt; <span class="string">&quot;MISSION_COUNT&quot; </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET (..) =&gt; <span class="string">&quot;LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET&quot; </span>, <span class="self">Self </span>:: NAMED_VALUE_FLOAT (..) =&gt; <span class="string">&quot;NAMED_VALUE_FLOAT&quot; </span>, <span class="self">Self </span>:: PLAY_TUNE_V2 (..) =&gt; <span class="string">&quot;PLAY_TUNE_V2&quot; </span>, <span class="self">Self </span>:: MEMINFO (..) =&gt; <span class="string">&quot;MEMINFO&quot; </span>, <span class="self">Self </span>:: DATA96 (..) =&gt; <span class="string">&quot;DATA96&quot; </span>, <span class="self">Self </span>:: GIMBAL_CONTROL (..) =&gt; <span class="string">&quot;GIMBAL_CONTROL&quot; </span>, <span class="self">Self </span>:: LOG_DATA (..) =&gt; <span class="string">&quot;LOG_DATA&quot; </span>, <span class="self">Self </span>:: SET_GPS_GLOBAL_ORIGIN (..) =&gt; <span class="string">&quot;SET_GPS_GLOBAL_ORIGIN&quot; </span>, <span class="self">Self </span>:: MOUNT_ORIENTATION (..) =&gt; <span class="string">&quot;MOUNT_ORIENTATION&quot; </span>, <span class="self">Self </span>:: GPS2_RAW (..) =&gt; <span class="string">&quot;GPS2_RAW&quot; </span>, <span class="self">Self </span>:: GLOBAL_VISION_POSITION_ESTIMATE (..) =&gt; <span class="string">&quot;GLOBAL_VISION_POSITION_ESTIMATE&quot; </span>, <span class="self">Self </span>:: HERELINK_TELEM (..) =&gt; <span class="string">&quot;HERELINK_TELEM&quot; </span>, <span class="self">Self </span>:: CAMERA_TRACKING_GEO_STATUS (..) =&gt; <span class="string">&quot;CAMERA_TRACKING_GEO_STATUS&quot; </span>, <span class="self">Self </span>:: CURRENT_EVENT_SEQUENCE (..) =&gt; <span class="string">&quot;CURRENT_EVENT_SEQUENCE&quot; </span>, <span class="self">Self </span>:: MESSAGE_INTERVAL (..) =&gt; <span class="string">&quot;MESSAGE_INTERVAL&quot; </span>, <span class="self">Self </span>:: MISSION_ITEM (..) =&gt; <span class="string">&quot;MISSION_ITEM&quot; </span>, <span class="self">Self </span>:: RADIO_STATUS (..) =&gt; <span class="string">&quot;RADIO_STATUS&quot; </span>, <span class="self">Self </span>:: FENCE_STATUS (..) =&gt; <span class="string">&quot;FENCE_STATUS&quot; </span>, <span class="self">Self </span>:: HIL_SENSOR (..) =&gt; <span class="string">&quot;HIL_SENSOR&quot; </span>, <span class="self">Self </span>:: MISSION_ACK (..) =&gt; <span class="string">&quot;MISSION_ACK&quot; </span>, <span class="self">Self </span>:: GLOBAL_POSITION_INT_COV (..) =&gt; <span class="string">&quot;GLOBAL_POSITION_INT_COV&quot; </span>, <span class="self">Self </span>:: CELLULAR_CONFIG (..) =&gt; <span class="string">&quot;CELLULAR_CONFIG&quot; </span>, <span class="self">Self </span>:: VIDEO_STREAM_INFORMATION (..) =&gt; <span class="string">&quot;VIDEO_STREAM_INFORMATION&quot; </span>, <span class="self">Self </span>:: ADSB_VEHICLE (..) =&gt; <span class="string">&quot;ADSB_VEHICLE&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_SYSTEM&quot; </span>, <span class="self">Self </span>:: GPS_INPUT (..) =&gt; <span class="string">&quot;GPS_INPUT&quot; </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_STATUS (..) =&gt; <span class="string">&quot;GIMBAL_MANAGER_STATUS&quot; </span>, <span class="self">Self </span>:: EXTENDED_SYS_STATE (..) =&gt; <span class="string">&quot;EXTENDED_SYS_STATE&quot; </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_OPERATOR_ID (..) =&gt; <span class="string">&quot;OPEN_DRONE_ID_OPERATOR_ID&quot; </span>, <span class="self">Self </span>:: SET_ACTUATOR_CONTROL_TARGET (..) =&gt; <span class="string">&quot;SET_ACTUATOR_CONTROL_TARGET&quot; </span>, <span class="self">Self </span>:: DEBUG_FLOAT_ARRAY (..) =&gt; <span class="string">&quot;DEBUG_FLOAT_ARRAY&quot; </span>, <span class="self">Self </span>:: AP_ADC (..) =&gt; <span class="string">&quot;AP_ADC&quot; </span>, <span class="self">Self </span>:: SMART_BATTERY_INFO (..) =&gt; <span class="string">&quot;SMART_BATTERY_INFO&quot; </span>, <span class="self">Self </span>:: LOG_REQUEST_END (..) =&gt; <span class="string">&quot;LOG_REQUEST_END&quot; </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_PITCHYAW (..) =&gt; <span class="string">&quot;GIMBAL_MANAGER_SET_PITCHYAW&quot; </span>, <span class="self">Self </span>:: COMPONENT_INFORMATION (..) =&gt; <span class="string">&quot;COMPONENT_INFORMATION&quot; </span>, <span class="self">Self </span>:: SERVO_OUTPUT_RAW (..) =&gt; <span class="string">&quot;SERVO_OUTPUT_RAW&quot; </span>, <span class="self">Self </span>:: ATTITUDE (..) =&gt; <span class="string">&quot;ATTITUDE&quot; </span>, <span class="self">Self </span>:: ESC_INFO (..) =&gt; <span class="string">&quot;ESC_INFO&quot; </span>, <span class="self">Self </span>:: PING (..) =&gt; <span class="string">&quot;PING&quot; </span>, <span class="self">Self </span>:: PARAM_EXT_VALUE (..) =&gt; <span class="string">&quot;PARAM_EXT_VALUE&quot; </span>, <span class="self">Self </span>:: AUTOPILOT_STATE_FOR_GIMBAL_DEVICE (..) =&gt; <span class="string">&quot;AUTOPILOT_STATE_FOR_GIMBAL_DEVICE&quot; </span>, <span class="self">Self </span>:: AUTOPILOT_VERSION (..) =&gt; <span class="string">&quot;AUTOPILOT_VERSION&quot; </span>, <span class="self">Self </span>:: NAV_CONTROLLER_OUTPUT (..) =&gt; <span class="string">&quot;NAV_CONTROLLER_OUTPUT&quot; </span>, <span class="self">Self </span>:: MISSION_ITEM_REACHED (..) =&gt; <span class="string">&quot;MISSION_ITEM_REACHED&quot; </span>, <span class="self">Self </span>:: EFI_STATUS (..) =&gt; <span class="string">&quot;EFI_STATUS&quot; </span>, <span class="self">Self </span>:: SET_MAG_OFFSETS (..) =&gt; <span class="string">&quot;SET_MAG_OFFSETS&quot; </span>, <span class="self">Self </span>:: DEBUG_VECT (..) =&gt; <span class="string">&quot;DEBUG_VECT&quot; </span>, <span class="self">Self </span>:: SYSTEM_TIME (..) =&gt; <span class="string">&quot;SYSTEM_TIME&quot; </span>, <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL_ACK (..) =&gt; <span class="string">&quot;CHANGE_OPERATOR_CONTROL_ACK&quot; </span>, } } <span class="kw">fn </span>message_id (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">match </span><span class="self">self </span>{ <span class="self">Self </span>:: GOPRO_GET_REQUEST (..) =&gt; <span class="number">216u32 </span>, <span class="self">Self </span>:: COLLISION (..) =&gt; <span class="number">247u32 </span>, <span class="self">Self </span>:: RC_CHANNELS_OVERRIDE (..) =&gt; <span class="number">70u32 </span>, <span class="self">Self </span>:: SAFETY_ALLOWED_AREA (..) =&gt; <span class="number">55u32 </span>, <span class="self">Self </span>:: RC_CHANNELS (..) =&gt; <span class="number">65u32 </span>, <span class="self">Self </span>:: RANGEFINDER (..) =&gt; <span class="number">173u32 </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_ATTITUDE_STATUS (..) =&gt; <span class="number">285u32 </span>, <span class="self">Self </span>:: GLOBAL_POSITION_INT (..) =&gt; <span class="number">33u32 </span>, <span class="self">Self </span>:: PARAM_VALUE (..) =&gt; <span class="number">22u32 </span>, <span class="self">Self </span>:: EVENT (..) =&gt; <span class="number">410u32 </span>, <span class="self">Self </span>:: SCALED_IMU (..) =&gt; <span class="number">26u32 </span>, <span class="self">Self </span>:: BATTERY_STATUS (..) =&gt; <span class="number">147u32 </span>, <span class="self">Self </span>:: V2_EXTENSION (..) =&gt; <span class="number">248u32 </span>, <span class="self">Self </span>:: HIL_STATE (..) =&gt; <span class="number">90u32 </span>, <span class="self">Self </span>:: AOA_SSA (..) =&gt; <span class="number">11020u32 </span>, <span class="self">Self </span>:: REQUEST_EVENT (..) =&gt; <span class="number">412u32 </span>, <span class="self">Self </span>:: AIS_VESSEL (..) =&gt; <span class="number">301u32 </span>, <span class="self">Self </span>:: DEBUG (..) =&gt; <span class="number">254u32 </span>, <span class="self">Self </span>:: SUPPORTED_TUNES (..) =&gt; <span class="number">401u32 </span>, <span class="self">Self </span>:: DIGICAM_CONFIGURE (..) =&gt; <span class="number">154u32 </span>, <span class="self">Self </span>:: LED_CONTROL (..) =&gt; <span class="number">186u32 </span>, <span class="self">Self </span>:: PARAM_EXT_REQUEST_READ (..) =&gt; <span class="number">320u32 </span>, <span class="self">Self </span>:: AUTH_KEY (..) =&gt; <span class="number">7u32 </span>, <span class="self">Self </span>:: ONBOARD_COMPUTER_STATUS (..) =&gt; <span class="number">390u32 </span>, <span class="self">Self </span>:: WIFI_CONFIG_AP (..) =&gt; <span class="number">299u32 </span>, <span class="self">Self </span>:: WHEEL_DISTANCE (..) =&gt; <span class="number">9000u32 </span>, <span class="self">Self </span>:: NAMED_VALUE_INT (..) =&gt; <span class="number">252u32 </span>, <span class="self">Self </span>:: PLAY_TUNE (..) =&gt; <span class="number">258u32 </span>, <span class="self">Self </span>:: PARAM_MAP_RC (..) =&gt; <span class="number">50u32 </span>, <span class="self">Self </span>:: GPS_INJECT_DATA (..) =&gt; <span class="number">123u32 </span>, <span class="self">Self </span>:: CANFD_FRAME (..) =&gt; <span class="number">387u32 </span>, <span class="self">Self </span>:: ADAP_TUNING (..) =&gt; <span class="number">11010u32 </span>, <span class="self">Self </span>:: LOG_REQUEST_DATA (..) =&gt; <span class="number">119u32 </span>, <span class="self">Self </span>:: PARAM_EXT_ACK (..) =&gt; <span class="number">324u32 </span>, <span class="self">Self </span>:: VIBRATION (..) =&gt; <span class="number">241u32 </span>, <span class="self">Self </span>:: EKF_STATUS_REPORT (..) =&gt; <span class="number">193u32 </span>, <span class="self">Self </span>:: STORAGE_INFORMATION (..) =&gt; <span class="number">261u32 </span>, <span class="self">Self </span>:: DEVICE_OP_READ (..) =&gt; <span class="number">11000u32 </span>, <span class="self">Self </span>:: OSD_PARAM_SHOW_CONFIG (..) =&gt; <span class="number">11035u32 </span>, <span class="self">Self </span>:: LOGGING_DATA_ACKED (..) =&gt; <span class="number">267u32 </span>, <span class="self">Self </span>:: HYGROMETER_SENSOR (..) =&gt; <span class="number">12920u32 </span>, <span class="self">Self </span>:: VFR_HUD (..) =&gt; <span class="number">74u32 </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC (..) =&gt; <span class="number">10002u32 </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED (..) =&gt; <span class="number">32u32 </span>, <span class="self">Self </span>:: TERRAIN_REQUEST (..) =&gt; <span class="number">133u32 </span>, <span class="self">Self </span>:: CAMERA_SETTINGS (..) =&gt; <span class="number">260u32 </span>, <span class="self">Self </span>:: FENCE_POINT (..) =&gt; <span class="number">160u32 </span>, <span class="self">Self </span>:: OPTICAL_FLOW_RAD (..) =&gt; <span class="number">106u32 </span>, <span class="self">Self </span>:: HIL_STATE_QUATERNION (..) =&gt; <span class="number">115u32 </span>, <span class="self">Self </span>:: SCALED_PRESSURE2 (..) =&gt; <span class="number">137u32 </span>, <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL (..) =&gt; <span class="number">5u32 </span>, <span class="self">Self </span>:: COMPASSMOT_STATUS (..) =&gt; <span class="number">177u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_ARM_STATUS (..) =&gt; <span class="number">12918u32 </span>, <span class="self">Self </span>:: LOGGING_ACK (..) =&gt; <span class="number">268u32 </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_ATTITUDE (..) =&gt; <span class="number">282u32 </span>, <span class="self">Self </span>:: TIME_ESTIMATE_TO_TARGET (..) =&gt; <span class="number">380u32 </span>, <span class="self">Self </span>:: SET_MODE (..) =&gt; <span class="number">11u32 </span>, <span class="self">Self </span>:: RALLY_FETCH_POINT (..) =&gt; <span class="number">176u32 </span>, <span class="self">Self </span>:: COMMAND_CANCEL (..) =&gt; <span class="number">80u32 </span>, <span class="self">Self </span>:: REQUEST_DATA_STREAM (..) =&gt; <span class="number">66u32 </span>, <span class="self">Self </span>:: PARAM_REQUEST_LIST (..) =&gt; <span class="number">21u32 </span>, <span class="self">Self </span>:: VISION_POSITION_ESTIMATE (..) =&gt; <span class="number">102u32 </span>, <span class="self">Self </span>:: CAMERA_IMAGE_CAPTURED (..) =&gt; <span class="number">263u32 </span>, <span class="self">Self </span>:: FOLLOW_TARGET (..) =&gt; <span class="number">144u32 </span>, <span class="self">Self </span>:: HEARTBEAT (..) =&gt; <span class="number">0u32 </span>, <span class="self">Self </span>:: DATA64 (..) =&gt; <span class="number">171u32 </span>, <span class="self">Self </span>:: HERELINK_VIDEO_STREAM_INFORMATION (..) =&gt; <span class="number">50002u32 </span>, <span class="self">Self </span>:: GOPRO_HEARTBEAT (..) =&gt; <span class="number">215u32 </span>, <span class="self">Self </span>:: RC_CHANNELS_SCALED (..) =&gt; <span class="number">34u32 </span>, <span class="self">Self </span>:: MISSION_REQUEST_INT (..) =&gt; <span class="number">51u32 </span>, <span class="self">Self </span>:: CAN_FRAME (..) =&gt; <span class="number">386u32 </span>, <span class="self">Self </span>:: HIL_GPS (..) =&gt; <span class="number">113u32 </span>, <span class="self">Self </span>:: GENERATOR_STATUS (..) =&gt; <span class="number">373u32 </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_INFORMATION (..) =&gt; <span class="number">280u32 </span>, <span class="self">Self </span>:: TERRAIN_CHECK (..) =&gt; <span class="number">135u32 </span>, <span class="self">Self </span>:: BATTERY2 (..) =&gt; <span class="number">181u32 </span>, <span class="self">Self </span>:: CAMERA_FOV_STATUS (..) =&gt; <span class="number">271u32 </span>, <span class="self">Self </span>:: PARAM_REQUEST_READ (..) =&gt; <span class="number">20u32 </span>, <span class="self">Self </span>:: MISSION_WRITE_PARTIAL_LIST (..) =&gt; <span class="number">38u32 </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG (..) =&gt; <span class="number">10001u32 </span>, <span class="self">Self </span>:: CAMERA_INFORMATION (..) =&gt; <span class="number">259u32 </span>, <span class="self">Self </span>:: WATER_DEPTH (..) =&gt; <span class="number">11038u32 </span>, <span class="self">Self </span>:: DATA_STREAM (..) =&gt; <span class="number">67u32 </span>, <span class="self">Self </span>:: COMMAND_LONG (..) =&gt; <span class="number">76u32 </span>, <span class="self">Self </span>:: SETUP_SIGNING (..) =&gt; <span class="number">256u32 </span>, <span class="self">Self </span>:: HIL_CONTROLS (..) =&gt; <span class="number">91u32 </span>, <span class="self">Self </span>:: REMOTE_LOG_DATA_BLOCK (..) =&gt; <span class="number">184u32 </span>, <span class="self">Self </span>:: HIGHRES_IMU (..) =&gt; <span class="number">105u32 </span>, <span class="self">Self </span>:: ORBIT_EXECUTION_STATUS (..) =&gt; <span class="number">360u32 </span>, <span class="self">Self </span>:: SCALED_IMU2 (..) =&gt; <span class="number">116u32 </span>, <span class="self">Self </span>:: MOUNT_CONFIGURE (..) =&gt; <span class="number">156u32 </span>, <span class="self">Self </span>:: MANUAL_CONTROL (..) =&gt; <span class="number">69u32 </span>, <span class="self">Self </span>:: SAFETY_SET_ALLOWED_AREA (..) =&gt; <span class="number">54u32 </span>, <span class="self">Self </span>:: HWSTATUS (..) =&gt; <span class="number">165u32 </span>, <span class="self">Self </span>:: AUTOPILOT_VERSION_REQUEST (..) =&gt; <span class="number">183u32 </span>, <span class="self">Self </span>:: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT (..) =&gt; <span class="number">10003u32 </span>, <span class="self">Self </span>:: LOG_REQUEST_LIST (..) =&gt; <span class="number">117u32 </span>, <span class="self">Self </span>:: GPS2_RTK (..) =&gt; <span class="number">128u32 </span>, <span class="self">Self </span>:: WIND_COV (..) =&gt; <span class="number">231u32 </span>, <span class="self">Self </span>:: DEVICE_OP_READ_REPLY (..) =&gt; <span class="number">11001u32 </span>, <span class="self">Self </span>:: DISTANCE_SENSOR (..) =&gt; <span class="number">132u32 </span>, <span class="self">Self </span>:: SERIAL_CONTROL (..) =&gt; <span class="number">126u32 </span>, <span class="self">Self </span>:: LOG_ERASE (..) =&gt; <span class="number">121u32 </span>, <span class="self">Self </span>:: OPTICAL_FLOW (..) =&gt; <span class="number">100u32 </span>, <span class="self">Self </span>:: ENCAPSULATED_DATA (..) =&gt; <span class="number">131u32 </span>, <span class="self">Self </span>:: LOG_ENTRY (..) =&gt; <span class="number">118u32 </span>, <span class="self">Self </span>:: HIGH_LATENCY2 (..) =&gt; <span class="number">235u32 </span>, <span class="self">Self </span>:: ISBD_LINK_STATUS (..) =&gt; <span class="number">335u32 </span>, <span class="self">Self </span>:: RESPONSE_EVENT_ERROR (..) =&gt; <span class="number">413u32 </span>, <span class="self">Self </span>:: ESTIMATOR_STATUS (..) =&gt; <span class="number">230u32 </span>, <span class="self">Self </span>:: MCU_STATUS (..) =&gt; <span class="number">11039u32 </span>, <span class="self">Self </span>:: RC_CHANNELS_RAW (..) =&gt; <span class="number">35u32 </span>, <span class="self">Self </span>:: DATA_TRANSMISSION_HANDSHAKE (..) =&gt; <span class="number">130u32 </span>, <span class="self">Self </span>:: CAMERA_CAPTURE_STATUS (..) =&gt; <span class="number">262u32 </span>, <span class="self">Self </span>:: RAW_RPM (..) =&gt; <span class="number">339u32 </span>, <span class="self">Self </span>:: GPS_RTCM_DATA (..) =&gt; <span class="number">233u32 </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED_COV (..) =&gt; <span class="number">64u32 </span>, <span class="self">Self </span>:: GOPRO_GET_RESPONSE (..) =&gt; <span class="number">217u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SELF_ID (..) =&gt; <span class="number">12903u32 </span>, <span class="self">Self </span>:: ESC_TELEMETRY_9_TO_12 (..) =&gt; <span class="number">11032u32 </span>, <span class="self">Self </span>:: POWER_STATUS (..) =&gt; <span class="number">125u32 </span>, <span class="self">Self </span>:: FILE_TRANSFER_PROTOCOL (..) =&gt; <span class="number">110u32 </span>, <span class="self">Self </span>:: GPS_RTK (..) =&gt; <span class="number">127u32 </span>, <span class="self">Self </span>:: MISSION_CLEAR_ALL (..) =&gt; <span class="number">45u32 </span>, <span class="self">Self </span>:: MISSION_REQUEST (..) =&gt; <span class="number">40u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_AUTHENTICATION (..) =&gt; <span class="number">12902u32 </span>, <span class="self">Self </span>:: FENCE_FETCH_POINT (..) =&gt; <span class="number">161u32 </span>, <span class="self">Self </span>:: GOPRO_SET_REQUEST (..) =&gt; <span class="number">218u32 </span>, <span class="self">Self </span>:: HIL_ACTUATOR_CONTROLS (..) =&gt; <span class="number">93u32 </span>, <span class="self">Self </span>:: OBSTACLE_DISTANCE_3D (..) =&gt; <span class="number">11037u32 </span>, <span class="self">Self </span>:: ATT_POS_MOCAP (..) =&gt; <span class="number">138u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM_UPDATE (..) =&gt; <span class="number">12919u32 </span>, <span class="self">Self </span>:: SET_POSITION_TARGET_GLOBAL_INT (..) =&gt; <span class="number">86u32 </span>, <span class="self">Self </span>:: RESOURCE_REQUEST (..) =&gt; <span class="number">142u32 </span>, <span class="self">Self </span>:: MAG_CAL_REPORT (..) =&gt; <span class="number">192u32 </span>, <span class="self">Self </span>:: HIL_RC_INPUTS_RAW (..) =&gt; <span class="number">92u32 </span>, <span class="self">Self </span>:: MISSION_REQUEST_PARTIAL_LIST (..) =&gt; <span class="number">37u32 </span>, <span class="self">Self </span>:: HOME_POSITION (..) =&gt; <span class="number">242u32 </span>, <span class="self">Self </span>:: RAW_PRESSURE (..) =&gt; <span class="number">28u32 </span>, <span class="self">Self </span>:: DIGICAM_CONTROL (..) =&gt; <span class="number">155u32 </span>, <span class="self">Self </span>:: MISSION_CURRENT (..) =&gt; <span class="number">42u32 </span>, <span class="self">Self </span>:: ESC_TELEMETRY_1_TO_4 (..) =&gt; <span class="number">11030u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_LOCATION (..) =&gt; <span class="number">12901u32 </span>, <span class="self">Self </span>:: MAG_CAL_PROGRESS (..) =&gt; <span class="number">191u32 </span>, <span class="self">Self </span>:: COMPONENT_METADATA (..) =&gt; <span class="number">397u32 </span>, <span class="self">Self </span>:: UTM_GLOBAL_POSITION (..) =&gt; <span class="number">340u32 </span>, <span class="self">Self </span>:: POSITION_TARGET_LOCAL_NED (..) =&gt; <span class="number">85u32 </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_SET_ATTITUDE (..) =&gt; <span class="number">284u32 </span>, <span class="self">Self </span>:: VISION_POSITION_DELTA (..) =&gt; <span class="number">11011u32 </span>, <span class="self">Self </span>:: HIGH_LATENCY (..) =&gt; <span class="number">234u32 </span>, <span class="self">Self </span>:: TERRAIN_REPORT (..) =&gt; <span class="number">136u32 </span>, <span class="self">Self </span>:: MISSION_ITEM_INT (..) =&gt; <span class="number">73u32 </span>, <span class="self">Self </span>:: DEEPSTALL (..) =&gt; <span class="number">195u32 </span>, <span class="self">Self </span>:: CAMERA_TRIGGER (..) =&gt; <span class="number">112u32 </span>, <span class="self">Self </span>:: MEMORY_VECT (..) =&gt; <span class="number">249u32 </span>, <span class="self">Self </span>:: LIMITS_STATUS (..) =&gt; <span class="number">167u32 </span>, <span class="self">Self </span>:: OSD_PARAM_SHOW_CONFIG_REPLY (..) =&gt; <span class="number">11036u32 </span>, <span class="self">Self </span>:: REMOTE_LOG_BLOCK_STATUS (..) =&gt; <span class="number">185u32 </span>, <span class="self">Self </span>:: DEVICE_OP_WRITE_REPLY (..) =&gt; <span class="number">11003u32 </span>, <span class="self">Self </span>:: LANDING_TARGET (..) =&gt; <span class="number">149u32 </span>, <span class="self">Self </span>:: GIMBAL_REPORT (..) =&gt; <span class="number">200u32 </span>, <span class="self">Self </span>:: CAMERA_TRACKING_IMAGE_STATUS (..) =&gt; <span class="number">275u32 </span>, <span class="self">Self </span>:: ATTITUDE_QUATERNION_COV (..) =&gt; <span class="number">61u32 </span>, <span class="self">Self </span>:: RALLY_POINT (..) =&gt; <span class="number">175u32 </span>, <span class="self">Self </span>:: SCALED_PRESSURE3 (..) =&gt; <span class="number">143u32 </span>, <span class="self">Self </span>:: SIM_STATE (..) =&gt; <span class="number">108u32 </span>, <span class="self">Self </span>:: ACTUATOR_OUTPUT_STATUS (..) =&gt; <span class="number">375u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_MESSAGE_PACK (..) =&gt; <span class="number">12915u32 </span>, <span class="self">Self </span>:: VISION_SPEED_ESTIMATE (..) =&gt; <span class="number">103u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_BASIC_ID (..) =&gt; <span class="number">12900u32 </span>, <span class="self">Self </span>:: TUNNEL (..) =&gt; <span class="number">385u32 </span>, <span class="self">Self </span>:: POSITION_TARGET_GLOBAL_INT (..) =&gt; <span class="number">87u32 </span>, <span class="self">Self </span>:: SENSOR_OFFSETS (..) =&gt; <span class="number">150u32 </span>, <span class="self">Self </span>:: UAVCAN_NODE_INFO (..) =&gt; <span class="number">311u32 </span>, <span class="self">Self </span>:: FLIGHT_INFORMATION (..) =&gt; <span class="number">264u32 </span>, <span class="self">Self </span>:: RADIO (..) =&gt; <span class="number">166u32 </span>, <span class="self">Self </span>:: DATA32 (..) =&gt; <span class="number">170u32 </span>, <span class="self">Self </span>:: CUBEPILOT_RAW_RC (..) =&gt; <span class="number">50001u32 </span>, <span class="self">Self </span>:: SCALED_IMU3 (..) =&gt; <span class="number">129u32 </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_MANUAL_CONTROL (..) =&gt; <span class="number">288u32 </span>, <span class="self">Self </span>:: GIMBAL_DEVICE_INFORMATION (..) =&gt; <span class="number">283u32 </span>, <span class="self">Self </span>:: TERRAIN_DATA (..) =&gt; <span class="number">134u32 </span>, <span class="self">Self </span>:: ACTUATOR_CONTROL_TARGET (..) =&gt; <span class="number">140u32 </span>, <span class="self">Self </span>:: LINK_NODE_STATUS (..) =&gt; <span class="number">8u32 </span>, <span class="self">Self </span>:: ESC_STATUS (..) =&gt; <span class="number">291u32 </span>, <span class="self">Self </span>:: STATUSTEXT (..) =&gt; <span class="number">253u32 </span>, <span class="self">Self </span>:: SET_ATTITUDE_TARGET (..) =&gt; <span class="number">82u32 </span>, <span class="self">Self </span>:: ALTITUDE (..) =&gt; <span class="number">141u32 </span>, <span class="self">Self </span>:: GPS_GLOBAL_ORIGIN (..) =&gt; <span class="number">49u32 </span>, <span class="self">Self </span>:: VIDEO_STREAM_STATUS (..) =&gt; <span class="number">270u32 </span>, <span class="self">Self </span>:: CONTROL_SYSTEM_STATE (..) =&gt; <span class="number">146u32 </span>, <span class="self">Self </span>:: CUBEPILOT_FIRMWARE_UPDATE_START (..) =&gt; <span class="number">50004u32 </span>, <span class="self">Self </span>:: MISSION_REQUEST_LIST (..) =&gt; <span class="number">43u32 </span>, <span class="self">Self </span>:: AHRS3 (..) =&gt; <span class="number">182u32 </span>, <span class="self">Self </span>:: DEVICE_OP_WRITE (..) =&gt; <span class="number">11002u32 </span>, <span class="self">Self </span>:: ESC_TELEMETRY_5_TO_8 (..) =&gt; <span class="number">11031u32 </span>, <span class="self">Self </span>:: MANUAL_SETPOINT (..) =&gt; <span class="number">81u32 </span>, <span class="self">Self </span>:: UAVCAN_NODE_STATUS (..) =&gt; <span class="number">310u32 </span>, <span class="self">Self </span>:: PARAM_EXT_SET (..) =&gt; <span class="number">323u32 </span>, <span class="self">Self </span>:: MOUNT_STATUS (..) =&gt; <span class="number">158u32 </span>, <span class="self">Self </span>:: AIRSPEED_AUTOCAL (..) =&gt; <span class="number">174u32 </span>, <span class="self">Self </span>:: SCALED_PRESSURE (..) =&gt; <span class="number">29u32 </span>, <span class="self">Self </span>:: CELLULAR_STATUS (..) =&gt; <span class="number">334u32 </span>, <span class="self">Self </span>:: SYS_STATUS (..) =&gt; <span class="number">1u32 </span>, <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_BEZIER (..) =&gt; <span class="number">333u32 </span>, <span class="self">Self </span>:: TIMESYNC (..) =&gt; <span class="number">111u32 </span>, <span class="self">Self </span>:: MOUNT_CONTROL (..) =&gt; <span class="number">157u32 </span>, <span class="self">Self </span>:: CAMERA_FEEDBACK (..) =&gt; <span class="number">180u32 </span>, <span class="self">Self </span>:: BUTTON_CHANGE (..) =&gt; <span class="number">257u32 </span>, <span class="self">Self </span>:: CAMERA_STATUS (..) =&gt; <span class="number">179u32 </span>, <span class="self">Self </span>:: SET_POSITION_TARGET_LOCAL_NED (..) =&gt; <span class="number">84u32 </span>, <span class="self">Self </span>:: ODOMETRY (..) =&gt; <span class="number">331u32 </span>, <span class="self">Self </span>:: GPS_RAW_INT (..) =&gt; <span class="number">24u32 </span>, <span class="self">Self </span>:: GIMBAL_TORQUE_CMD_REPORT (..) =&gt; <span class="number">214u32 </span>, <span class="self">Self </span>:: OSD_PARAM_CONFIG (..) =&gt; <span class="number">11033u32 </span>, <span class="self">Self </span>:: DATA16 (..) =&gt; <span class="number">169u32 </span>, <span class="self">Self </span>:: PID_TUNING (..) =&gt; <span class="number">194u32 </span>, <span class="self">Self </span>:: OBSTACLE_DISTANCE (..) =&gt; <span class="number">330u32 </span>, <span class="self">Self </span>:: COMMAND_INT (..) =&gt; <span class="number">75u32 </span>, <span class="self">Self </span>:: COMMAND_ACK (..) =&gt; <span class="number">77u32 </span>, <span class="self">Self </span>:: ICAROUS_HEARTBEAT (..) =&gt; <span class="number">42000u32 </span>, <span class="self">Self </span>:: MISSION_SET_CURRENT (..) =&gt; <span class="number">41u32 </span>, <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_WAYPOINTS (..) =&gt; <span class="number">332u32 </span>, <span class="self">Self </span>:: WINCH_STATUS (..) =&gt; <span class="number">9005u32 </span>, <span class="self">Self </span>:: PARAM_EXT_REQUEST_LIST (..) =&gt; <span class="number">321u32 </span>, <span class="self">Self </span>:: ICAROUS_KINEMATIC_BANDS (..) =&gt; <span class="number">42001u32 </span>, <span class="self">Self </span>:: CUBEPILOT_FIRMWARE_UPDATE_RESP (..) =&gt; <span class="number">50005u32 </span>, <span class="self">Self </span>:: AHRS (..) =&gt; <span class="number">163u32 </span>, <span class="self">Self </span>:: CAN_FILTER_MODIFY (..) =&gt; <span class="number">388u32 </span>, <span class="self">Self </span>:: SET_HOME_POSITION (..) =&gt; <span class="number">243u32 </span>, <span class="self">Self </span>:: GPS_STATUS (..) =&gt; <span class="number">25u32 </span>, <span class="self">Self </span>:: RAW_IMU (..) =&gt; <span class="number">27u32 </span>, <span class="self">Self </span>:: GOPRO_SET_RESPONSE (..) =&gt; <span class="number">219u32 </span>, <span class="self">Self </span>:: LOGGING_DATA (..) =&gt; <span class="number">266u32 </span>, <span class="self">Self </span>:: SIMSTATE (..) =&gt; <span class="number">164u32 </span>, <span class="self">Self </span>:: ATTITUDE_QUATERNION (..) =&gt; <span class="number">31u32 </span>, <span class="self">Self </span>:: HIL_OPTICAL_FLOW (..) =&gt; <span class="number">114u32 </span>, <span class="self">Self </span>:: RPM (..) =&gt; <span class="number">226u32 </span>, <span class="self">Self </span>:: OSD_PARAM_CONFIG_REPLY (..) =&gt; <span class="number">11034u32 </span>, <span class="self">Self </span>:: PROTOCOL_VERSION (..) =&gt; <span class="number">300u32 </span>, <span class="self">Self </span>:: ATTITUDE_TARGET (..) =&gt; <span class="number">83u32 </span>, <span class="self">Self </span>:: PARAM_SET (..) =&gt; <span class="number">23u32 </span>, <span class="self">Self </span>:: AHRS2 (..) =&gt; <span class="number">178u32 </span>, <span class="self">Self </span>:: WIND (..) =&gt; <span class="number">168u32 </span>, <span class="self">Self </span>:: VICON_POSITION_ESTIMATE (..) =&gt; <span class="number">104u32 </span>, <span class="self">Self </span>:: MISSION_COUNT (..) =&gt; <span class="number">44u32 </span>, <span class="self">Self </span>:: LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET (..) =&gt; <span class="number">89u32 </span>, <span class="self">Self </span>:: NAMED_VALUE_FLOAT (..) =&gt; <span class="number">251u32 </span>, <span class="self">Self </span>:: PLAY_TUNE_V2 (..) =&gt; <span class="number">400u32 </span>, <span class="self">Self </span>:: MEMINFO (..) =&gt; <span class="number">152u32 </span>, <span class="self">Self </span>:: DATA96 (..) =&gt; <span class="number">172u32 </span>, <span class="self">Self </span>:: GIMBAL_CONTROL (..) =&gt; <span class="number">201u32 </span>, <span class="self">Self </span>:: LOG_DATA (..) =&gt; <span class="number">120u32 </span>, <span class="self">Self </span>:: SET_GPS_GLOBAL_ORIGIN (..) =&gt; <span class="number">48u32 </span>, <span class="self">Self </span>:: MOUNT_ORIENTATION (..) =&gt; <span class="number">265u32 </span>, <span class="self">Self </span>:: GPS2_RAW (..) =&gt; <span class="number">124u32 </span>, <span class="self">Self </span>:: GLOBAL_VISION_POSITION_ESTIMATE (..) =&gt; <span class="number">101u32 </span>, <span class="self">Self </span>:: HERELINK_TELEM (..) =&gt; <span class="number">50003u32 </span>, <span class="self">Self </span>:: CAMERA_TRACKING_GEO_STATUS (..) =&gt; <span class="number">276u32 </span>, <span class="self">Self </span>:: CURRENT_EVENT_SEQUENCE (..) =&gt; <span class="number">411u32 </span>, <span class="self">Self </span>:: MESSAGE_INTERVAL (..) =&gt; <span class="number">244u32 </span>, <span class="self">Self </span>:: MISSION_ITEM (..) =&gt; <span class="number">39u32 </span>, <span class="self">Self </span>:: RADIO_STATUS (..) =&gt; <span class="number">109u32 </span>, <span class="self">Self </span>:: FENCE_STATUS (..) =&gt; <span class="number">162u32 </span>, <span class="self">Self </span>:: HIL_SENSOR (..) =&gt; <span class="number">107u32 </span>, <span class="self">Self </span>:: MISSION_ACK (..) =&gt; <span class="number">47u32 </span>, <span class="self">Self </span>:: GLOBAL_POSITION_INT_COV (..) =&gt; <span class="number">63u32 </span>, <span class="self">Self </span>:: CELLULAR_CONFIG (..) =&gt; <span class="number">336u32 </span>, <span class="self">Self </span>:: VIDEO_STREAM_INFORMATION (..) =&gt; <span class="number">269u32 </span>, <span class="self">Self </span>:: ADSB_VEHICLE (..) =&gt; <span class="number">246u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM (..) =&gt; <span class="number">12904u32 </span>, <span class="self">Self </span>:: GPS_INPUT (..) =&gt; <span class="number">232u32 </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_STATUS (..) =&gt; <span class="number">281u32 </span>, <span class="self">Self </span>:: EXTENDED_SYS_STATE (..) =&gt; <span class="number">245u32 </span>, <span class="self">Self </span>:: OPEN_DRONE_ID_OPERATOR_ID (..) =&gt; <span class="number">12905u32 </span>, <span class="self">Self </span>:: SET_ACTUATOR_CONTROL_TARGET (..) =&gt; <span class="number">139u32 </span>, <span class="self">Self </span>:: DEBUG_FLOAT_ARRAY (..) =&gt; <span class="number">350u32 </span>, <span class="self">Self </span>:: AP_ADC (..) =&gt; <span class="number">153u32 </span>, <span class="self">Self </span>:: SMART_BATTERY_INFO (..) =&gt; <span class="number">370u32 </span>, <span class="self">Self </span>:: LOG_REQUEST_END (..) =&gt; <span class="number">122u32 </span>, <span class="self">Self </span>:: GIMBAL_MANAGER_SET_PITCHYAW (..) =&gt; <span class="number">287u32 </span>, <span class="self">Self </span>:: COMPONENT_INFORMATION (..) =&gt; <span class="number">395u32 </span>, <span class="self">Self </span>:: SERVO_OUTPUT_RAW (..) =&gt; <span class="number">36u32 </span>, <span class="self">Self </span>:: ATTITUDE (..) =&gt; <span class="number">30u32 </span>, <span class="self">Self </span>:: ESC_INFO (..) =&gt; <span class="number">290u32 </span>, <span class="self">Self </span>:: PING (..) =&gt; <span class="number">4u32 </span>, <span class="self">Self </span>:: PARAM_EXT_VALUE (..) =&gt; <span class="number">322u32 </span>, <span class="self">Self </span>:: AUTOPILOT_STATE_FOR_GIMBAL_DEVICE (..) =&gt; <span class="number">286u32 </span>, <span class="self">Self </span>:: AUTOPILOT_VERSION (..) =&gt; <span class="number">148u32 </span>, <span class="self">Self </span>:: NAV_CONTROLLER_OUTPUT (..) =&gt; <span class="number">62u32 </span>, <span class="self">Self </span>:: MISSION_ITEM_REACHED (..) =&gt; <span class="number">46u32 </span>, <span class="self">Self </span>:: EFI_STATUS (..) =&gt; <span class="number">225u32 </span>, <span class="self">Self </span>:: SET_MAG_OFFSETS (..) =&gt; <span class="number">151u32 </span>, <span class="self">Self </span>:: DEBUG_VECT (..) =&gt; <span class="number">250u32 </span>, <span class="self">Self </span>:: SYSTEM_TIME (..) =&gt; <span class="number">2u32 </span>, <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL_ACK (..) =&gt; <span class="number">6u32 </span>, } } <span class="kw">fn </span>message_id_from_name (name : &amp; str) -&gt; <span class="prelude-ty">Result </span>&lt; u32 , &amp; <span class="lifetime">&#39;static </span>str &gt; { <span class="kw">match </span>name { <span class="string">&quot;GOPRO_GET_REQUEST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">216u32</span>) , <span class="string">&quot;COLLISION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">247u32</span>) , <span class="string">&quot;RC_CHANNELS_OVERRIDE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">70u32</span>) , <span class="string">&quot;SAFETY_ALLOWED_AREA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">55u32</span>) , <span class="string">&quot;RC_CHANNELS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">65u32</span>) , <span class="string">&quot;RANGEFINDER&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">173u32</span>) , <span class="string">&quot;GIMBAL_DEVICE_ATTITUDE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">285u32</span>) , <span class="string">&quot;GLOBAL_POSITION_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">33u32</span>) , <span class="string">&quot;PARAM_VALUE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">22u32</span>) , <span class="string">&quot;EVENT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">410u32</span>) , <span class="string">&quot;SCALED_IMU&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">26u32</span>) , <span class="string">&quot;BATTERY_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">147u32</span>) , <span class="string">&quot;V2_EXTENSION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">248u32</span>) , <span class="string">&quot;HIL_STATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">90u32</span>) , <span class="string">&quot;AOA_SSA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11020u32</span>) , <span class="string">&quot;REQUEST_EVENT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">412u32</span>) , <span class="string">&quot;AIS_VESSEL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">301u32</span>) , <span class="string">&quot;DEBUG&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">254u32</span>) , <span class="string">&quot;SUPPORTED_TUNES&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">401u32</span>) , <span class="string">&quot;DIGICAM_CONFIGURE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">154u32</span>) , <span class="string">&quot;LED_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">186u32</span>) , <span class="string">&quot;PARAM_EXT_REQUEST_READ&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">320u32</span>) , <span class="string">&quot;AUTH_KEY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">7u32</span>) , <span class="string">&quot;ONBOARD_COMPUTER_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">390u32</span>) , <span class="string">&quot;WIFI_CONFIG_AP&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">299u32</span>) , <span class="string">&quot;WHEEL_DISTANCE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">9000u32</span>) , <span class="string">&quot;NAMED_VALUE_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">252u32</span>) , <span class="string">&quot;PLAY_TUNE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">258u32</span>) , <span class="string">&quot;PARAM_MAP_RC&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">50u32</span>) , <span class="string">&quot;GPS_INJECT_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">123u32</span>) , <span class="string">&quot;CANFD_FRAME&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">387u32</span>) , <span class="string">&quot;ADAP_TUNING&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11010u32</span>) , <span class="string">&quot;LOG_REQUEST_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">119u32</span>) , <span class="string">&quot;PARAM_EXT_ACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">324u32</span>) , <span class="string">&quot;VIBRATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">241u32</span>) , <span class="string">&quot;EKF_STATUS_REPORT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">193u32</span>) , <span class="string">&quot;STORAGE_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">261u32</span>) , <span class="string">&quot;DEVICE_OP_READ&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11000u32</span>) , <span class="string">&quot;OSD_PARAM_SHOW_CONFIG&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11035u32</span>) , <span class="string">&quot;LOGGING_DATA_ACKED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">267u32</span>) , <span class="string">&quot;HYGROMETER_SENSOR&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12920u32</span>) , <span class="string">&quot;VFR_HUD&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">74u32</span>) , <span class="string">&quot;UAVIONIX_ADSB_OUT_DYNAMIC&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">10002u32</span>) , <span class="string">&quot;LOCAL_POSITION_NED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">32u32</span>) , <span class="string">&quot;TERRAIN_REQUEST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">133u32</span>) , <span class="string">&quot;CAMERA_SETTINGS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">260u32</span>) , <span class="string">&quot;FENCE_POINT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">160u32</span>) , <span class="string">&quot;OPTICAL_FLOW_RAD&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">106u32</span>) , <span class="string">&quot;HIL_STATE_QUATERNION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">115u32</span>) , <span class="string">&quot;SCALED_PRESSURE2&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">137u32</span>) , <span class="string">&quot;CHANGE_OPERATOR_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">5u32</span>) , <span class="string">&quot;COMPASSMOT_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">177u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_ARM_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12918u32</span>) , <span class="string">&quot;LOGGING_ACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">268u32</span>) , <span class="string">&quot;GIMBAL_MANAGER_SET_ATTITUDE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">282u32</span>) , <span class="string">&quot;TIME_ESTIMATE_TO_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">380u32</span>) , <span class="string">&quot;SET_MODE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11u32</span>) , <span class="string">&quot;RALLY_FETCH_POINT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">176u32</span>) , <span class="string">&quot;COMMAND_CANCEL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">80u32</span>) , <span class="string">&quot;REQUEST_DATA_STREAM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">66u32</span>) , <span class="string">&quot;PARAM_REQUEST_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">21u32</span>) , <span class="string">&quot;VISION_POSITION_ESTIMATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">102u32</span>) , <span class="string">&quot;CAMERA_IMAGE_CAPTURED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">263u32</span>) , <span class="string">&quot;FOLLOW_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">144u32</span>) , <span class="string">&quot;HEARTBEAT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">0u32</span>) , <span class="string">&quot;DATA64&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">171u32</span>) , <span class="string">&quot;HERELINK_VIDEO_STREAM_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">50002u32</span>) , <span class="string">&quot;GOPRO_HEARTBEAT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">215u32</span>) , <span class="string">&quot;RC_CHANNELS_SCALED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">34u32</span>) , <span class="string">&quot;MISSION_REQUEST_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">51u32</span>) , <span class="string">&quot;CAN_FRAME&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">386u32</span>) , <span class="string">&quot;HIL_GPS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">113u32</span>) , <span class="string">&quot;GENERATOR_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">373u32</span>) , <span class="string">&quot;GIMBAL_MANAGER_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">280u32</span>) , <span class="string">&quot;TERRAIN_CHECK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">135u32</span>) , <span class="string">&quot;BATTERY2&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">181u32</span>) , <span class="string">&quot;CAMERA_FOV_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">271u32</span>) , <span class="string">&quot;PARAM_REQUEST_READ&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">20u32</span>) , <span class="string">&quot;MISSION_WRITE_PARTIAL_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">38u32</span>) , <span class="string">&quot;UAVIONIX_ADSB_OUT_CFG&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">10001u32</span>) , <span class="string">&quot;CAMERA_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">259u32</span>) , <span class="string">&quot;WATER_DEPTH&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11038u32</span>) , <span class="string">&quot;DATA_STREAM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">67u32</span>) , <span class="string">&quot;COMMAND_LONG&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">76u32</span>) , <span class="string">&quot;SETUP_SIGNING&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">256u32</span>) , <span class="string">&quot;HIL_CONTROLS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">91u32</span>) , <span class="string">&quot;REMOTE_LOG_DATA_BLOCK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">184u32</span>) , <span class="string">&quot;HIGHRES_IMU&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">105u32</span>) , <span class="string">&quot;ORBIT_EXECUTION_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">360u32</span>) , <span class="string">&quot;SCALED_IMU2&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">116u32</span>) , <span class="string">&quot;MOUNT_CONFIGURE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">156u32</span>) , <span class="string">&quot;MANUAL_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">69u32</span>) , <span class="string">&quot;SAFETY_SET_ALLOWED_AREA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">54u32</span>) , <span class="string">&quot;HWSTATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">165u32</span>) , <span class="string">&quot;AUTOPILOT_VERSION_REQUEST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">183u32</span>) , <span class="string">&quot;UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">10003u32</span>) , <span class="string">&quot;LOG_REQUEST_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">117u32</span>) , <span class="string">&quot;GPS2_RTK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">128u32</span>) , <span class="string">&quot;WIND_COV&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">231u32</span>) , <span class="string">&quot;DEVICE_OP_READ_REPLY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11001u32</span>) , <span class="string">&quot;DISTANCE_SENSOR&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">132u32</span>) , <span class="string">&quot;SERIAL_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">126u32</span>) , <span class="string">&quot;LOG_ERASE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">121u32</span>) , <span class="string">&quot;OPTICAL_FLOW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">100u32</span>) , <span class="string">&quot;ENCAPSULATED_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">131u32</span>) , <span class="string">&quot;LOG_ENTRY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">118u32</span>) , <span class="string">&quot;HIGH_LATENCY2&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">235u32</span>) , <span class="string">&quot;ISBD_LINK_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">335u32</span>) , <span class="string">&quot;RESPONSE_EVENT_ERROR&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">413u32</span>) , <span class="string">&quot;ESTIMATOR_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">230u32</span>) , <span class="string">&quot;MCU_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11039u32</span>) , <span class="string">&quot;RC_CHANNELS_RAW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">35u32</span>) , <span class="string">&quot;DATA_TRANSMISSION_HANDSHAKE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">130u32</span>) , <span class="string">&quot;CAMERA_CAPTURE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">262u32</span>) , <span class="string">&quot;RAW_RPM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">339u32</span>) , <span class="string">&quot;GPS_RTCM_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">233u32</span>) , <span class="string">&quot;LOCAL_POSITION_NED_COV&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">64u32</span>) , <span class="string">&quot;GOPRO_GET_RESPONSE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">217u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_SELF_ID&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12903u32</span>) , <span class="string">&quot;ESC_TELEMETRY_9_TO_12&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11032u32</span>) , <span class="string">&quot;POWER_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">125u32</span>) , <span class="string">&quot;FILE_TRANSFER_PROTOCOL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">110u32</span>) , <span class="string">&quot;GPS_RTK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">127u32</span>) , <span class="string">&quot;MISSION_CLEAR_ALL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">45u32</span>) , <span class="string">&quot;MISSION_REQUEST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">40u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_AUTHENTICATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12902u32</span>) , <span class="string">&quot;FENCE_FETCH_POINT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">161u32</span>) , <span class="string">&quot;GOPRO_SET_REQUEST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">218u32</span>) , <span class="string">&quot;HIL_ACTUATOR_CONTROLS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">93u32</span>) , <span class="string">&quot;OBSTACLE_DISTANCE_3D&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11037u32</span>) , <span class="string">&quot;ATT_POS_MOCAP&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">138u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_SYSTEM_UPDATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12919u32</span>) , <span class="string">&quot;SET_POSITION_TARGET_GLOBAL_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">86u32</span>) , <span class="string">&quot;RESOURCE_REQUEST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">142u32</span>) , <span class="string">&quot;MAG_CAL_REPORT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">192u32</span>) , <span class="string">&quot;HIL_RC_INPUTS_RAW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">92u32</span>) , <span class="string">&quot;MISSION_REQUEST_PARTIAL_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">37u32</span>) , <span class="string">&quot;HOME_POSITION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">242u32</span>) , <span class="string">&quot;RAW_PRESSURE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">28u32</span>) , <span class="string">&quot;DIGICAM_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">155u32</span>) , <span class="string">&quot;MISSION_CURRENT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">42u32</span>) , <span class="string">&quot;ESC_TELEMETRY_1_TO_4&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11030u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_LOCATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12901u32</span>) , <span class="string">&quot;MAG_CAL_PROGRESS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">191u32</span>) , <span class="string">&quot;COMPONENT_METADATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">397u32</span>) , <span class="string">&quot;UTM_GLOBAL_POSITION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">340u32</span>) , <span class="string">&quot;POSITION_TARGET_LOCAL_NED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">85u32</span>) , <span class="string">&quot;GIMBAL_DEVICE_SET_ATTITUDE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">284u32</span>) , <span class="string">&quot;VISION_POSITION_DELTA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11011u32</span>) , <span class="string">&quot;HIGH_LATENCY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">234u32</span>) , <span class="string">&quot;TERRAIN_REPORT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">136u32</span>) , <span class="string">&quot;MISSION_ITEM_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">73u32</span>) , <span class="string">&quot;DEEPSTALL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">195u32</span>) , <span class="string">&quot;CAMERA_TRIGGER&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">112u32</span>) , <span class="string">&quot;MEMORY_VECT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">249u32</span>) , <span class="string">&quot;LIMITS_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">167u32</span>) , <span class="string">&quot;OSD_PARAM_SHOW_CONFIG_REPLY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11036u32</span>) , <span class="string">&quot;REMOTE_LOG_BLOCK_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">185u32</span>) , <span class="string">&quot;DEVICE_OP_WRITE_REPLY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11003u32</span>) , <span class="string">&quot;LANDING_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">149u32</span>) , <span class="string">&quot;GIMBAL_REPORT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">200u32</span>) , <span class="string">&quot;CAMERA_TRACKING_IMAGE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">275u32</span>) , <span class="string">&quot;ATTITUDE_QUATERNION_COV&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">61u32</span>) , <span class="string">&quot;RALLY_POINT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">175u32</span>) , <span class="string">&quot;SCALED_PRESSURE3&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">143u32</span>) , <span class="string">&quot;SIM_STATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">108u32</span>) , <span class="string">&quot;ACTUATOR_OUTPUT_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">375u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_MESSAGE_PACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12915u32</span>) , <span class="string">&quot;VISION_SPEED_ESTIMATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">103u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_BASIC_ID&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12900u32</span>) , <span class="string">&quot;TUNNEL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">385u32</span>) , <span class="string">&quot;POSITION_TARGET_GLOBAL_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">87u32</span>) , <span class="string">&quot;SENSOR_OFFSETS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">150u32</span>) , <span class="string">&quot;UAVCAN_NODE_INFO&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">311u32</span>) , <span class="string">&quot;FLIGHT_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">264u32</span>) , <span class="string">&quot;RADIO&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">166u32</span>) , <span class="string">&quot;DATA32&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">170u32</span>) , <span class="string">&quot;CUBEPILOT_RAW_RC&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">50001u32</span>) , <span class="string">&quot;SCALED_IMU3&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">129u32</span>) , <span class="string">&quot;GIMBAL_MANAGER_SET_MANUAL_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">288u32</span>) , <span class="string">&quot;GIMBAL_DEVICE_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">283u32</span>) , <span class="string">&quot;TERRAIN_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">134u32</span>) , <span class="string">&quot;ACTUATOR_CONTROL_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">140u32</span>) , <span class="string">&quot;LINK_NODE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">8u32</span>) , <span class="string">&quot;ESC_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">291u32</span>) , <span class="string">&quot;STATUSTEXT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">253u32</span>) , <span class="string">&quot;SET_ATTITUDE_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">82u32</span>) , <span class="string">&quot;ALTITUDE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">141u32</span>) , <span class="string">&quot;GPS_GLOBAL_ORIGIN&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">49u32</span>) , <span class="string">&quot;VIDEO_STREAM_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">270u32</span>) , <span class="string">&quot;CONTROL_SYSTEM_STATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">146u32</span>) , <span class="string">&quot;CUBEPILOT_FIRMWARE_UPDATE_START&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">50004u32</span>) , <span class="string">&quot;MISSION_REQUEST_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">43u32</span>) , <span class="string">&quot;AHRS3&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">182u32</span>) , <span class="string">&quot;DEVICE_OP_WRITE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11002u32</span>) , <span class="string">&quot;ESC_TELEMETRY_5_TO_8&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11031u32</span>) , <span class="string">&quot;MANUAL_SETPOINT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">81u32</span>) , <span class="string">&quot;UAVCAN_NODE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">310u32</span>) , <span class="string">&quot;PARAM_EXT_SET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">323u32</span>) , <span class="string">&quot;MOUNT_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">158u32</span>) , <span class="string">&quot;AIRSPEED_AUTOCAL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">174u32</span>) , <span class="string">&quot;SCALED_PRESSURE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">29u32</span>) , <span class="string">&quot;CELLULAR_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">334u32</span>) , <span class="string">&quot;SYS_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">1u32</span>) , <span class="string">&quot;TRAJECTORY_REPRESENTATION_BEZIER&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">333u32</span>) , <span class="string">&quot;TIMESYNC&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">111u32</span>) , <span class="string">&quot;MOUNT_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">157u32</span>) , <span class="string">&quot;CAMERA_FEEDBACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">180u32</span>) , <span class="string">&quot;BUTTON_CHANGE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">257u32</span>) , <span class="string">&quot;CAMERA_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">179u32</span>) , <span class="string">&quot;SET_POSITION_TARGET_LOCAL_NED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">84u32</span>) , <span class="string">&quot;ODOMETRY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">331u32</span>) , <span class="string">&quot;GPS_RAW_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">24u32</span>) , <span class="string">&quot;GIMBAL_TORQUE_CMD_REPORT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">214u32</span>) , <span class="string">&quot;OSD_PARAM_CONFIG&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11033u32</span>) , <span class="string">&quot;DATA16&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">169u32</span>) , <span class="string">&quot;PID_TUNING&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">194u32</span>) , <span class="string">&quot;OBSTACLE_DISTANCE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">330u32</span>) , <span class="string">&quot;COMMAND_INT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">75u32</span>) , <span class="string">&quot;COMMAND_ACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">77u32</span>) , <span class="string">&quot;ICAROUS_HEARTBEAT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">42000u32</span>) , <span class="string">&quot;MISSION_SET_CURRENT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">41u32</span>) , <span class="string">&quot;TRAJECTORY_REPRESENTATION_WAYPOINTS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">332u32</span>) , <span class="string">&quot;WINCH_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">9005u32</span>) , <span class="string">&quot;PARAM_EXT_REQUEST_LIST&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">321u32</span>) , <span class="string">&quot;ICAROUS_KINEMATIC_BANDS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">42001u32</span>) , <span class="string">&quot;CUBEPILOT_FIRMWARE_UPDATE_RESP&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">50005u32</span>) , <span class="string">&quot;AHRS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">163u32</span>) , <span class="string">&quot;CAN_FILTER_MODIFY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">388u32</span>) , <span class="string">&quot;SET_HOME_POSITION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">243u32</span>) , <span class="string">&quot;GPS_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">25u32</span>) , <span class="string">&quot;RAW_IMU&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">27u32</span>) , <span class="string">&quot;GOPRO_SET_RESPONSE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">219u32</span>) , <span class="string">&quot;LOGGING_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">266u32</span>) , <span class="string">&quot;SIMSTATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">164u32</span>) , <span class="string">&quot;ATTITUDE_QUATERNION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">31u32</span>) , <span class="string">&quot;HIL_OPTICAL_FLOW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">114u32</span>) , <span class="string">&quot;RPM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">226u32</span>) , <span class="string">&quot;OSD_PARAM_CONFIG_REPLY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">11034u32</span>) , <span class="string">&quot;PROTOCOL_VERSION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">300u32</span>) , <span class="string">&quot;ATTITUDE_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">83u32</span>) , <span class="string">&quot;PARAM_SET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">23u32</span>) , <span class="string">&quot;AHRS2&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">178u32</span>) , <span class="string">&quot;WIND&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">168u32</span>) , <span class="string">&quot;VICON_POSITION_ESTIMATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">104u32</span>) , <span class="string">&quot;MISSION_COUNT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">44u32</span>) , <span class="string">&quot;LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">89u32</span>) , <span class="string">&quot;NAMED_VALUE_FLOAT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">251u32</span>) , <span class="string">&quot;PLAY_TUNE_V2&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">400u32</span>) , <span class="string">&quot;MEMINFO&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">152u32</span>) , <span class="string">&quot;DATA96&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">172u32</span>) , <span class="string">&quot;GIMBAL_CONTROL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">201u32</span>) , <span class="string">&quot;LOG_DATA&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">120u32</span>) , <span class="string">&quot;SET_GPS_GLOBAL_ORIGIN&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">48u32</span>) , <span class="string">&quot;MOUNT_ORIENTATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">265u32</span>) , <span class="string">&quot;GPS2_RAW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">124u32</span>) , <span class="string">&quot;GLOBAL_VISION_POSITION_ESTIMATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">101u32</span>) , <span class="string">&quot;HERELINK_TELEM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">50003u32</span>) , <span class="string">&quot;CAMERA_TRACKING_GEO_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">276u32</span>) , <span class="string">&quot;CURRENT_EVENT_SEQUENCE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">411u32</span>) , <span class="string">&quot;MESSAGE_INTERVAL&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">244u32</span>) , <span class="string">&quot;MISSION_ITEM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">39u32</span>) , <span class="string">&quot;RADIO_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">109u32</span>) , <span class="string">&quot;FENCE_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">162u32</span>) , <span class="string">&quot;HIL_SENSOR&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">107u32</span>) , <span class="string">&quot;MISSION_ACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">47u32</span>) , <span class="string">&quot;GLOBAL_POSITION_INT_COV&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">63u32</span>) , <span class="string">&quot;CELLULAR_CONFIG&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">336u32</span>) , <span class="string">&quot;VIDEO_STREAM_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">269u32</span>) , <span class="string">&quot;ADSB_VEHICLE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">246u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_SYSTEM&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12904u32</span>) , <span class="string">&quot;GPS_INPUT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">232u32</span>) , <span class="string">&quot;GIMBAL_MANAGER_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">281u32</span>) , <span class="string">&quot;EXTENDED_SYS_STATE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">245u32</span>) , <span class="string">&quot;OPEN_DRONE_ID_OPERATOR_ID&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">12905u32</span>) , <span class="string">&quot;SET_ACTUATOR_CONTROL_TARGET&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">139u32</span>) , <span class="string">&quot;DEBUG_FLOAT_ARRAY&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">350u32</span>) , <span class="string">&quot;AP_ADC&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">153u32</span>) , <span class="string">&quot;SMART_BATTERY_INFO&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">370u32</span>) , <span class="string">&quot;LOG_REQUEST_END&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">122u32</span>) , <span class="string">&quot;GIMBAL_MANAGER_SET_PITCHYAW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">287u32</span>) , <span class="string">&quot;COMPONENT_INFORMATION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">395u32</span>) , <span class="string">&quot;SERVO_OUTPUT_RAW&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">36u32</span>) , <span class="string">&quot;ATTITUDE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">30u32</span>) , <span class="string">&quot;ESC_INFO&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">290u32</span>) , <span class="string">&quot;PING&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">4u32</span>) , <span class="string">&quot;PARAM_EXT_VALUE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">322u32</span>) , <span class="string">&quot;AUTOPILOT_STATE_FOR_GIMBAL_DEVICE&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">286u32</span>) , <span class="string">&quot;AUTOPILOT_VERSION&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">148u32</span>) , <span class="string">&quot;NAV_CONTROLLER_OUTPUT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">62u32</span>) , <span class="string">&quot;MISSION_ITEM_REACHED&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">46u32</span>) , <span class="string">&quot;EFI_STATUS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">225u32</span>) , <span class="string">&quot;SET_MAG_OFFSETS&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">151u32</span>) , <span class="string">&quot;DEBUG_VECT&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">250u32</span>) , <span class="string">&quot;SYSTEM_TIME&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">2u32</span>) , <span class="string">&quot;CHANGE_OPERATOR_CONTROL_ACK&quot; </span>=&gt; <span class="prelude-val">Ok </span>(<span class="number">6u32</span>) , <span class="kw">_ </span>=&gt; { <span class="prelude-val">Err </span>(<span class="string">&quot;Invalid message name.&quot;</span>) } } } <span class="kw">fn </span>default_message_from_id (id : u32) -&gt; <span class="prelude-ty">Result </span>&lt; <span class="self">Self </span>, &amp; <span class="lifetime">&#39;static </span>str &gt; { <span class="kw">match </span>id { <span class="number">216u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GOPRO_GET_REQUEST (GOPRO_GET_REQUEST_DATA :: default ())) , <span class="number">247u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COLLISION (COLLISION_DATA :: default ())) , <span class="number">70u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RC_CHANNELS_OVERRIDE (RC_CHANNELS_OVERRIDE_DATA :: default ())) , <span class="number">55u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SAFETY_ALLOWED_AREA (SAFETY_ALLOWED_AREA_DATA :: default ())) , <span class="number">65u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RC_CHANNELS (RC_CHANNELS_DATA :: default ())) , <span class="number">173u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RANGEFINDER (RANGEFINDER_DATA :: default ())) , <span class="number">285u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_DEVICE_ATTITUDE_STATUS (GIMBAL_DEVICE_ATTITUDE_STATUS_DATA :: default ())) , <span class="number">33u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GLOBAL_POSITION_INT (GLOBAL_POSITION_INT_DATA :: default ())) , <span class="number">22u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_VALUE (PARAM_VALUE_DATA :: default ())) , <span class="number">410u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: EVENT (EVENT_DATA :: default ())) , <span class="number">26u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_IMU (SCALED_IMU_DATA :: default ())) , <span class="number">147u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: BATTERY_STATUS (BATTERY_STATUS_DATA :: default ())) , <span class="number">248u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: V2_EXTENSION (V2_EXTENSION_DATA :: default ())) , <span class="number">90u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_STATE (HIL_STATE_DATA :: default ())) , <span class="number">11020u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AOA_SSA (AOA_SSA_DATA :: default ())) , <span class="number">412u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: REQUEST_EVENT (REQUEST_EVENT_DATA :: default ())) , <span class="number">301u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AIS_VESSEL (AIS_VESSEL_DATA :: default ())) , <span class="number">254u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DEBUG (DEBUG_DATA :: default ())) , <span class="number">401u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SUPPORTED_TUNES (SUPPORTED_TUNES_DATA :: default ())) , <span class="number">154u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DIGICAM_CONFIGURE (DIGICAM_CONFIGURE_DATA :: default ())) , <span class="number">186u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LED_CONTROL (LED_CONTROL_DATA :: default ())) , <span class="number">320u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_EXT_REQUEST_READ (PARAM_EXT_REQUEST_READ_DATA :: default ())) , <span class="number">7u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AUTH_KEY (AUTH_KEY_DATA :: default ())) , <span class="number">390u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ONBOARD_COMPUTER_STATUS (ONBOARD_COMPUTER_STATUS_DATA :: default ())) , <span class="number">299u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: WIFI_CONFIG_AP (WIFI_CONFIG_AP_DATA :: default ())) , <span class="number">9000u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: WHEEL_DISTANCE (WHEEL_DISTANCE_DATA :: default ())) , <span class="number">252u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: NAMED_VALUE_INT (NAMED_VALUE_INT_DATA :: default ())) , <span class="number">258u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PLAY_TUNE (PLAY_TUNE_DATA :: default ())) , <span class="number">50u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_MAP_RC (PARAM_MAP_RC_DATA :: default ())) , <span class="number">123u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_INJECT_DATA (GPS_INJECT_DATA_DATA :: default ())) , <span class="number">387u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CANFD_FRAME (CANFD_FRAME_DATA :: default ())) , <span class="number">11010u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ADAP_TUNING (ADAP_TUNING_DATA :: default ())) , <span class="number">119u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_REQUEST_DATA (LOG_REQUEST_DATA_DATA :: default ())) , <span class="number">324u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_EXT_ACK (PARAM_EXT_ACK_DATA :: default ())) , <span class="number">241u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VIBRATION (VIBRATION_DATA :: default ())) , <span class="number">193u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: EKF_STATUS_REPORT (EKF_STATUS_REPORT_DATA :: default ())) , <span class="number">261u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: STORAGE_INFORMATION (STORAGE_INFORMATION_DATA :: default ())) , <span class="number">11000u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DEVICE_OP_READ (DEVICE_OP_READ_DATA :: default ())) , <span class="number">11035u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OSD_PARAM_SHOW_CONFIG (OSD_PARAM_SHOW_CONFIG_DATA :: default ())) , <span class="number">267u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOGGING_DATA_ACKED (LOGGING_DATA_ACKED_DATA :: default ())) , <span class="number">12920u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HYGROMETER_SENSOR (HYGROMETER_SENSOR_DATA :: default ())) , <span class="number">74u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VFR_HUD (VFR_HUD_DATA :: default ())) , <span class="number">10002u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC (UAVIONIX_ADSB_OUT_DYNAMIC_DATA :: default ())) , <span class="number">32u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOCAL_POSITION_NED (LOCAL_POSITION_NED_DATA :: default ())) , <span class="number">133u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TERRAIN_REQUEST (TERRAIN_REQUEST_DATA :: default ())) , <span class="number">260u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_SETTINGS (CAMERA_SETTINGS_DATA :: default ())) , <span class="number">160u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: FENCE_POINT (FENCE_POINT_DATA :: default ())) , <span class="number">106u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPTICAL_FLOW_RAD (OPTICAL_FLOW_RAD_DATA :: default ())) , <span class="number">115u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_STATE_QUATERNION (HIL_STATE_QUATERNION_DATA :: default ())) , <span class="number">137u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_PRESSURE2 (SCALED_PRESSURE2_DATA :: default ())) , <span class="number">5u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL (CHANGE_OPERATOR_CONTROL_DATA :: default ())) , <span class="number">177u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMPASSMOT_STATUS (COMPASSMOT_STATUS_DATA :: default ())) , <span class="number">12918u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_ARM_STATUS (OPEN_DRONE_ID_ARM_STATUS_DATA :: default ())) , <span class="number">268u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOGGING_ACK (LOGGING_ACK_DATA :: default ())) , <span class="number">282u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_MANAGER_SET_ATTITUDE (GIMBAL_MANAGER_SET_ATTITUDE_DATA :: default ())) , <span class="number">380u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TIME_ESTIMATE_TO_TARGET (TIME_ESTIMATE_TO_TARGET_DATA :: default ())) , <span class="number">11u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_MODE (SET_MODE_DATA :: default ())) , <span class="number">176u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RALLY_FETCH_POINT (RALLY_FETCH_POINT_DATA :: default ())) , <span class="number">80u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMMAND_CANCEL (COMMAND_CANCEL_DATA :: default ())) , <span class="number">66u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: REQUEST_DATA_STREAM (REQUEST_DATA_STREAM_DATA :: default ())) , <span class="number">21u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_REQUEST_LIST (PARAM_REQUEST_LIST_DATA :: default ())) , <span class="number">102u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VISION_POSITION_ESTIMATE (VISION_POSITION_ESTIMATE_DATA :: default ())) , <span class="number">263u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_IMAGE_CAPTURED (CAMERA_IMAGE_CAPTURED_DATA :: default ())) , <span class="number">144u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: FOLLOW_TARGET (FOLLOW_TARGET_DATA :: default ())) , <span class="number">0u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HEARTBEAT (HEARTBEAT_DATA :: default ())) , <span class="number">171u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DATA64 (DATA64_DATA :: default ())) , <span class="number">50002u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HERELINK_VIDEO_STREAM_INFORMATION (HERELINK_VIDEO_STREAM_INFORMATION_DATA :: default ())) , <span class="number">215u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GOPRO_HEARTBEAT (GOPRO_HEARTBEAT_DATA :: default ())) , <span class="number">34u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RC_CHANNELS_SCALED (RC_CHANNELS_SCALED_DATA :: default ())) , <span class="number">51u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_REQUEST_INT (MISSION_REQUEST_INT_DATA :: default ())) , <span class="number">386u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAN_FRAME (CAN_FRAME_DATA :: default ())) , <span class="number">113u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_GPS (HIL_GPS_DATA :: default ())) , <span class="number">373u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GENERATOR_STATUS (GENERATOR_STATUS_DATA :: default ())) , <span class="number">280u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_MANAGER_INFORMATION (GIMBAL_MANAGER_INFORMATION_DATA :: default ())) , <span class="number">135u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TERRAIN_CHECK (TERRAIN_CHECK_DATA :: default ())) , <span class="number">181u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: BATTERY2 (BATTERY2_DATA :: default ())) , <span class="number">271u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_FOV_STATUS (CAMERA_FOV_STATUS_DATA :: default ())) , <span class="number">20u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_REQUEST_READ (PARAM_REQUEST_READ_DATA :: default ())) , <span class="number">38u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_WRITE_PARTIAL_LIST (MISSION_WRITE_PARTIAL_LIST_DATA :: default ())) , <span class="number">10001u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG (UAVIONIX_ADSB_OUT_CFG_DATA :: default ())) , <span class="number">259u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_INFORMATION (CAMERA_INFORMATION_DATA :: default ())) , <span class="number">11038u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: WATER_DEPTH (WATER_DEPTH_DATA :: default ())) , <span class="number">67u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DATA_STREAM (DATA_STREAM_DATA :: default ())) , <span class="number">76u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMMAND_LONG (COMMAND_LONG_DATA :: default ())) , <span class="number">256u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SETUP_SIGNING (SETUP_SIGNING_DATA :: default ())) , <span class="number">91u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_CONTROLS (HIL_CONTROLS_DATA :: default ())) , <span class="number">184u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: REMOTE_LOG_DATA_BLOCK (REMOTE_LOG_DATA_BLOCK_DATA :: default ())) , <span class="number">105u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIGHRES_IMU (HIGHRES_IMU_DATA :: default ())) , <span class="number">360u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ORBIT_EXECUTION_STATUS (ORBIT_EXECUTION_STATUS_DATA :: default ())) , <span class="number">116u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_IMU2 (SCALED_IMU2_DATA :: default ())) , <span class="number">156u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MOUNT_CONFIGURE (MOUNT_CONFIGURE_DATA :: default ())) , <span class="number">69u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MANUAL_CONTROL (MANUAL_CONTROL_DATA :: default ())) , <span class="number">54u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SAFETY_SET_ALLOWED_AREA (SAFETY_SET_ALLOWED_AREA_DATA :: default ())) , <span class="number">165u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HWSTATUS (HWSTATUS_DATA :: default ())) , <span class="number">183u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AUTOPILOT_VERSION_REQUEST (AUTOPILOT_VERSION_REQUEST_DATA :: default ())) , <span class="number">10003u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT (UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT_DATA :: default ())) , <span class="number">117u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_REQUEST_LIST (LOG_REQUEST_LIST_DATA :: default ())) , <span class="number">128u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS2_RTK (GPS2_RTK_DATA :: default ())) , <span class="number">231u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: WIND_COV (WIND_COV_DATA :: default ())) , <span class="number">11001u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DEVICE_OP_READ_REPLY (DEVICE_OP_READ_REPLY_DATA :: default ())) , <span class="number">132u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DISTANCE_SENSOR (DISTANCE_SENSOR_DATA :: default ())) , <span class="number">126u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SERIAL_CONTROL (SERIAL_CONTROL_DATA :: default ())) , <span class="number">121u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_ERASE (LOG_ERASE_DATA :: default ())) , <span class="number">100u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPTICAL_FLOW (OPTICAL_FLOW_DATA :: default ())) , <span class="number">131u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ENCAPSULATED_DATA (ENCAPSULATED_DATA_DATA :: default ())) , <span class="number">118u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_ENTRY (LOG_ENTRY_DATA :: default ())) , <span class="number">235u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIGH_LATENCY2 (HIGH_LATENCY2_DATA :: default ())) , <span class="number">335u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ISBD_LINK_STATUS (ISBD_LINK_STATUS_DATA :: default ())) , <span class="number">413u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RESPONSE_EVENT_ERROR (RESPONSE_EVENT_ERROR_DATA :: default ())) , <span class="number">230u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ESTIMATOR_STATUS (ESTIMATOR_STATUS_DATA :: default ())) , <span class="number">11039u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MCU_STATUS (MCU_STATUS_DATA :: default ())) , <span class="number">35u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RC_CHANNELS_RAW (RC_CHANNELS_RAW_DATA :: default ())) , <span class="number">130u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DATA_TRANSMISSION_HANDSHAKE (DATA_TRANSMISSION_HANDSHAKE_DATA :: default ())) , <span class="number">262u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_CAPTURE_STATUS (CAMERA_CAPTURE_STATUS_DATA :: default ())) , <span class="number">339u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RAW_RPM (RAW_RPM_DATA :: default ())) , <span class="number">233u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_RTCM_DATA (GPS_RTCM_DATA_DATA :: default ())) , <span class="number">64u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOCAL_POSITION_NED_COV (LOCAL_POSITION_NED_COV_DATA :: default ())) , <span class="number">217u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GOPRO_GET_RESPONSE (GOPRO_GET_RESPONSE_DATA :: default ())) , <span class="number">12903u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_SELF_ID (OPEN_DRONE_ID_SELF_ID_DATA :: default ())) , <span class="number">11032u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ESC_TELEMETRY_9_TO_12 (ESC_TELEMETRY_9_TO_12_DATA :: default ())) , <span class="number">125u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: POWER_STATUS (POWER_STATUS_DATA :: default ())) , <span class="number">110u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: FILE_TRANSFER_PROTOCOL (FILE_TRANSFER_PROTOCOL_DATA :: default ())) , <span class="number">127u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_RTK (GPS_RTK_DATA :: default ())) , <span class="number">45u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_CLEAR_ALL (MISSION_CLEAR_ALL_DATA :: default ())) , <span class="number">40u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_REQUEST (MISSION_REQUEST_DATA :: default ())) , <span class="number">12902u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_AUTHENTICATION (OPEN_DRONE_ID_AUTHENTICATION_DATA :: default ())) , <span class="number">161u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: FENCE_FETCH_POINT (FENCE_FETCH_POINT_DATA :: default ())) , <span class="number">218u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GOPRO_SET_REQUEST (GOPRO_SET_REQUEST_DATA :: default ())) , <span class="number">93u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_ACTUATOR_CONTROLS (HIL_ACTUATOR_CONTROLS_DATA :: default ())) , <span class="number">11037u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OBSTACLE_DISTANCE_3D (OBSTACLE_DISTANCE_3D_DATA :: default ())) , <span class="number">138u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ATT_POS_MOCAP (ATT_POS_MOCAP_DATA :: default ())) , <span class="number">12919u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM_UPDATE (OPEN_DRONE_ID_SYSTEM_UPDATE_DATA :: default ())) , <span class="number">86u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_POSITION_TARGET_GLOBAL_INT (SET_POSITION_TARGET_GLOBAL_INT_DATA :: default ())) , <span class="number">142u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RESOURCE_REQUEST (RESOURCE_REQUEST_DATA :: default ())) , <span class="number">192u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MAG_CAL_REPORT (MAG_CAL_REPORT_DATA :: default ())) , <span class="number">92u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_RC_INPUTS_RAW (HIL_RC_INPUTS_RAW_DATA :: default ())) , <span class="number">37u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_REQUEST_PARTIAL_LIST (MISSION_REQUEST_PARTIAL_LIST_DATA :: default ())) , <span class="number">242u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HOME_POSITION (HOME_POSITION_DATA :: default ())) , <span class="number">28u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RAW_PRESSURE (RAW_PRESSURE_DATA :: default ())) , <span class="number">155u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DIGICAM_CONTROL (DIGICAM_CONTROL_DATA :: default ())) , <span class="number">42u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_CURRENT (MISSION_CURRENT_DATA :: default ())) , <span class="number">11030u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ESC_TELEMETRY_1_TO_4 (ESC_TELEMETRY_1_TO_4_DATA :: default ())) , <span class="number">12901u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_LOCATION (OPEN_DRONE_ID_LOCATION_DATA :: default ())) , <span class="number">191u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MAG_CAL_PROGRESS (MAG_CAL_PROGRESS_DATA :: default ())) , <span class="number">397u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMPONENT_METADATA (COMPONENT_METADATA_DATA :: default ())) , <span class="number">340u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UTM_GLOBAL_POSITION (UTM_GLOBAL_POSITION_DATA :: default ())) , <span class="number">85u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: POSITION_TARGET_LOCAL_NED (POSITION_TARGET_LOCAL_NED_DATA :: default ())) , <span class="number">284u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_DEVICE_SET_ATTITUDE (GIMBAL_DEVICE_SET_ATTITUDE_DATA :: default ())) , <span class="number">11011u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VISION_POSITION_DELTA (VISION_POSITION_DELTA_DATA :: default ())) , <span class="number">234u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIGH_LATENCY (HIGH_LATENCY_DATA :: default ())) , <span class="number">136u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TERRAIN_REPORT (TERRAIN_REPORT_DATA :: default ())) , <span class="number">73u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_ITEM_INT (MISSION_ITEM_INT_DATA :: default ())) , <span class="number">195u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DEEPSTALL (DEEPSTALL_DATA :: default ())) , <span class="number">112u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_TRIGGER (CAMERA_TRIGGER_DATA :: default ())) , <span class="number">249u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MEMORY_VECT (MEMORY_VECT_DATA :: default ())) , <span class="number">167u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LIMITS_STATUS (LIMITS_STATUS_DATA :: default ())) , <span class="number">11036u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OSD_PARAM_SHOW_CONFIG_REPLY (OSD_PARAM_SHOW_CONFIG_REPLY_DATA :: default ())) , <span class="number">185u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: REMOTE_LOG_BLOCK_STATUS (REMOTE_LOG_BLOCK_STATUS_DATA :: default ())) , <span class="number">11003u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DEVICE_OP_WRITE_REPLY (DEVICE_OP_WRITE_REPLY_DATA :: default ())) , <span class="number">149u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LANDING_TARGET (LANDING_TARGET_DATA :: default ())) , <span class="number">200u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_REPORT (GIMBAL_REPORT_DATA :: default ())) , <span class="number">275u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_TRACKING_IMAGE_STATUS (CAMERA_TRACKING_IMAGE_STATUS_DATA :: default ())) , <span class="number">61u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ATTITUDE_QUATERNION_COV (ATTITUDE_QUATERNION_COV_DATA :: default ())) , <span class="number">175u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RALLY_POINT (RALLY_POINT_DATA :: default ())) , <span class="number">143u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_PRESSURE3 (SCALED_PRESSURE3_DATA :: default ())) , <span class="number">108u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SIM_STATE (SIM_STATE_DATA :: default ())) , <span class="number">375u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ACTUATOR_OUTPUT_STATUS (ACTUATOR_OUTPUT_STATUS_DATA :: default ())) , <span class="number">12915u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_MESSAGE_PACK (OPEN_DRONE_ID_MESSAGE_PACK_DATA :: default ())) , <span class="number">103u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VISION_SPEED_ESTIMATE (VISION_SPEED_ESTIMATE_DATA :: default ())) , <span class="number">12900u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_BASIC_ID (OPEN_DRONE_ID_BASIC_ID_DATA :: default ())) , <span class="number">385u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TUNNEL (TUNNEL_DATA :: default ())) , <span class="number">87u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: POSITION_TARGET_GLOBAL_INT (POSITION_TARGET_GLOBAL_INT_DATA :: default ())) , <span class="number">150u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SENSOR_OFFSETS (SENSOR_OFFSETS_DATA :: default ())) , <span class="number">311u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UAVCAN_NODE_INFO (UAVCAN_NODE_INFO_DATA :: default ())) , <span class="number">264u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: FLIGHT_INFORMATION (FLIGHT_INFORMATION_DATA :: default ())) , <span class="number">166u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RADIO (RADIO_DATA :: default ())) , <span class="number">170u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DATA32 (DATA32_DATA :: default ())) , <span class="number">50001u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CUBEPILOT_RAW_RC (CUBEPILOT_RAW_RC_DATA :: default ())) , <span class="number">129u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_IMU3 (SCALED_IMU3_DATA :: default ())) , <span class="number">288u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_MANAGER_SET_MANUAL_CONTROL (GIMBAL_MANAGER_SET_MANUAL_CONTROL_DATA :: default ())) , <span class="number">283u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_DEVICE_INFORMATION (GIMBAL_DEVICE_INFORMATION_DATA :: default ())) , <span class="number">134u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TERRAIN_DATA (TERRAIN_DATA_DATA :: default ())) , <span class="number">140u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ACTUATOR_CONTROL_TARGET (ACTUATOR_CONTROL_TARGET_DATA :: default ())) , <span class="number">8u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LINK_NODE_STATUS (LINK_NODE_STATUS_DATA :: default ())) , <span class="number">291u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ESC_STATUS (ESC_STATUS_DATA :: default ())) , <span class="number">253u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: STATUSTEXT (STATUSTEXT_DATA :: default ())) , <span class="number">82u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_ATTITUDE_TARGET (SET_ATTITUDE_TARGET_DATA :: default ())) , <span class="number">141u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ALTITUDE (ALTITUDE_DATA :: default ())) , <span class="number">49u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_GLOBAL_ORIGIN (GPS_GLOBAL_ORIGIN_DATA :: default ())) , <span class="number">270u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VIDEO_STREAM_STATUS (VIDEO_STREAM_STATUS_DATA :: default ())) , <span class="number">146u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CONTROL_SYSTEM_STATE (CONTROL_SYSTEM_STATE_DATA :: default ())) , <span class="number">50004u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CUBEPILOT_FIRMWARE_UPDATE_START (CUBEPILOT_FIRMWARE_UPDATE_START_DATA :: default ())) , <span class="number">43u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_REQUEST_LIST (MISSION_REQUEST_LIST_DATA :: default ())) , <span class="number">182u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AHRS3 (AHRS3_DATA :: default ())) , <span class="number">11002u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DEVICE_OP_WRITE (DEVICE_OP_WRITE_DATA :: default ())) , <span class="number">11031u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ESC_TELEMETRY_5_TO_8 (ESC_TELEMETRY_5_TO_8_DATA :: default ())) , <span class="number">81u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MANUAL_SETPOINT (MANUAL_SETPOINT_DATA :: default ())) , <span class="number">310u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: UAVCAN_NODE_STATUS (UAVCAN_NODE_STATUS_DATA :: default ())) , <span class="number">323u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_EXT_SET (PARAM_EXT_SET_DATA :: default ())) , <span class="number">158u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MOUNT_STATUS (MOUNT_STATUS_DATA :: default ())) , <span class="number">174u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AIRSPEED_AUTOCAL (AIRSPEED_AUTOCAL_DATA :: default ())) , <span class="number">29u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SCALED_PRESSURE (SCALED_PRESSURE_DATA :: default ())) , <span class="number">334u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CELLULAR_STATUS (CELLULAR_STATUS_DATA :: default ())) , <span class="number">1u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SYS_STATUS (SYS_STATUS_DATA :: default ())) , <span class="number">333u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_BEZIER (TRAJECTORY_REPRESENTATION_BEZIER_DATA :: default ())) , <span class="number">111u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TIMESYNC (TIMESYNC_DATA :: default ())) , <span class="number">157u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MOUNT_CONTROL (MOUNT_CONTROL_DATA :: default ())) , <span class="number">180u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_FEEDBACK (CAMERA_FEEDBACK_DATA :: default ())) , <span class="number">257u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: BUTTON_CHANGE (BUTTON_CHANGE_DATA :: default ())) , <span class="number">179u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_STATUS (CAMERA_STATUS_DATA :: default ())) , <span class="number">84u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_POSITION_TARGET_LOCAL_NED (SET_POSITION_TARGET_LOCAL_NED_DATA :: default ())) , <span class="number">331u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ODOMETRY (ODOMETRY_DATA :: default ())) , <span class="number">24u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_RAW_INT (GPS_RAW_INT_DATA :: default ())) , <span class="number">214u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_TORQUE_CMD_REPORT (GIMBAL_TORQUE_CMD_REPORT_DATA :: default ())) , <span class="number">11033u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OSD_PARAM_CONFIG (OSD_PARAM_CONFIG_DATA :: default ())) , <span class="number">169u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DATA16 (DATA16_DATA :: default ())) , <span class="number">194u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PID_TUNING (PID_TUNING_DATA :: default ())) , <span class="number">330u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OBSTACLE_DISTANCE (OBSTACLE_DISTANCE_DATA :: default ())) , <span class="number">75u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMMAND_INT (COMMAND_INT_DATA :: default ())) , <span class="number">77u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMMAND_ACK (COMMAND_ACK_DATA :: default ())) , <span class="number">42000u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ICAROUS_HEARTBEAT (ICAROUS_HEARTBEAT_DATA :: default ())) , <span class="number">41u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_SET_CURRENT (MISSION_SET_CURRENT_DATA :: default ())) , <span class="number">332u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_WAYPOINTS (TRAJECTORY_REPRESENTATION_WAYPOINTS_DATA :: default ())) , <span class="number">9005u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: WINCH_STATUS (WINCH_STATUS_DATA :: default ())) , <span class="number">321u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_EXT_REQUEST_LIST (PARAM_EXT_REQUEST_LIST_DATA :: default ())) , <span class="number">42001u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ICAROUS_KINEMATIC_BANDS (ICAROUS_KINEMATIC_BANDS_DATA :: default ())) , <span class="number">50005u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CUBEPILOT_FIRMWARE_UPDATE_RESP (CUBEPILOT_FIRMWARE_UPDATE_RESP_DATA :: default ())) , <span class="number">163u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AHRS (AHRS_DATA :: default ())) , <span class="number">388u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAN_FILTER_MODIFY (CAN_FILTER_MODIFY_DATA :: default ())) , <span class="number">243u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_HOME_POSITION (SET_HOME_POSITION_DATA :: default ())) , <span class="number">25u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_STATUS (GPS_STATUS_DATA :: default ())) , <span class="number">27u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RAW_IMU (RAW_IMU_DATA :: default ())) , <span class="number">219u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GOPRO_SET_RESPONSE (GOPRO_SET_RESPONSE_DATA :: default ())) , <span class="number">266u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOGGING_DATA (LOGGING_DATA_DATA :: default ())) , <span class="number">164u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SIMSTATE (SIMSTATE_DATA :: default ())) , <span class="number">31u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ATTITUDE_QUATERNION (ATTITUDE_QUATERNION_DATA :: default ())) , <span class="number">114u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_OPTICAL_FLOW (HIL_OPTICAL_FLOW_DATA :: default ())) , <span class="number">226u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RPM (RPM_DATA :: default ())) , <span class="number">11034u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OSD_PARAM_CONFIG_REPLY (OSD_PARAM_CONFIG_REPLY_DATA :: default ())) , <span class="number">300u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PROTOCOL_VERSION (PROTOCOL_VERSION_DATA :: default ())) , <span class="number">83u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ATTITUDE_TARGET (ATTITUDE_TARGET_DATA :: default ())) , <span class="number">23u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_SET (PARAM_SET_DATA :: default ())) , <span class="number">178u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AHRS2 (AHRS2_DATA :: default ())) , <span class="number">168u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: WIND (WIND_DATA :: default ())) , <span class="number">104u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VICON_POSITION_ESTIMATE (VICON_POSITION_ESTIMATE_DATA :: default ())) , <span class="number">44u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_COUNT (MISSION_COUNT_DATA :: default ())) , <span class="number">89u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET (LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET_DATA :: default ())) , <span class="number">251u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: NAMED_VALUE_FLOAT (NAMED_VALUE_FLOAT_DATA :: default ())) , <span class="number">400u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PLAY_TUNE_V2 (PLAY_TUNE_V2_DATA :: default ())) , <span class="number">152u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MEMINFO (MEMINFO_DATA :: default ())) , <span class="number">172u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DATA96 (DATA96_DATA :: default ())) , <span class="number">201u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_CONTROL (GIMBAL_CONTROL_DATA :: default ())) , <span class="number">120u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_DATA (LOG_DATA_DATA :: default ())) , <span class="number">48u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_GPS_GLOBAL_ORIGIN (SET_GPS_GLOBAL_ORIGIN_DATA :: default ())) , <span class="number">265u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MOUNT_ORIENTATION (MOUNT_ORIENTATION_DATA :: default ())) , <span class="number">124u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS2_RAW (GPS2_RAW_DATA :: default ())) , <span class="number">101u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GLOBAL_VISION_POSITION_ESTIMATE (GLOBAL_VISION_POSITION_ESTIMATE_DATA :: default ())) , <span class="number">50003u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HERELINK_TELEM (HERELINK_TELEM_DATA :: default ())) , <span class="number">276u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CAMERA_TRACKING_GEO_STATUS (CAMERA_TRACKING_GEO_STATUS_DATA :: default ())) , <span class="number">411u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CURRENT_EVENT_SEQUENCE (CURRENT_EVENT_SEQUENCE_DATA :: default ())) , <span class="number">244u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MESSAGE_INTERVAL (MESSAGE_INTERVAL_DATA :: default ())) , <span class="number">39u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_ITEM (MISSION_ITEM_DATA :: default ())) , <span class="number">109u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: RADIO_STATUS (RADIO_STATUS_DATA :: default ())) , <span class="number">162u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: FENCE_STATUS (FENCE_STATUS_DATA :: default ())) , <span class="number">107u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: HIL_SENSOR (HIL_SENSOR_DATA :: default ())) , <span class="number">47u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_ACK (MISSION_ACK_DATA :: default ())) , <span class="number">63u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GLOBAL_POSITION_INT_COV (GLOBAL_POSITION_INT_COV_DATA :: default ())) , <span class="number">336u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CELLULAR_CONFIG (CELLULAR_CONFIG_DATA :: default ())) , <span class="number">269u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: VIDEO_STREAM_INFORMATION (VIDEO_STREAM_INFORMATION_DATA :: default ())) , <span class="number">246u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ADSB_VEHICLE (ADSB_VEHICLE_DATA :: default ())) , <span class="number">12904u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM (OPEN_DRONE_ID_SYSTEM_DATA :: default ())) , <span class="number">232u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GPS_INPUT (GPS_INPUT_DATA :: default ())) , <span class="number">281u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_MANAGER_STATUS (GIMBAL_MANAGER_STATUS_DATA :: default ())) , <span class="number">245u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: EXTENDED_SYS_STATE (EXTENDED_SYS_STATE_DATA :: default ())) , <span class="number">12905u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: OPEN_DRONE_ID_OPERATOR_ID (OPEN_DRONE_ID_OPERATOR_ID_DATA :: default ())) , <span class="number">139u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_ACTUATOR_CONTROL_TARGET (SET_ACTUATOR_CONTROL_TARGET_DATA :: default ())) , <span class="number">350u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DEBUG_FLOAT_ARRAY (DEBUG_FLOAT_ARRAY_DATA :: default ())) , <span class="number">153u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AP_ADC (AP_ADC_DATA :: default ())) , <span class="number">370u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SMART_BATTERY_INFO (SMART_BATTERY_INFO_DATA :: default ())) , <span class="number">122u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: LOG_REQUEST_END (LOG_REQUEST_END_DATA :: default ())) , <span class="number">287u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: GIMBAL_MANAGER_SET_PITCHYAW (GIMBAL_MANAGER_SET_PITCHYAW_DATA :: default ())) , <span class="number">395u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: COMPONENT_INFORMATION (COMPONENT_INFORMATION_DATA :: default ())) , <span class="number">36u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SERVO_OUTPUT_RAW (SERVO_OUTPUT_RAW_DATA :: default ())) , <span class="number">30u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ATTITUDE (ATTITUDE_DATA :: default ())) , <span class="number">290u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: ESC_INFO (ESC_INFO_DATA :: default ())) , <span class="number">4u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PING (PING_DATA :: default ())) , <span class="number">322u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: PARAM_EXT_VALUE (PARAM_EXT_VALUE_DATA :: default ())) , <span class="number">286u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AUTOPILOT_STATE_FOR_GIMBAL_DEVICE (AUTOPILOT_STATE_FOR_GIMBAL_DEVICE_DATA :: default ())) , <span class="number">148u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: AUTOPILOT_VERSION (AUTOPILOT_VERSION_DATA :: default ())) , <span class="number">62u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: NAV_CONTROLLER_OUTPUT (NAV_CONTROLLER_OUTPUT_DATA :: default ())) , <span class="number">46u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: MISSION_ITEM_REACHED (MISSION_ITEM_REACHED_DATA :: default ())) , <span class="number">225u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: EFI_STATUS (EFI_STATUS_DATA :: default ())) , <span class="number">151u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SET_MAG_OFFSETS (SET_MAG_OFFSETS_DATA :: default ())) , <span class="number">250u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: DEBUG_VECT (DEBUG_VECT_DATA :: default ())) , <span class="number">2u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: SYSTEM_TIME (SYSTEM_TIME_DATA :: default ())) , <span class="number">6u32 </span>=&gt; <span class="prelude-val">Ok </span>(<span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL_ACK (CHANGE_OPERATOR_CONTROL_ACK_DATA :: default ())) , <span class="kw">_ </span>=&gt; { <span class="prelude-val">Err </span>(<span class="string">&quot;Invalid message id.&quot;</span>) } } } <span class="kw">fn </span>ser (&amp; <span class="self">self </span>, version : MavlinkVersion , bytes : &amp; <span class="kw-2">mut </span>[u8]) -&gt; usize { <span class="kw">match </span><span class="self">self </span>{ <span class="self">Self </span>:: GOPRO_GET_REQUEST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COLLISION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RC_CHANNELS_OVERRIDE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SAFETY_ALLOWED_AREA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RC_CHANNELS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RANGEFINDER (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_DEVICE_ATTITUDE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GLOBAL_POSITION_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_VALUE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: EVENT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_IMU (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: BATTERY_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: V2_EXTENSION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_STATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AOA_SSA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: REQUEST_EVENT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AIS_VESSEL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DEBUG (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SUPPORTED_TUNES (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DIGICAM_CONFIGURE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LED_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_EXT_REQUEST_READ (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AUTH_KEY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ONBOARD_COMPUTER_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: WIFI_CONFIG_AP (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: WHEEL_DISTANCE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: NAMED_VALUE_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PLAY_TUNE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_MAP_RC (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_INJECT_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CANFD_FRAME (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ADAP_TUNING (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_REQUEST_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_EXT_ACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VIBRATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: EKF_STATUS_REPORT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: STORAGE_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DEVICE_OP_READ (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OSD_PARAM_SHOW_CONFIG (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOGGING_DATA_ACKED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HYGROMETER_SENSOR (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VFR_HUD (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_DYNAMIC (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOCAL_POSITION_NED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TERRAIN_REQUEST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_SETTINGS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: FENCE_POINT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPTICAL_FLOW_RAD (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_STATE_QUATERNION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_PRESSURE2 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMPASSMOT_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_ARM_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOGGING_ACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_MANAGER_SET_ATTITUDE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TIME_ESTIMATE_TO_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_MODE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RALLY_FETCH_POINT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMMAND_CANCEL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: REQUEST_DATA_STREAM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_REQUEST_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VISION_POSITION_ESTIMATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_IMAGE_CAPTURED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: FOLLOW_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HEARTBEAT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DATA64 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HERELINK_VIDEO_STREAM_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GOPRO_HEARTBEAT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RC_CHANNELS_SCALED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_REQUEST_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAN_FRAME (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_GPS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GENERATOR_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_MANAGER_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TERRAIN_CHECK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: BATTERY2 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_FOV_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_REQUEST_READ (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_WRITE_PARTIAL_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: UAVIONIX_ADSB_OUT_CFG (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: WATER_DEPTH (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DATA_STREAM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMMAND_LONG (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SETUP_SIGNING (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_CONTROLS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: REMOTE_LOG_DATA_BLOCK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIGHRES_IMU (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ORBIT_EXECUTION_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_IMU2 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MOUNT_CONFIGURE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MANUAL_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SAFETY_SET_ALLOWED_AREA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HWSTATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AUTOPILOT_VERSION_REQUEST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: UAVIONIX_ADSB_TRANSCEIVER_HEALTH_REPORT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_REQUEST_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS2_RTK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: WIND_COV (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DEVICE_OP_READ_REPLY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DISTANCE_SENSOR (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SERIAL_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_ERASE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPTICAL_FLOW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ENCAPSULATED_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_ENTRY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIGH_LATENCY2 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ISBD_LINK_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RESPONSE_EVENT_ERROR (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ESTIMATOR_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MCU_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RC_CHANNELS_RAW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DATA_TRANSMISSION_HANDSHAKE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_CAPTURE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RAW_RPM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_RTCM_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOCAL_POSITION_NED_COV (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GOPRO_GET_RESPONSE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_SELF_ID (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ESC_TELEMETRY_9_TO_12 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: POWER_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: FILE_TRANSFER_PROTOCOL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_RTK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_CLEAR_ALL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_REQUEST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_AUTHENTICATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: FENCE_FETCH_POINT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GOPRO_SET_REQUEST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_ACTUATOR_CONTROLS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OBSTACLE_DISTANCE_3D (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ATT_POS_MOCAP (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM_UPDATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_POSITION_TARGET_GLOBAL_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RESOURCE_REQUEST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MAG_CAL_REPORT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_RC_INPUTS_RAW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_REQUEST_PARTIAL_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HOME_POSITION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RAW_PRESSURE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DIGICAM_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_CURRENT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ESC_TELEMETRY_1_TO_4 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_LOCATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MAG_CAL_PROGRESS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMPONENT_METADATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: UTM_GLOBAL_POSITION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: POSITION_TARGET_LOCAL_NED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_DEVICE_SET_ATTITUDE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VISION_POSITION_DELTA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIGH_LATENCY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TERRAIN_REPORT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_ITEM_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DEEPSTALL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_TRIGGER (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MEMORY_VECT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LIMITS_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OSD_PARAM_SHOW_CONFIG_REPLY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: REMOTE_LOG_BLOCK_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DEVICE_OP_WRITE_REPLY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LANDING_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_REPORT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_TRACKING_IMAGE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ATTITUDE_QUATERNION_COV (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RALLY_POINT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_PRESSURE3 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SIM_STATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ACTUATOR_OUTPUT_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_MESSAGE_PACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VISION_SPEED_ESTIMATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_BASIC_ID (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TUNNEL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: POSITION_TARGET_GLOBAL_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SENSOR_OFFSETS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: UAVCAN_NODE_INFO (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: FLIGHT_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RADIO (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DATA32 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CUBEPILOT_RAW_RC (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_IMU3 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_MANAGER_SET_MANUAL_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_DEVICE_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TERRAIN_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ACTUATOR_CONTROL_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LINK_NODE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ESC_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: STATUSTEXT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_ATTITUDE_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ALTITUDE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_GLOBAL_ORIGIN (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VIDEO_STREAM_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CONTROL_SYSTEM_STATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CUBEPILOT_FIRMWARE_UPDATE_START (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_REQUEST_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AHRS3 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DEVICE_OP_WRITE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ESC_TELEMETRY_5_TO_8 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MANUAL_SETPOINT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: UAVCAN_NODE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_EXT_SET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MOUNT_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AIRSPEED_AUTOCAL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SCALED_PRESSURE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CELLULAR_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SYS_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_BEZIER (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TIMESYNC (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MOUNT_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_FEEDBACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: BUTTON_CHANGE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_POSITION_TARGET_LOCAL_NED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ODOMETRY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_RAW_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_TORQUE_CMD_REPORT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OSD_PARAM_CONFIG (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DATA16 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PID_TUNING (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OBSTACLE_DISTANCE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMMAND_INT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMMAND_ACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ICAROUS_HEARTBEAT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_SET_CURRENT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: TRAJECTORY_REPRESENTATION_WAYPOINTS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: WINCH_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_EXT_REQUEST_LIST (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ICAROUS_KINEMATIC_BANDS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CUBEPILOT_FIRMWARE_UPDATE_RESP (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AHRS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAN_FILTER_MODIFY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_HOME_POSITION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RAW_IMU (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GOPRO_SET_RESPONSE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOGGING_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SIMSTATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ATTITUDE_QUATERNION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_OPTICAL_FLOW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RPM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OSD_PARAM_CONFIG_REPLY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PROTOCOL_VERSION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ATTITUDE_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_SET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AHRS2 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: WIND (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VICON_POSITION_ESTIMATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_COUNT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: NAMED_VALUE_FLOAT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PLAY_TUNE_V2 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MEMINFO (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DATA96 (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_CONTROL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_DATA (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_GPS_GLOBAL_ORIGIN (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MOUNT_ORIENTATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS2_RAW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GLOBAL_VISION_POSITION_ESTIMATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HERELINK_TELEM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CAMERA_TRACKING_GEO_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CURRENT_EVENT_SEQUENCE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MESSAGE_INTERVAL (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_ITEM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: RADIO_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: FENCE_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: HIL_SENSOR (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_ACK (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GLOBAL_POSITION_INT_COV (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CELLULAR_CONFIG (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: VIDEO_STREAM_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ADSB_VEHICLE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_SYSTEM (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GPS_INPUT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_MANAGER_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: EXTENDED_SYS_STATE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: OPEN_DRONE_ID_OPERATOR_ID (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_ACTUATOR_CONTROL_TARGET (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DEBUG_FLOAT_ARRAY (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AP_ADC (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SMART_BATTERY_INFO (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: LOG_REQUEST_END (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: GIMBAL_MANAGER_SET_PITCHYAW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: COMPONENT_INFORMATION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SERVO_OUTPUT_RAW (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ATTITUDE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: ESC_INFO (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PING (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: PARAM_EXT_VALUE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AUTOPILOT_STATE_FOR_GIMBAL_DEVICE (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: AUTOPILOT_VERSION (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: NAV_CONTROLLER_OUTPUT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: MISSION_ITEM_REACHED (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: EFI_STATUS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SET_MAG_OFFSETS (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: DEBUG_VECT (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: SYSTEM_TIME (body) =&gt; body . ser (version , bytes) , <span class="self">Self </span>:: CHANGE_OPERATOR_CONTROL_ACK (body) =&gt; body . ser (version , bytes) , } } <span class="kw">fn </span>extra_crc (id : u32) -&gt; u8 { <span class="kw">match </span>id { <span class="number">216u32 </span>=&gt; <span class="number">50u8 </span>, <span class="number">247u32 </span>=&gt; <span class="number">81u8 </span>, <span class="number">70u32 </span>=&gt; <span class="number">124u8 </span>, <span class="number">55u32 </span>=&gt; <span class="number">3u8 </span>, <span class="number">65u32 </span>=&gt; <span class="number">118u8 </span>, <span class="number">173u32 </span>=&gt; <span class="number">83u8 </span>, <span class="number">285u32 </span>=&gt; <span class="number">137u8 </span>, <span class="number">33u32 </span>=&gt; <span class="number">104u8 </span>, <span class="number">22u32 </span>=&gt; <span class="number">220u8 </span>, <span class="number">410u32 </span>=&gt; <span class="number">160u8 </span>, <span class="number">26u32 </span>=&gt; <span class="number">170u8 </span>, <span class="number">147u32 </span>=&gt; <span class="number">154u8 </span>, <span class="number">248u32 </span>=&gt; <span class="number">8u8 </span>, <span class="number">90u32 </span>=&gt; <span class="number">183u8 </span>, <span class="number">11020u32 </span>=&gt; <span class="number">205u8 </span>, <span class="number">412u32 </span>=&gt; <span class="number">33u8 </span>, <span class="number">301u32 </span>=&gt; <span class="number">243u8 </span>, <span class="number">254u32 </span>=&gt; <span class="number">46u8 </span>, <span class="number">401u32 </span>=&gt; <span class="number">183u8 </span>, <span class="number">154u32 </span>=&gt; <span class="number">84u8 </span>, <span class="number">186u32 </span>=&gt; <span class="number">72u8 </span>, <span class="number">320u32 </span>=&gt; <span class="number">243u8 </span>, <span class="number">7u32 </span>=&gt; <span class="number">119u8 </span>, <span class="number">390u32 </span>=&gt; <span class="number">156u8 </span>, <span class="number">299u32 </span>=&gt; <span class="number">19u8 </span>, <span class="number">9000u32 </span>=&gt; <span class="number">113u8 </span>, <span class="number">252u32 </span>=&gt; <span class="number">44u8 </span>, <span class="number">258u32 </span>=&gt; <span class="number">187u8 </span>, <span class="number">50u32 </span>=&gt; <span class="number">78u8 </span>, <span class="number">123u32 </span>=&gt; <span class="number">250u8 </span>, <span class="number">387u32 </span>=&gt; <span class="number">4u8 </span>, <span class="number">11010u32 </span>=&gt; <span class="number">46u8 </span>, <span class="number">119u32 </span>=&gt; <span class="number">116u8 </span>, <span class="number">324u32 </span>=&gt; <span class="number">132u8 </span>, <span class="number">241u32 </span>=&gt; <span class="number">90u8 </span>, <span class="number">193u32 </span>=&gt; <span class="number">71u8 </span>, <span class="number">261u32 </span>=&gt; <span class="number">179u8 </span>, <span class="number">11000u32 </span>=&gt; <span class="number">134u8 </span>, <span class="number">11035u32 </span>=&gt; <span class="number">128u8 </span>, <span class="number">267u32 </span>=&gt; <span class="number">35u8 </span>, <span class="number">12920u32 </span>=&gt; <span class="number">20u8 </span>, <span class="number">74u32 </span>=&gt; <span class="number">20u8 </span>, <span class="number">10002u32 </span>=&gt; <span class="number">186u8 </span>, <span class="number">32u32 </span>=&gt; <span class="number">185u8 </span>, <span class="number">133u32 </span>=&gt; <span class="number">6u8 </span>, <span class="number">260u32 </span>=&gt; <span class="number">146u8 </span>, <span class="number">160u32 </span>=&gt; <span class="number">78u8 </span>, <span class="number">106u32 </span>=&gt; <span class="number">138u8 </span>, <span class="number">115u32 </span>=&gt; <span class="number">4u8 </span>, <span class="number">137u32 </span>=&gt; <span class="number">195u8 </span>, <span class="number">5u32 </span>=&gt; <span class="number">217u8 </span>, <span class="number">177u32 </span>=&gt; <span class="number">240u8 </span>, <span class="number">12918u32 </span>=&gt; <span class="number">139u8 </span>, <span class="number">268u32 </span>=&gt; <span class="number">14u8 </span>, <span class="number">282u32 </span>=&gt; <span class="number">123u8 </span>, <span class="number">380u32 </span>=&gt; <span class="number">232u8 </span>, <span class="number">11u32 </span>=&gt; <span class="number">89u8 </span>, <span class="number">176u32 </span>=&gt; <span class="number">234u8 </span>, <span class="number">80u32 </span>=&gt; <span class="number">14u8 </span>, <span class="number">66u32 </span>=&gt; <span class="number">148u8 </span>, <span class="number">21u32 </span>=&gt; <span class="number">159u8 </span>, <span class="number">102u32 </span>=&gt; <span class="number">158u8 </span>, <span class="number">263u32 </span>=&gt; <span class="number">133u8 </span>, <span class="number">144u32 </span>=&gt; <span class="number">127u8 </span>, <span class="number">0u32 </span>=&gt; <span class="number">50u8 </span>, <span class="number">171u32 </span>=&gt; <span class="number">181u8 </span>, <span class="number">50002u32 </span>=&gt; <span class="number">181u8 </span>, <span class="number">215u32 </span>=&gt; <span class="number">101u8 </span>, <span class="number">34u32 </span>=&gt; <span class="number">237u8 </span>, <span class="number">51u32 </span>=&gt; <span class="number">196u8 </span>, <span class="number">386u32 </span>=&gt; <span class="number">132u8 </span>, <span class="number">113u32 </span>=&gt; <span class="number">124u8 </span>, <span class="number">373u32 </span>=&gt; <span class="number">117u8 </span>, <span class="number">280u32 </span>=&gt; <span class="number">70u8 </span>, <span class="number">135u32 </span>=&gt; <span class="number">203u8 </span>, <span class="number">181u32 </span>=&gt; <span class="number">174u8 </span>, <span class="number">271u32 </span>=&gt; <span class="number">22u8 </span>, <span class="number">20u32 </span>=&gt; <span class="number">214u8 </span>, <span class="number">38u32 </span>=&gt; <span class="number">9u8 </span>, <span class="number">10001u32 </span>=&gt; <span class="number">209u8 </span>, <span class="number">259u32 </span>=&gt; <span class="number">92u8 </span>, <span class="number">11038u32 </span>=&gt; <span class="number">47u8 </span>, <span class="number">67u32 </span>=&gt; <span class="number">21u8 </span>, <span class="number">76u32 </span>=&gt; <span class="number">152u8 </span>, <span class="number">256u32 </span>=&gt; <span class="number">71u8 </span>, <span class="number">91u32 </span>=&gt; <span class="number">63u8 </span>, <span class="number">184u32 </span>=&gt; <span class="number">159u8 </span>, <span class="number">105u32 </span>=&gt; <span class="number">93u8 </span>, <span class="number">360u32 </span>=&gt; <span class="number">11u8 </span>, <span class="number">116u32 </span>=&gt; <span class="number">76u8 </span>, <span class="number">156u32 </span>=&gt; <span class="number">19u8 </span>, <span class="number">69u32 </span>=&gt; <span class="number">243u8 </span>, <span class="number">54u32 </span>=&gt; <span class="number">15u8 </span>, <span class="number">165u32 </span>=&gt; <span class="number">21u8 </span>, <span class="number">183u32 </span>=&gt; <span class="number">85u8 </span>, <span class="number">10003u32 </span>=&gt; <span class="number">4u8 </span>, <span class="number">117u32 </span>=&gt; <span class="number">128u8 </span>, <span class="number">128u32 </span>=&gt; <span class="number">226u8 </span>, <span class="number">231u32 </span>=&gt; <span class="number">105u8 </span>, <span class="number">11001u32 </span>=&gt; <span class="number">15u8 </span>, <span class="number">132u32 </span>=&gt; <span class="number">85u8 </span>, <span class="number">126u32 </span>=&gt; <span class="number">220u8 </span>, <span class="number">121u32 </span>=&gt; <span class="number">237u8 </span>, <span class="number">100u32 </span>=&gt; <span class="number">175u8 </span>, <span class="number">131u32 </span>=&gt; <span class="number">223u8 </span>, <span class="number">118u32 </span>=&gt; <span class="number">56u8 </span>, <span class="number">235u32 </span>=&gt; <span class="number">179u8 </span>, <span class="number">335u32 </span>=&gt; <span class="number">225u8 </span>, <span class="number">413u32 </span>=&gt; <span class="number">77u8 </span>, <span class="number">230u32 </span>=&gt; <span class="number">163u8 </span>, <span class="number">11039u32 </span>=&gt; <span class="number">142u8 </span>, <span class="number">35u32 </span>=&gt; <span class="number">244u8 </span>, <span class="number">130u32 </span>=&gt; <span class="number">29u8 </span>, <span class="number">262u32 </span>=&gt; <span class="number">12u8 </span>, <span class="number">339u32 </span>=&gt; <span class="number">199u8 </span>, <span class="number">233u32 </span>=&gt; <span class="number">35u8 </span>, <span class="number">64u32 </span>=&gt; <span class="number">191u8 </span>, <span class="number">217u32 </span>=&gt; <span class="number">202u8 </span>, <span class="number">12903u32 </span>=&gt; <span class="number">249u8 </span>, <span class="number">11032u32 </span>=&gt; <span class="number">85u8 </span>, <span class="number">125u32 </span>=&gt; <span class="number">203u8 </span>, <span class="number">110u32 </span>=&gt; <span class="number">84u8 </span>, <span class="number">127u32 </span>=&gt; <span class="number">25u8 </span>, <span class="number">45u32 </span>=&gt; <span class="number">232u8 </span>, <span class="number">40u32 </span>=&gt; <span class="number">230u8 </span>, <span class="number">12902u32 </span>=&gt; <span class="number">140u8 </span>, <span class="number">161u32 </span>=&gt; <span class="number">68u8 </span>, <span class="number">218u32 </span>=&gt; <span class="number">17u8 </span>, <span class="number">93u32 </span>=&gt; <span class="number">47u8 </span>, <span class="number">11037u32 </span>=&gt; <span class="number">130u8 </span>, <span class="number">138u32 </span>=&gt; <span class="number">109u8 </span>, <span class="number">12919u32 </span>=&gt; <span class="number">7u8 </span>, <span class="number">86u32 </span>=&gt; <span class="number">5u8 </span>, <span class="number">142u32 </span>=&gt; <span class="number">72u8 </span>, <span class="number">192u32 </span>=&gt; <span class="number">36u8 </span>, <span class="number">92u32 </span>=&gt; <span class="number">54u8 </span>, <span class="number">37u32 </span>=&gt; <span class="number">212u8 </span>, <span class="number">242u32 </span>=&gt; <span class="number">104u8 </span>, <span class="number">28u32 </span>=&gt; <span class="number">67u8 </span>, <span class="number">155u32 </span>=&gt; <span class="number">22u8 </span>, <span class="number">42u32 </span>=&gt; <span class="number">28u8 </span>, <span class="number">11030u32 </span>=&gt; <span class="number">144u8 </span>, <span class="number">12901u32 </span>=&gt; <span class="number">254u8 </span>, <span class="number">191u32 </span>=&gt; <span class="number">92u8 </span>, <span class="number">397u32 </span>=&gt; <span class="number">182u8 </span>, <span class="number">340u32 </span>=&gt; <span class="number">99u8 </span>, <span class="number">85u32 </span>=&gt; <span class="number">140u8 </span>, <span class="number">284u32 </span>=&gt; <span class="number">99u8 </span>, <span class="number">11011u32 </span>=&gt; <span class="number">106u8 </span>, <span class="number">234u32 </span>=&gt; <span class="number">150u8 </span>, <span class="number">136u32 </span>=&gt; <span class="number">1u8 </span>, <span class="number">73u32 </span>=&gt; <span class="number">38u8 </span>, <span class="number">195u32 </span>=&gt; <span class="number">120u8 </span>, <span class="number">112u32 </span>=&gt; <span class="number">174u8 </span>, <span class="number">249u32 </span>=&gt; <span class="number">204u8 </span>, <span class="number">167u32 </span>=&gt; <span class="number">144u8 </span>, <span class="number">11036u32 </span>=&gt; <span class="number">177u8 </span>, <span class="number">185u32 </span>=&gt; <span class="number">186u8 </span>, <span class="number">11003u32 </span>=&gt; <span class="number">64u8 </span>, <span class="number">149u32 </span>=&gt; <span class="number">200u8 </span>, <span class="number">200u32 </span>=&gt; <span class="number">134u8 </span>, <span class="number">275u32 </span>=&gt; <span class="number">126u8 </span>, <span class="number">61u32 </span>=&gt; <span class="number">167u8 </span>, <span class="number">175u32 </span>=&gt; <span class="number">138u8 </span>, <span class="number">143u32 </span>=&gt; <span class="number">131u8 </span>, <span class="number">108u32 </span>=&gt; <span class="number">32u8 </span>, <span class="number">375u32 </span>=&gt; <span class="number">251u8 </span>, <span class="number">12915u32 </span>=&gt; <span class="number">94u8 </span>, <span class="number">103u32 </span>=&gt; <span class="number">208u8 </span>, <span class="number">12900u32 </span>=&gt; <span class="number">114u8 </span>, <span class="number">385u32 </span>=&gt; <span class="number">147u8 </span>, <span class="number">87u32 </span>=&gt; <span class="number">150u8 </span>, <span class="number">150u32 </span>=&gt; <span class="number">134u8 </span>, <span class="number">311u32 </span>=&gt; <span class="number">95u8 </span>, <span class="number">264u32 </span>=&gt; <span class="number">49u8 </span>, <span class="number">166u32 </span>=&gt; <span class="number">21u8 </span>, <span class="number">170u32 </span>=&gt; <span class="number">73u8 </span>, <span class="number">50001u32 </span>=&gt; <span class="number">1u8 </span>, <span class="number">129u32 </span>=&gt; <span class="number">46u8 </span>, <span class="number">288u32 </span>=&gt; <span class="number">20u8 </span>, <span class="number">283u32 </span>=&gt; <span class="number">74u8 </span>, <span class="number">134u32 </span>=&gt; <span class="number">229u8 </span>, <span class="number">140u32 </span>=&gt; <span class="number">181u8 </span>, <span class="number">8u32 </span>=&gt; <span class="number">117u8 </span>, <span class="number">291u32 </span>=&gt; <span class="number">10u8 </span>, <span class="number">253u32 </span>=&gt; <span class="number">83u8 </span>, <span class="number">82u32 </span>=&gt; <span class="number">49u8 </span>, <span class="number">141u32 </span>=&gt; <span class="number">47u8 </span>, <span class="number">49u32 </span>=&gt; <span class="number">39u8 </span>, <span class="number">270u32 </span>=&gt; <span class="number">59u8 </span>, <span class="number">146u32 </span>=&gt; <span class="number">103u8 </span>, <span class="number">50004u32 </span>=&gt; <span class="number">240u8 </span>, <span class="number">43u32 </span>=&gt; <span class="number">132u8 </span>, <span class="number">182u32 </span>=&gt; <span class="number">229u8 </span>, <span class="number">11002u32 </span>=&gt; <span class="number">234u8 </span>, <span class="number">11031u32 </span>=&gt; <span class="number">133u8 </span>, <span class="number">81u32 </span>=&gt; <span class="number">106u8 </span>, <span class="number">310u32 </span>=&gt; <span class="number">28u8 </span>, <span class="number">323u32 </span>=&gt; <span class="number">78u8 </span>, <span class="number">158u32 </span>=&gt; <span class="number">134u8 </span>, <span class="number">174u32 </span>=&gt; <span class="number">167u8 </span>, <span class="number">29u32 </span>=&gt; <span class="number">115u8 </span>, <span class="number">334u32 </span>=&gt; <span class="number">72u8 </span>, <span class="number">1u32 </span>=&gt; <span class="number">124u8 </span>, <span class="number">333u32 </span>=&gt; <span class="number">231u8 </span>, <span class="number">111u32 </span>=&gt; <span class="number">34u8 </span>, <span class="number">157u32 </span>=&gt; <span class="number">21u8 </span>, <span class="number">180u32 </span>=&gt; <span class="number">52u8 </span>, <span class="number">257u32 </span>=&gt; <span class="number">131u8 </span>, <span class="number">179u32 </span>=&gt; <span class="number">189u8 </span>, <span class="number">84u32 </span>=&gt; <span class="number">143u8 </span>, <span class="number">331u32 </span>=&gt; <span class="number">91u8 </span>, <span class="number">24u32 </span>=&gt; <span class="number">24u8 </span>, <span class="number">214u32 </span>=&gt; <span class="number">69u8 </span>, <span class="number">11033u32 </span>=&gt; <span class="number">195u8 </span>, <span class="number">169u32 </span>=&gt; <span class="number">234u8 </span>, <span class="number">194u32 </span>=&gt; <span class="number">98u8 </span>, <span class="number">330u32 </span>=&gt; <span class="number">23u8 </span>, <span class="number">75u32 </span>=&gt; <span class="number">158u8 </span>, <span class="number">77u32 </span>=&gt; <span class="number">143u8 </span>, <span class="number">42000u32 </span>=&gt; <span class="number">227u8 </span>, <span class="number">41u32 </span>=&gt; <span class="number">28u8 </span>, <span class="number">332u32 </span>=&gt; <span class="number">236u8 </span>, <span class="number">9005u32 </span>=&gt; <span class="number">117u8 </span>, <span class="number">321u32 </span>=&gt; <span class="number">88u8 </span>, <span class="number">42001u32 </span>=&gt; <span class="number">239u8 </span>, <span class="number">50005u32 </span>=&gt; <span class="number">152u8 </span>, <span class="number">163u32 </span>=&gt; <span class="number">127u8 </span>, <span class="number">388u32 </span>=&gt; <span class="number">8u8 </span>, <span class="number">243u32 </span>=&gt; <span class="number">85u8 </span>, <span class="number">25u32 </span>=&gt; <span class="number">23u8 </span>, <span class="number">27u32 </span>=&gt; <span class="number">144u8 </span>, <span class="number">219u32 </span>=&gt; <span class="number">162u8 </span>, <span class="number">266u32 </span>=&gt; <span class="number">193u8 </span>, <span class="number">164u32 </span>=&gt; <span class="number">154u8 </span>, <span class="number">31u32 </span>=&gt; <span class="number">246u8 </span>, <span class="number">114u32 </span>=&gt; <span class="number">237u8 </span>, <span class="number">226u32 </span>=&gt; <span class="number">207u8 </span>, <span class="number">11034u32 </span>=&gt; <span class="number">79u8 </span>, <span class="number">300u32 </span>=&gt; <span class="number">217u8 </span>, <span class="number">83u32 </span>=&gt; <span class="number">22u8 </span>, <span class="number">23u32 </span>=&gt; <span class="number">168u8 </span>, <span class="number">178u32 </span>=&gt; <span class="number">47u8 </span>, <span class="number">168u32 </span>=&gt; <span class="number">1u8 </span>, <span class="number">104u32 </span>=&gt; <span class="number">56u8 </span>, <span class="number">44u32 </span>=&gt; <span class="number">221u8 </span>, <span class="number">89u32 </span>=&gt; <span class="number">231u8 </span>, <span class="number">251u32 </span>=&gt; <span class="number">170u8 </span>, <span class="number">400u32 </span>=&gt; <span class="number">110u8 </span>, <span class="number">152u32 </span>=&gt; <span class="number">208u8 </span>, <span class="number">172u32 </span>=&gt; <span class="number">22u8 </span>, <span class="number">201u32 </span>=&gt; <span class="number">205u8 </span>, <span class="number">120u32 </span>=&gt; <span class="number">134u8 </span>, <span class="number">48u32 </span>=&gt; <span class="number">41u8 </span>, <span class="number">265u32 </span>=&gt; <span class="number">26u8 </span>, <span class="number">124u32 </span>=&gt; <span class="number">87u8 </span>, <span class="number">101u32 </span>=&gt; <span class="number">102u8 </span>, <span class="number">50003u32 </span>=&gt; <span class="number">53u8 </span>, <span class="number">276u32 </span>=&gt; <span class="number">18u8 </span>, <span class="number">411u32 </span>=&gt; <span class="number">106u8 </span>, <span class="number">244u32 </span>=&gt; <span class="number">95u8 </span>, <span class="number">39u32 </span>=&gt; <span class="number">254u8 </span>, <span class="number">109u32 </span>=&gt; <span class="number">185u8 </span>, <span class="number">162u32 </span>=&gt; <span class="number">189u8 </span>, <span class="number">107u32 </span>=&gt; <span class="number">108u8 </span>, <span class="number">47u32 </span>=&gt; <span class="number">153u8 </span>, <span class="number">63u32 </span>=&gt; <span class="number">119u8 </span>, <span class="number">336u32 </span>=&gt; <span class="number">245u8 </span>, <span class="number">269u32 </span>=&gt; <span class="number">109u8 </span>, <span class="number">246u32 </span>=&gt; <span class="number">184u8 </span>, <span class="number">12904u32 </span>=&gt; <span class="number">77u8 </span>, <span class="number">232u32 </span>=&gt; <span class="number">151u8 </span>, <span class="number">281u32 </span>=&gt; <span class="number">48u8 </span>, <span class="number">245u32 </span>=&gt; <span class="number">130u8 </span>, <span class="number">12905u32 </span>=&gt; <span class="number">49u8 </span>, <span class="number">139u32 </span>=&gt; <span class="number">168u8 </span>, <span class="number">350u32 </span>=&gt; <span class="number">232u8 </span>, <span class="number">153u32 </span>=&gt; <span class="number">188u8 </span>, <span class="number">370u32 </span>=&gt; <span class="number">75u8 </span>, <span class="number">122u32 </span>=&gt; <span class="number">203u8 </span>, <span class="number">287u32 </span>=&gt; <span class="number">1u8 </span>, <span class="number">395u32 </span>=&gt; <span class="number">0u8 </span>, <span class="number">36u32 </span>=&gt; <span class="number">222u8 </span>, <span class="number">30u32 </span>=&gt; <span class="number">39u8 </span>, <span class="number">290u32 </span>=&gt; <span class="number">251u8 </span>, <span class="number">4u32 </span>=&gt; <span class="number">237u8 </span>, <span class="number">322u32 </span>=&gt; <span class="number">243u8 </span>, <span class="number">286u32 </span>=&gt; <span class="number">210u8 </span>, <span class="number">148u32 </span>=&gt; <span class="number">178u8 </span>, <span class="number">62u32 </span>=&gt; <span class="number">183u8 </span>, <span class="number">46u32 </span>=&gt; <span class="number">11u8 </span>, <span class="number">225u32 </span>=&gt; <span class="number">208u8 </span>, <span class="number">151u32 </span>=&gt; <span class="number">219u8 </span>, <span class="number">250u32 </span>=&gt; <span class="number">49u8 </span>, <span class="number">2u32 </span>=&gt; <span class="number">137u8 </span>, <span class="number">6u32 </span>=&gt; <span class="number">104u8 </span>, <span class="kw">_ </span>=&gt; { <span class="number">0 </span>} , } } }
</code></pre></div>
</section></main><div id="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="mavlink" data-themes="" data-resource-suffix="" data-rustdoc-version="1.69.0 (84c898d65 2023-04-16)" data-search-js="search-8a59a8356673ec1f.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>